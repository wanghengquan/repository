//----------------------------------------------------------------------------
// Date		: $Date: 2011/06/01 15:12:35 $
// Copyright	: 1997-2011 by Synopsys, Inc., All Rights Reserved.
// Revision	: Version $Revision: 1.3 $
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Cell model definitions.
//----------------------------------------------------------------------------

`resetall


`timescale 100ps / 1ps

`ifdef VIRL_functiononly
    `delay_mode_distributed
`else
    `delay_mode_path
`endif

//%BEGIN SEH_ADDF42_0P5

`celldefine
module SEH_ADDF42_0P5 (S, CO, ICO, A, B, C, D, CI);
   output S, CO, ICO;
   input A, B, C, D, CI;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A, B, C);
   and (int_res_1, int_res_0, D);
   xor (int_res_2, A, B, C);
   and (int_res_3, int_res_2, CI);
   and (int_res_4, D, CI);
   and (int_res_5, A, B);
   and (int_res_6, A, C);
   and (int_res_7, B, C);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      xor #1 (S, A, B, C, D, CI);
      or #1 (CO, int_res_1, int_res_3, int_res_4);
      or #1 (ICO, int_res_5, int_res_6, int_res_7);
   `else
      xor (S, A, B, C, D, CI);
      or (CO, int_res_1, int_res_3, int_res_4);
      or (ICO, int_res_5, int_res_6, int_res_7);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((B & C & CI & ~(D)))
         (A => CO) = 0;
      if ((B & C & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => CO) = 0;
      if ((A & C & CI & ~(D)))
         (B => CO) = 0;
      if ((A & C & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => CO) = 0;
      if ((A & B & CI & ~(D)))
         (C => CO) = 0;
      if ((A & B & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => CO) = 0;
      (CI => CO) = 0;
      if ((A & B & C & ~(CI)))
         (D => CO) = 0;
      if ((A & B & ~(C) & CI))
         (D => CO) = 0;
      if ((A & ~(B) & C & CI))
         (D => CO) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & B & C & CI))
         (D => CO) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => CO) = 0;
      if ((B & ~(C) & CI & D))
         (A => ICO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & CI & D))
         (A => ICO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((A & ~(C) & CI & D))
         (B => ICO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & CI & D))
         (B => ICO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(B) & CI & D))
         (C => ICO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & CI & D))
         (C => ICO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((B & C & CI & D))
         (A => S) = 0;
      if ((B & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & C & CI & ~(D)))
         (A => S) = 0;
      if ((B & C & ~(CI) & D))
         (A => S) = 0;
      if ((B & ~(C) & CI & D))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & CI & D))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((A & C & CI & D))
         (B => S) = 0;
      if ((A & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & C & CI & ~(D)))
         (B => S) = 0;
      if ((A & C & ~(CI) & D))
         (B => S) = 0;
      if ((A & ~(C) & CI & D))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & CI & D))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((A & B & CI & D))
         (C => S) = 0;
      if ((A & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & B & CI & ~(D)))
         (C => S) = 0;
      if ((A & B & ~(CI) & D))
         (C => S) = 0;
      if ((A & ~(B) & CI & D))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & CI & D))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((A & B & C & D) | (A & B & ~(C) & ~(D)) | (A & ~(B) & C & ~(D)) | (A & ~(B) & ~(C) & D) | (~(A) & B & C & ~(D)) | (~(A) & B & ~(C) & D) | (~(A) & ~(B) & C & D) | (~(A) & ~(B) & ~(C) & ~(D)))
         (CI => S) = 0;
      if ((A & B & C & ~(D)) | (A & B & ~(C) & D) | (A & ~(B) & C & D) | (A & ~(B) & ~(C) & ~(D)) | (~(A) & B & C & D) | (~(A) & B & ~(C) & ~(D)) | (~(A) & ~(B) & C & ~(D)) | (~(A) & ~(B) & ~(C) & D))
         (CI => S) = 0;
      if ((A & B & C & CI))
         (D => S) = 0;
      if ((A & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & B & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & B & C & ~(CI)))
         (D => S) = 0;
      if ((A & B & ~(C) & CI))
         (D => S) = 0;
      if ((A & ~(B) & C & CI))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & C & CI))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF42_0P5

//%BEGIN SEH_ADDF42_1

`celldefine
module SEH_ADDF42_1 (S, CO, ICO, A, B, C, D, CI);
   output S, CO, ICO;
   input A, B, C, D, CI;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A, B, C);
   and (int_res_1, int_res_0, D);
   xor (int_res_2, A, B, C);
   and (int_res_3, int_res_2, CI);
   and (int_res_4, D, CI);
   and (int_res_5, A, B);
   and (int_res_6, A, C);
   and (int_res_7, B, C);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      xor #1 (S, A, B, C, D, CI);
      or #1 (CO, int_res_1, int_res_3, int_res_4);
      or #1 (ICO, int_res_5, int_res_6, int_res_7);
   `else
      xor (S, A, B, C, D, CI);
      or (CO, int_res_1, int_res_3, int_res_4);
      or (ICO, int_res_5, int_res_6, int_res_7);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((B & C & CI & ~(D)))
         (A => CO) = 0;
      if ((B & C & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => CO) = 0;
      if ((A & C & CI & ~(D)))
         (B => CO) = 0;
      if ((A & C & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => CO) = 0;
      if ((A & B & CI & ~(D)))
         (C => CO) = 0;
      if ((A & B & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => CO) = 0;
      (CI => CO) = 0;
      if ((A & B & C & ~(CI)))
         (D => CO) = 0;
      if ((A & B & ~(C) & CI))
         (D => CO) = 0;
      if ((A & ~(B) & C & CI))
         (D => CO) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & B & C & CI))
         (D => CO) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => CO) = 0;
      if ((B & ~(C) & CI & D))
         (A => ICO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & CI & D))
         (A => ICO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((A & ~(C) & CI & D))
         (B => ICO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & CI & D))
         (B => ICO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(B) & CI & D))
         (C => ICO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & CI & D))
         (C => ICO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((B & C & CI & D))
         (A => S) = 0;
      if ((B & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & C & CI & ~(D)))
         (A => S) = 0;
      if ((B & C & ~(CI) & D))
         (A => S) = 0;
      if ((B & ~(C) & CI & D))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & CI & D))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((A & C & CI & D))
         (B => S) = 0;
      if ((A & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & C & CI & ~(D)))
         (B => S) = 0;
      if ((A & C & ~(CI) & D))
         (B => S) = 0;
      if ((A & ~(C) & CI & D))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & CI & D))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((A & B & CI & D))
         (C => S) = 0;
      if ((A & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & B & CI & ~(D)))
         (C => S) = 0;
      if ((A & B & ~(CI) & D))
         (C => S) = 0;
      if ((A & ~(B) & CI & D))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & CI & D))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((A & B & C & D) | (A & B & ~(C) & ~(D)) | (A & ~(B) & C & ~(D)) | (A & ~(B) & ~(C) & D) | (~(A) & B & C & ~(D)) | (~(A) & B & ~(C) & D) | (~(A) & ~(B) & C & D) | (~(A) & ~(B) & ~(C) & ~(D)))
         (CI => S) = 0;
      if ((A & B & C & ~(D)) | (A & B & ~(C) & D) | (A & ~(B) & C & D) | (A & ~(B) & ~(C) & ~(D)) | (~(A) & B & C & D) | (~(A) & B & ~(C) & ~(D)) | (~(A) & ~(B) & C & ~(D)) | (~(A) & ~(B) & ~(C) & D))
         (CI => S) = 0;
      if ((A & B & C & CI))
         (D => S) = 0;
      if ((A & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & B & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & B & C & ~(CI)))
         (D => S) = 0;
      if ((A & B & ~(C) & CI))
         (D => S) = 0;
      if ((A & ~(B) & C & CI))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & C & CI))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF42_1

//%BEGIN SEH_ADDF42_2

`celldefine
module SEH_ADDF42_2 (S, CO, ICO, A, B, C, D, CI);
   output S, CO, ICO;
   input A, B, C, D, CI;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A, B, C);
   and (int_res_1, int_res_0, D);
   xor (int_res_2, A, B, C);
   and (int_res_3, int_res_2, CI);
   and (int_res_4, D, CI);
   and (int_res_5, A, B);
   and (int_res_6, A, C);
   and (int_res_7, B, C);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      xor #1 (S, A, B, C, D, CI);
      or #1 (CO, int_res_1, int_res_3, int_res_4);
      or #1 (ICO, int_res_5, int_res_6, int_res_7);
   `else
      xor (S, A, B, C, D, CI);
      or (CO, int_res_1, int_res_3, int_res_4);
      or (ICO, int_res_5, int_res_6, int_res_7);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((B & C & CI & ~(D)))
         (A => CO) = 0;
      if ((B & C & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => CO) = 0;
      if ((A & C & CI & ~(D)))
         (B => CO) = 0;
      if ((A & C & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => CO) = 0;
      if ((A & B & CI & ~(D)))
         (C => CO) = 0;
      if ((A & B & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => CO) = 0;
      (CI => CO) = 0;
      if ((A & B & C & ~(CI)))
         (D => CO) = 0;
      if ((A & B & ~(C) & CI))
         (D => CO) = 0;
      if ((A & ~(B) & C & CI))
         (D => CO) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & B & C & CI))
         (D => CO) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => CO) = 0;
      if ((B & ~(C) & CI & D))
         (A => ICO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & CI & D))
         (A => ICO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((A & ~(C) & CI & D))
         (B => ICO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & CI & D))
         (B => ICO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(B) & CI & D))
         (C => ICO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & CI & D))
         (C => ICO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((B & C & CI & D))
         (A => S) = 0;
      if ((B & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & C & CI & ~(D)))
         (A => S) = 0;
      if ((B & C & ~(CI) & D))
         (A => S) = 0;
      if ((B & ~(C) & CI & D))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & CI & D))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((A & C & CI & D))
         (B => S) = 0;
      if ((A & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & C & CI & ~(D)))
         (B => S) = 0;
      if ((A & C & ~(CI) & D))
         (B => S) = 0;
      if ((A & ~(C) & CI & D))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & CI & D))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((A & B & CI & D))
         (C => S) = 0;
      if ((A & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & B & CI & ~(D)))
         (C => S) = 0;
      if ((A & B & ~(CI) & D))
         (C => S) = 0;
      if ((A & ~(B) & CI & D))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & CI & D))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((A & B & C & D) | (A & B & ~(C) & ~(D)) | (A & ~(B) & C & ~(D)) | (A & ~(B) & ~(C) & D) | (~(A) & B & C & ~(D)) | (~(A) & B & ~(C) & D) | (~(A) & ~(B) & C & D) | (~(A) & ~(B) & ~(C) & ~(D)))
         (CI => S) = 0;
      if ((A & B & C & ~(D)) | (A & B & ~(C) & D) | (A & ~(B) & C & D) | (A & ~(B) & ~(C) & ~(D)) | (~(A) & B & C & D) | (~(A) & B & ~(C) & ~(D)) | (~(A) & ~(B) & C & ~(D)) | (~(A) & ~(B) & ~(C) & D))
         (CI => S) = 0;
      if ((A & B & C & CI))
         (D => S) = 0;
      if ((A & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & B & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & B & C & ~(CI)))
         (D => S) = 0;
      if ((A & B & ~(C) & CI))
         (D => S) = 0;
      if ((A & ~(B) & C & CI))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & C & CI))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF42_2

//%BEGIN SEH_ADDF42_GY2_2

`celldefine
module SEH_ADDF42_GY2_2 (S, CO, ICO, A, B, C, D, CI);
   output S, CO, ICO;
   input A, B, C, D, CI;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A, B, C);
   and (int_res_1, int_res_0, D);
   xor (int_res_2, A, B, C);
   and (int_res_3, int_res_2, CI);
   and (int_res_4, D, CI);
   and (int_res_5, A, B);
   and (int_res_6, A, C);
   and (int_res_7, B, C);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      xor #1 (S, A, B, C, D, CI);
      or #1 (CO, int_res_1, int_res_3, int_res_4);
      or #1 (ICO, int_res_5, int_res_6, int_res_7);
   `else
      xor (S, A, B, C, D, CI);
      or (CO, int_res_1, int_res_3, int_res_4);
      or (ICO, int_res_5, int_res_6, int_res_7);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((B & C & CI & ~(D)))
         (A => CO) = 0;
      if ((B & C & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => CO) = 0;
      if ((A & C & CI & ~(D)))
         (B => CO) = 0;
      if ((A & C & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => CO) = 0;
      if ((A & B & CI & ~(D)))
         (C => CO) = 0;
      if ((A & B & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => CO) = 0;
      (CI => CO) = 0;
      if ((A & B & C & ~(CI)))
         (D => CO) = 0;
      if ((A & B & ~(C) & CI))
         (D => CO) = 0;
      if ((A & ~(B) & C & CI))
         (D => CO) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & B & C & CI))
         (D => CO) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => CO) = 0;
      if ((B & ~(C) & CI & D))
         (A => ICO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & CI & D))
         (A => ICO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((A & ~(C) & CI & D))
         (B => ICO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & CI & D))
         (B => ICO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(B) & CI & D))
         (C => ICO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & CI & D))
         (C => ICO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((B & C & CI & D))
         (A => S) = 0;
      if ((B & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & C & CI & ~(D)))
         (A => S) = 0;
      if ((B & C & ~(CI) & D))
         (A => S) = 0;
      if ((B & ~(C) & CI & D))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & CI & D))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((A & C & CI & D))
         (B => S) = 0;
      if ((A & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & C & CI & ~(D)))
         (B => S) = 0;
      if ((A & C & ~(CI) & D))
         (B => S) = 0;
      if ((A & ~(C) & CI & D))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & CI & D))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((A & B & CI & D))
         (C => S) = 0;
      if ((A & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & B & CI & ~(D)))
         (C => S) = 0;
      if ((A & B & ~(CI) & D))
         (C => S) = 0;
      if ((A & ~(B) & CI & D))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & CI & D))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((A & B & C & D) | (A & B & ~(C) & ~(D)) | (A & ~(B) & C & ~(D)) | (A & ~(B) & ~(C) & D) | (~(A) & B & C & ~(D)) | (~(A) & B & ~(C) & D) | (~(A) & ~(B) & C & D) | (~(A) & ~(B) & ~(C) & ~(D)))
         (CI => S) = 0;
      if ((A & B & C & ~(D)) | (A & B & ~(C) & D) | (A & ~(B) & C & D) | (A & ~(B) & ~(C) & ~(D)) | (~(A) & B & C & D) | (~(A) & B & ~(C) & ~(D)) | (~(A) & ~(B) & C & ~(D)) | (~(A) & ~(B) & ~(C) & D))
         (CI => S) = 0;
      if ((A & B & C & CI))
         (D => S) = 0;
      if ((A & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & B & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & B & C & ~(CI)))
         (D => S) = 0;
      if ((A & B & ~(C) & CI))
         (D => S) = 0;
      if ((A & ~(B) & C & CI))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & C & CI))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF42_GY2_2

//%BEGIN SEH_ADDF42_GY2_3

`celldefine
module SEH_ADDF42_GY2_3 (S, CO, ICO, A, B, C, D, CI);
   output S, CO, ICO;
   input A, B, C, D, CI;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A, B, C);
   and (int_res_1, int_res_0, D);
   xor (int_res_2, A, B, C);
   and (int_res_3, int_res_2, CI);
   and (int_res_4, D, CI);
   and (int_res_5, A, B);
   and (int_res_6, A, C);
   and (int_res_7, B, C);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      xor #1 (S, A, B, C, D, CI);
      or #1 (CO, int_res_1, int_res_3, int_res_4);
      or #1 (ICO, int_res_5, int_res_6, int_res_7);
   `else
      xor (S, A, B, C, D, CI);
      or (CO, int_res_1, int_res_3, int_res_4);
      or (ICO, int_res_5, int_res_6, int_res_7);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((B & C & CI & ~(D)))
         (A => CO) = 0;
      if ((B & C & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => CO) = 0;
      if ((A & C & CI & ~(D)))
         (B => CO) = 0;
      if ((A & C & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => CO) = 0;
      if ((A & B & CI & ~(D)))
         (C => CO) = 0;
      if ((A & B & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => CO) = 0;
      (CI => CO) = 0;
      if ((A & B & C & ~(CI)))
         (D => CO) = 0;
      if ((A & B & ~(C) & CI))
         (D => CO) = 0;
      if ((A & ~(B) & C & CI))
         (D => CO) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & B & C & CI))
         (D => CO) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => CO) = 0;
      if ((B & ~(C) & CI & D))
         (A => ICO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & CI & D))
         (A => ICO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((A & ~(C) & CI & D))
         (B => ICO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & CI & D))
         (B => ICO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(B) & CI & D))
         (C => ICO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & CI & D))
         (C => ICO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((B & C & CI & D))
         (A => S) = 0;
      if ((B & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & C & CI & ~(D)))
         (A => S) = 0;
      if ((B & C & ~(CI) & D))
         (A => S) = 0;
      if ((B & ~(C) & CI & D))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & CI & D))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((A & C & CI & D))
         (B => S) = 0;
      if ((A & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & C & CI & ~(D)))
         (B => S) = 0;
      if ((A & C & ~(CI) & D))
         (B => S) = 0;
      if ((A & ~(C) & CI & D))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & CI & D))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((A & B & CI & D))
         (C => S) = 0;
      if ((A & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & B & CI & ~(D)))
         (C => S) = 0;
      if ((A & B & ~(CI) & D))
         (C => S) = 0;
      if ((A & ~(B) & CI & D))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & CI & D))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((A & B & C & D) | (A & B & ~(C) & ~(D)) | (A & ~(B) & C & ~(D)) | (A & ~(B) & ~(C) & D) | (~(A) & B & C & ~(D)) | (~(A) & B & ~(C) & D) | (~(A) & ~(B) & C & D) | (~(A) & ~(B) & ~(C) & ~(D)))
         (CI => S) = 0;
      if ((A & B & C & ~(D)) | (A & B & ~(C) & D) | (A & ~(B) & C & D) | (A & ~(B) & ~(C) & ~(D)) | (~(A) & B & C & D) | (~(A) & B & ~(C) & ~(D)) | (~(A) & ~(B) & C & ~(D)) | (~(A) & ~(B) & ~(C) & D))
         (CI => S) = 0;
      if ((A & B & C & CI))
         (D => S) = 0;
      if ((A & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & B & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & B & C & ~(CI)))
         (D => S) = 0;
      if ((A & B & ~(C) & CI))
         (D => S) = 0;
      if ((A & ~(B) & C & CI))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & C & CI))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF42_GY2_3

//%BEGIN SEH_ADDF42_GY2_4

`celldefine
module SEH_ADDF42_GY2_4 (S, CO, ICO, A, B, C, D, CI);
   output S, CO, ICO;
   input A, B, C, D, CI;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A, B, C);
   and (int_res_1, int_res_0, D);
   xor (int_res_2, A, B, C);
   and (int_res_3, int_res_2, CI);
   and (int_res_4, D, CI);
   and (int_res_5, A, B);
   and (int_res_6, A, C);
   and (int_res_7, B, C);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      xor #1 (S, A, B, C, D, CI);
      or #1 (CO, int_res_1, int_res_3, int_res_4);
      or #1 (ICO, int_res_5, int_res_6, int_res_7);
   `else
      xor (S, A, B, C, D, CI);
      or (CO, int_res_1, int_res_3, int_res_4);
      or (ICO, int_res_5, int_res_6, int_res_7);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((B & C & CI & ~(D)))
         (A => CO) = 0;
      if ((B & C & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => CO) = 0;
      if ((A & C & CI & ~(D)))
         (B => CO) = 0;
      if ((A & C & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => CO) = 0;
      if ((A & B & CI & ~(D)))
         (C => CO) = 0;
      if ((A & B & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => CO) = 0;
      (CI => CO) = 0;
      if ((A & B & C & ~(CI)))
         (D => CO) = 0;
      if ((A & B & ~(C) & CI))
         (D => CO) = 0;
      if ((A & ~(B) & C & CI))
         (D => CO) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & B & C & CI))
         (D => CO) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => CO) = 0;
      if ((B & ~(C) & CI & D))
         (A => ICO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & CI & D))
         (A => ICO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((A & ~(C) & CI & D))
         (B => ICO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & CI & D))
         (B => ICO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(B) & CI & D))
         (C => ICO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & CI & D))
         (C => ICO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((B & C & CI & D))
         (A => S) = 0;
      if ((B & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & C & CI & ~(D)))
         (A => S) = 0;
      if ((B & C & ~(CI) & D))
         (A => S) = 0;
      if ((B & ~(C) & CI & D))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & CI & D))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((A & C & CI & D))
         (B => S) = 0;
      if ((A & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & C & CI & ~(D)))
         (B => S) = 0;
      if ((A & C & ~(CI) & D))
         (B => S) = 0;
      if ((A & ~(C) & CI & D))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & CI & D))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((A & B & CI & D))
         (C => S) = 0;
      if ((A & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & B & CI & ~(D)))
         (C => S) = 0;
      if ((A & B & ~(CI) & D))
         (C => S) = 0;
      if ((A & ~(B) & CI & D))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & CI & D))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((A & B & C & D) | (A & B & ~(C) & ~(D)) | (A & ~(B) & C & ~(D)) | (A & ~(B) & ~(C) & D) | (~(A) & B & C & ~(D)) | (~(A) & B & ~(C) & D) | (~(A) & ~(B) & C & D) | (~(A) & ~(B) & ~(C) & ~(D)))
         (CI => S) = 0;
      if ((A & B & C & ~(D)) | (A & B & ~(C) & D) | (A & ~(B) & C & D) | (A & ~(B) & ~(C) & ~(D)) | (~(A) & B & C & D) | (~(A) & B & ~(C) & ~(D)) | (~(A) & ~(B) & C & ~(D)) | (~(A) & ~(B) & ~(C) & D))
         (CI => S) = 0;
      if ((A & B & C & CI))
         (D => S) = 0;
      if ((A & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & B & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & B & C & ~(CI)))
         (D => S) = 0;
      if ((A & B & ~(C) & CI))
         (D => S) = 0;
      if ((A & ~(B) & C & CI))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & C & CI))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF42_GY2_4

//%BEGIN SEH_ADDF42_GY2_6

`celldefine
module SEH_ADDF42_GY2_6 (S, CO, ICO, A, B, C, D, CI);
   output S, CO, ICO;
   input A, B, C, D, CI;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A, B, C);
   and (int_res_1, int_res_0, D);
   xor (int_res_2, A, B, C);
   and (int_res_3, int_res_2, CI);
   and (int_res_4, D, CI);
   and (int_res_5, A, B);
   and (int_res_6, A, C);
   and (int_res_7, B, C);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      xor #1 (S, A, B, C, D, CI);
      or #1 (CO, int_res_1, int_res_3, int_res_4);
      or #1 (ICO, int_res_5, int_res_6, int_res_7);
   `else
      xor (S, A, B, C, D, CI);
      or (CO, int_res_1, int_res_3, int_res_4);
      or (ICO, int_res_5, int_res_6, int_res_7);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((B & C & CI & ~(D)))
         (A => CO) = 0;
      if ((B & C & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => CO) = 0;
      if ((A & C & CI & ~(D)))
         (B => CO) = 0;
      if ((A & C & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => CO) = 0;
      if ((A & B & CI & ~(D)))
         (C => CO) = 0;
      if ((A & B & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => CO) = 0;
      (CI => CO) = 0;
      if ((A & B & C & ~(CI)))
         (D => CO) = 0;
      if ((A & B & ~(C) & CI))
         (D => CO) = 0;
      if ((A & ~(B) & C & CI))
         (D => CO) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & B & C & CI))
         (D => CO) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => CO) = 0;
      if ((B & ~(C) & CI & D))
         (A => ICO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & CI & D))
         (A => ICO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((A & ~(C) & CI & D))
         (B => ICO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & CI & D))
         (B => ICO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(B) & CI & D))
         (C => ICO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & CI & D))
         (C => ICO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((B & C & CI & D))
         (A => S) = 0;
      if ((B & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & C & CI & ~(D)))
         (A => S) = 0;
      if ((B & C & ~(CI) & D))
         (A => S) = 0;
      if ((B & ~(C) & CI & D))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & CI & D))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((A & C & CI & D))
         (B => S) = 0;
      if ((A & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & C & CI & ~(D)))
         (B => S) = 0;
      if ((A & C & ~(CI) & D))
         (B => S) = 0;
      if ((A & ~(C) & CI & D))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & CI & D))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((A & B & CI & D))
         (C => S) = 0;
      if ((A & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & B & CI & ~(D)))
         (C => S) = 0;
      if ((A & B & ~(CI) & D))
         (C => S) = 0;
      if ((A & ~(B) & CI & D))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & CI & D))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((A & B & C & D) | (A & B & ~(C) & ~(D)) | (A & ~(B) & C & ~(D)) | (A & ~(B) & ~(C) & D) | (~(A) & B & C & ~(D)) | (~(A) & B & ~(C) & D) | (~(A) & ~(B) & C & D) | (~(A) & ~(B) & ~(C) & ~(D)))
         (CI => S) = 0;
      if ((A & B & C & ~(D)) | (A & B & ~(C) & D) | (A & ~(B) & C & D) | (A & ~(B) & ~(C) & ~(D)) | (~(A) & B & C & D) | (~(A) & B & ~(C) & ~(D)) | (~(A) & ~(B) & C & ~(D)) | (~(A) & ~(B) & ~(C) & D))
         (CI => S) = 0;
      if ((A & B & C & CI))
         (D => S) = 0;
      if ((A & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & B & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & B & C & ~(CI)))
         (D => S) = 0;
      if ((A & B & ~(C) & CI))
         (D => S) = 0;
      if ((A & ~(B) & C & CI))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & C & CI))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF42_GY2_6

//%BEGIN SEH_ADDF42_GY2_8

`celldefine
module SEH_ADDF42_GY2_8 (S, CO, ICO, A, B, C, D, CI);
   output S, CO, ICO;
   input A, B, C, D, CI;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A, B, C);
   and (int_res_1, int_res_0, D);
   xor (int_res_2, A, B, C);
   and (int_res_3, int_res_2, CI);
   and (int_res_4, D, CI);
   and (int_res_5, A, B);
   and (int_res_6, A, C);
   and (int_res_7, B, C);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      xor #1 (S, A, B, C, D, CI);
      or #1 (CO, int_res_1, int_res_3, int_res_4);
      or #1 (ICO, int_res_5, int_res_6, int_res_7);
   `else
      xor (S, A, B, C, D, CI);
      or (CO, int_res_1, int_res_3, int_res_4);
      or (ICO, int_res_5, int_res_6, int_res_7);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((B & C & CI & ~(D)))
         (A => CO) = 0;
      if ((B & C & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => CO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => CO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => CO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => CO) = 0;
      if ((A & C & CI & ~(D)))
         (B => CO) = 0;
      if ((A & C & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => CO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => CO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => CO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => CO) = 0;
      if ((A & B & CI & ~(D)))
         (C => CO) = 0;
      if ((A & B & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => CO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => CO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => CO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => CO) = 0;
      (CI => CO) = 0;
      if ((A & B & C & ~(CI)))
         (D => CO) = 0;
      if ((A & B & ~(C) & CI))
         (D => CO) = 0;
      if ((A & ~(B) & C & CI))
         (D => CO) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & B & C & CI))
         (D => CO) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => CO) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => CO) = 0;
      if ((B & ~(C) & CI & D))
         (A => ICO) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => ICO) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & CI & D))
         (A => ICO) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => ICO) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => ICO) = 0;
      if ((A & ~(C) & CI & D))
         (B => ICO) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => ICO) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & CI & D))
         (B => ICO) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => ICO) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => ICO) = 0;
      if ((A & ~(B) & CI & D))
         (C => ICO) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => ICO) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & CI & D))
         (C => ICO) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => ICO) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => ICO) = 0;
      if ((B & C & CI & D))
         (A => S) = 0;
      if ((B & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & C & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & D))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((B & C & CI & ~(D)))
         (A => S) = 0;
      if ((B & C & ~(CI) & D))
         (A => S) = 0;
      if ((B & ~(C) & CI & D))
         (A => S) = 0;
      if ((B & ~(C) & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & C & CI & D))
         (A => S) = 0;
      if ((~(B) & C & ~(CI) & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & CI & ~(D)))
         (A => S) = 0;
      if ((~(B) & ~(C) & ~(CI) & D))
         (A => S) = 0;
      if ((A & C & CI & D))
         (B => S) = 0;
      if ((A & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & C & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & D))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((A & C & CI & ~(D)))
         (B => S) = 0;
      if ((A & C & ~(CI) & D))
         (B => S) = 0;
      if ((A & ~(C) & CI & D))
         (B => S) = 0;
      if ((A & ~(C) & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & C & CI & D))
         (B => S) = 0;
      if ((~(A) & C & ~(CI) & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & CI & ~(D)))
         (B => S) = 0;
      if ((~(A) & ~(C) & ~(CI) & D))
         (B => S) = 0;
      if ((A & B & CI & D))
         (C => S) = 0;
      if ((A & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & B & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & D))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((A & B & CI & ~(D)))
         (C => S) = 0;
      if ((A & B & ~(CI) & D))
         (C => S) = 0;
      if ((A & ~(B) & CI & D))
         (C => S) = 0;
      if ((A & ~(B) & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & B & CI & D))
         (C => S) = 0;
      if ((~(A) & B & ~(CI) & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & CI & ~(D)))
         (C => S) = 0;
      if ((~(A) & ~(B) & ~(CI) & D))
         (C => S) = 0;
      if ((A & B & C & D) | (A & B & ~(C) & ~(D)) | (A & ~(B) & C & ~(D)) | (A & ~(B) & ~(C) & D) | (~(A) & B & C & ~(D)) | (~(A) & B & ~(C) & D) | (~(A) & ~(B) & C & D) | (~(A) & ~(B) & ~(C) & ~(D)))
         (CI => S) = 0;
      if ((A & B & C & ~(D)) | (A & B & ~(C) & D) | (A & ~(B) & C & D) | (A & ~(B) & ~(C) & ~(D)) | (~(A) & B & C & D) | (~(A) & B & ~(C) & ~(D)) | (~(A) & ~(B) & C & ~(D)) | (~(A) & ~(B) & ~(C) & D))
         (CI => S) = 0;
      if ((A & B & C & CI))
         (D => S) = 0;
      if ((A & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & B & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & CI))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((A & B & C & ~(CI)))
         (D => S) = 0;
      if ((A & B & ~(C) & CI))
         (D => S) = 0;
      if ((A & ~(B) & C & CI))
         (D => S) = 0;
      if ((A & ~(B) & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & B & C & CI))
         (D => S) = 0;
      if ((~(A) & B & ~(C) & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & C & ~(CI)))
         (D => S) = 0;
      if ((~(A) & ~(B) & ~(C) & CI))
         (D => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF42_GY2_8

//%BEGIN SEH_ADDFCIB_1

`celldefine
module SEH_ADDFCIB_1 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, CI);
   and (int_res_1, A, B);
   not (int_res_2, CI);
   and (int_res_3, A, int_res_2);
   not (int_res_4, CI);
   and (int_res_5, B, int_res_4);


   `ifdef VIRL_functiononly
       xor #1 (S, A, B, int_res_0);
       or  #1 (CO, int_res_1, int_res_3, int_res_5);
   `else
       xor (S, A, B, int_res_0);
       or (CO, int_res_1, int_res_3, int_res_5);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & CI))
         (A => CO) = 0;
      if ((~(B) & ~(CI)))
         (A => CO) = 0;
      if ((A & CI))
         (B => CO) = 0;
      if ((~(A) & ~(CI)))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_ADDFCIB_1

//%BEGIN SEH_ADDFCIB_2

`celldefine
module SEH_ADDFCIB_2 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, CI);
   and (int_res_1, A, B);
   not (int_res_2, CI);
   and (int_res_3, A, int_res_2);
   not (int_res_4, CI);
   and (int_res_5, B, int_res_4);


   `ifdef VIRL_functiononly
       xor #1 (S, A, B, int_res_0);
       or  #1 (CO, int_res_1, int_res_3, int_res_5);
   `else
       xor (S, A, B, int_res_0);
       or (CO, int_res_1, int_res_3, int_res_5);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & CI))
         (A => CO) = 0;
      if ((~(B) & ~(CI)))
         (A => CO) = 0;
      if ((A & CI))
         (B => CO) = 0;
      if ((~(A) & ~(CI)))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_ADDFCIB_2

//%BEGIN SEH_ADDFCOB_1

`celldefine
module SEH_ADDFCOB_1 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);

   `ifdef VIRL_functiononly
       xor #1 (S, A, B, CI);
       nor #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
       xor (S, A, B, CI);
       nor (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)) | (~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_ADDFCOB_1

//%BEGIN SEH_ADDFCOB_2

`celldefine
module SEH_ADDFCOB_2 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);

   `ifdef VIRL_functiononly
       xor #1 (S, A, B, CI);
       nor #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
       xor (S, A, B, CI);
       nor (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)) | (~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_ADDFCOB_2

//%BEGIN SEH_ADDFCSCIB_1

`celldefine
module SEH_ADDFCSCIB_1 (S, CO0, CO1, A, B, CI0, CI1, CS);
   output S, CO0, CO1;
   input A, B, CI0, CI1, CS;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7, int_res_8, int_res_9, int_res_10, 
      int_res_11, int_res_12, int_res_13, int_res_14, 
      int_res_15, int_res_16;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, CI0);
   xor (int_res_1, A, B, int_res_0);
   not (int_res_2, CS);
   and (int_res_3, int_res_1, int_res_2);
   not (int_res_4, CI1);
   xor (int_res_5, A, B, int_res_4);
   and (int_res_6, int_res_5, CS);
   and (int_res_7, A, B);
   not (int_res_8, CI0);
   and (int_res_9, A, int_res_8);
   not (int_res_10, CI0);
   and (int_res_11, B, int_res_10);
   and (int_res_12, A, B);
   not (int_res_13, CI1);
   and (int_res_14, A, int_res_13);
   not (int_res_15, CI1);
   and (int_res_16, B, int_res_15);

   `ifdef VIRL_functiononly
       or #1 (S, int_res_3, int_res_6);
       or #1 (CO0, int_res_7, int_res_9, int_res_11);
       or #1 (CO1, int_res_12, int_res_14, int_res_16);
   `else
       or (S, int_res_3, int_res_6);
       or (CO0, int_res_7, int_res_9, int_res_11);
       or (CO1, int_res_12, int_res_14, int_res_16);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & CI0 & CI1))
         (A => CO0) = 0;
      if ((B & CI0 & ~(CI1) & CS))
         (A => CO0) = 0;
      if ((B & CI0 & ~(CI1) & ~(CS)))
         (A => CO0) = 0;
      if ((~(B) & ~(CI0) & CI1 & CS))
         (A => CO0) = 0;
      if ((~(B) & ~(CI0) & CI1 & ~(CS)))
         (A => CO0) = 0;
      if ((~(B) & ~(CI0) & ~(CI1)))
         (A => CO0) = 0;
      if ((A & CI0 & CI1))
         (B => CO0) = 0;
      if ((A & CI0 & ~(CI1) & CS))
         (B => CO0) = 0;
      if ((A & CI0 & ~(CI1) & ~(CS)))
         (B => CO0) = 0;
      if ((~(A) & ~(CI0) & CI1 & CS))
         (B => CO0) = 0;
      if ((~(A) & ~(CI0) & CI1 & ~(CS)))
         (B => CO0) = 0;
      if ((~(A) & ~(CI0) & ~(CI1)))
         (B => CO0) = 0;
      if ((A & ~(B) & CI1 & CS))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & CI1 & ~(CS)))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & ~(CI1) & CS))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & ~(CI1) & ~(CS)))
         (CI0 => CO0) = 0;
      if ((~(A) & B & CI1 & CS))
         (CI0 => CO0) = 0;
      if ((~(A) & B & CI1 & ~(CS)))
         (CI0 => CO0) = 0;
      if ((~(A) & B & ~(CI1) & CS))
         (CI0 => CO0) = 0;
      if ((~(A) & B & ~(CI1) & ~(CS)))
         (CI0 => CO0) = 0;
      if ((B & CI0 & CI1))
         (A => CO1) = 0;
      if ((B & ~(CI0) & CI1 & CS))
         (A => CO1) = 0;
      if ((B & ~(CI0) & CI1 & ~(CS)))
         (A => CO1) = 0;
      if ((~(B) & CI0 & ~(CI1) & CS))
         (A => CO1) = 0;
      if ((~(B) & CI0 & ~(CI1) & ~(CS)))
         (A => CO1) = 0;
      if ((~(B) & ~(CI0) & ~(CI1)))
         (A => CO1) = 0;
      if ((A & CI0 & CI1))
         (B => CO1) = 0;
      if ((A & ~(CI0) & CI1 & CS))
         (B => CO1) = 0;
      if ((A & ~(CI0) & CI1 & ~(CS)))
         (B => CO1) = 0;
      if ((~(A) & CI0 & ~(CI1) & CS))
         (B => CO1) = 0;
      if ((~(A) & CI0 & ~(CI1) & ~(CS)))
         (B => CO1) = 0;
      if ((~(A) & ~(CI0) & ~(CI1)))
         (B => CO1) = 0;
      if ((A & ~(B) & CI0 & CS))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & CI0 & ~(CS)))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & ~(CI0) & CS))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & ~(CI0) & ~(CS)))
         (CI1 => CO1) = 0;
      if ((~(A) & B & CI0 & CS))
         (CI1 => CO1) = 0;
      if ((~(A) & B & CI0 & ~(CS)))
         (CI1 => CO1) = 0;
      if ((~(A) & B & ~(CI0) & CS))
         (CI1 => CO1) = 0;
      if ((~(A) & B & ~(CI0) & ~(CS)))
         (CI1 => CO1) = 0;
      if ((B & CI0 & ~(CI1) & CS))
         (A => S) = 0;
      if ((B & ~(CI0) & CI1 & ~(CS)))
         (A => S) = 0;
      if ((B & ~(CI0) & ~(CI1)))
         (A => S) = 0;
      if ((~(B) & CI0 & CI1))
         (A => S) = 0;
      if ((~(B) & CI0 & ~(CI1) & ~(CS)))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & CI1 & CS))
         (A => S) = 0;
      if ((B & CI0 & CI1))
         (A => S) = 0;
      if ((B & CI0 & ~(CI1) & ~(CS)))
         (A => S) = 0;
      if ((B & ~(CI0) & CI1 & CS))
         (A => S) = 0;
      if ((~(B) & CI0 & ~(CI1) & CS))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & CI1 & ~(CS)))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & ~(CI1)))
         (A => S) = 0;
      if ((A & CI0 & ~(CI1) & CS))
         (B => S) = 0;
      if ((A & ~(CI0) & CI1 & ~(CS)))
         (B => S) = 0;
      if ((A & ~(CI0) & ~(CI1)))
         (B => S) = 0;
      if ((~(A) & CI0 & CI1))
         (B => S) = 0;
      if ((~(A) & CI0 & ~(CI1) & ~(CS)))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & CI1 & CS))
         (B => S) = 0;
      if ((A & CI0 & CI1))
         (B => S) = 0;
      if ((A & CI0 & ~(CI1) & ~(CS)))
         (B => S) = 0;
      if ((A & ~(CI0) & CI1 & CS))
         (B => S) = 0;
      if ((~(A) & CI0 & ~(CI1) & CS))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & CI1 & ~(CS)))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & ~(CI1)))
         (B => S) = 0;
      if ((A & ~(B) & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((A & ~(B) & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & B & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & B & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((A & B & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((A & B & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & ~(B) & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & ~(B) & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((A & ~(B) & CI0 & CS))
         (CI1 => S) = 0;
      if ((A & ~(B) & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((~(A) & B & CI0 & CS))
         (CI1 => S) = 0;
      if ((~(A) & B & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((A & B & CI0 & CS))
         (CI1 => S) = 0;
      if ((A & B & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((~(A) & ~(B) & CI0 & CS))
         (CI1 => S) = 0;
      if ((~(A) & ~(B) & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((A & B & CI0 & ~(CI1)) | (~(A) & ~(B) & CI0 & ~(CI1)))
         (CS => S) = 0;
      if ((A & ~(B) & ~(CI0) & CI1) | (~(A) & B & ~(CI0) & CI1))
         (CS => S) = 0;
      if ((A & B & ~(CI0) & CI1) | (~(A) & ~(B) & ~(CI0) & CI1))
         (CS => S) = 0;
      if ((A & ~(B) & CI0 & ~(CI1)) | (~(A) & B & CI0 & ~(CI1)))
         (CS => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDFCSCIB_1

//%BEGIN SEH_ADDFCSCIB_2

`celldefine
module SEH_ADDFCSCIB_2 (S, CO0, CO1, A, B, CI0, CI1, CS);
   output S, CO0, CO1;
   input A, B, CI0, CI1, CS;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7, int_res_8, int_res_9, int_res_10, 
      int_res_11, int_res_12, int_res_13, int_res_14, 
      int_res_15, int_res_16;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, CI0);
   xor (int_res_1, A, B, int_res_0);
   not (int_res_2, CS);
   and (int_res_3, int_res_1, int_res_2);
   not (int_res_4, CI1);
   xor (int_res_5, A, B, int_res_4);
   and (int_res_6, int_res_5, CS);
   and (int_res_7, A, B);
   not (int_res_8, CI0);
   and (int_res_9, A, int_res_8);
   not (int_res_10, CI0);
   and (int_res_11, B, int_res_10);
   and (int_res_12, A, B);
   not (int_res_13, CI1);
   and (int_res_14, A, int_res_13);
   not (int_res_15, CI1);
   and (int_res_16, B, int_res_15);

   `ifdef VIRL_functiononly
       or #1 (S, int_res_3, int_res_6);
       or #1 (CO0, int_res_7, int_res_9, int_res_11);
       or #1 (CO1, int_res_12, int_res_14, int_res_16);
   `else
       or (S, int_res_3, int_res_6);
       or (CO0, int_res_7, int_res_9, int_res_11);
       or (CO1, int_res_12, int_res_14, int_res_16);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & CI0 & CI1))
         (A => CO0) = 0;
      if ((B & CI0 & ~(CI1) & CS))
         (A => CO0) = 0;
      if ((B & CI0 & ~(CI1) & ~(CS)))
         (A => CO0) = 0;
      if ((~(B) & ~(CI0) & CI1 & CS))
         (A => CO0) = 0;
      if ((~(B) & ~(CI0) & CI1 & ~(CS)))
         (A => CO0) = 0;
      if ((~(B) & ~(CI0) & ~(CI1)))
         (A => CO0) = 0;
      if ((A & CI0 & CI1))
         (B => CO0) = 0;
      if ((A & CI0 & ~(CI1) & CS))
         (B => CO0) = 0;
      if ((A & CI0 & ~(CI1) & ~(CS)))
         (B => CO0) = 0;
      if ((~(A) & ~(CI0) & CI1 & CS))
         (B => CO0) = 0;
      if ((~(A) & ~(CI0) & CI1 & ~(CS)))
         (B => CO0) = 0;
      if ((~(A) & ~(CI0) & ~(CI1)))
         (B => CO0) = 0;
      if ((A & ~(B) & CI1 & CS))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & CI1 & ~(CS)))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & ~(CI1) & CS))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & ~(CI1) & ~(CS)))
         (CI0 => CO0) = 0;
      if ((~(A) & B & CI1 & CS))
         (CI0 => CO0) = 0;
      if ((~(A) & B & CI1 & ~(CS)))
         (CI0 => CO0) = 0;
      if ((~(A) & B & ~(CI1) & CS))
         (CI0 => CO0) = 0;
      if ((~(A) & B & ~(CI1) & ~(CS)))
         (CI0 => CO0) = 0;
      if ((B & CI0 & CI1))
         (A => CO1) = 0;
      if ((B & ~(CI0) & CI1 & CS))
         (A => CO1) = 0;
      if ((B & ~(CI0) & CI1 & ~(CS)))
         (A => CO1) = 0;
      if ((~(B) & CI0 & ~(CI1) & CS))
         (A => CO1) = 0;
      if ((~(B) & CI0 & ~(CI1) & ~(CS)))
         (A => CO1) = 0;
      if ((~(B) & ~(CI0) & ~(CI1)))
         (A => CO1) = 0;
      if ((A & CI0 & CI1))
         (B => CO1) = 0;
      if ((A & ~(CI0) & CI1 & CS))
         (B => CO1) = 0;
      if ((A & ~(CI0) & CI1 & ~(CS)))
         (B => CO1) = 0;
      if ((~(A) & CI0 & ~(CI1) & CS))
         (B => CO1) = 0;
      if ((~(A) & CI0 & ~(CI1) & ~(CS)))
         (B => CO1) = 0;
      if ((~(A) & ~(CI0) & ~(CI1)))
         (B => CO1) = 0;
      if ((A & ~(B) & CI0 & CS))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & CI0 & ~(CS)))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & ~(CI0) & CS))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & ~(CI0) & ~(CS)))
         (CI1 => CO1) = 0;
      if ((~(A) & B & CI0 & CS))
         (CI1 => CO1) = 0;
      if ((~(A) & B & CI0 & ~(CS)))
         (CI1 => CO1) = 0;
      if ((~(A) & B & ~(CI0) & CS))
         (CI1 => CO1) = 0;
      if ((~(A) & B & ~(CI0) & ~(CS)))
         (CI1 => CO1) = 0;
      if ((B & CI0 & ~(CI1) & CS))
         (A => S) = 0;
      if ((B & ~(CI0) & CI1 & ~(CS)))
         (A => S) = 0;
      if ((B & ~(CI0) & ~(CI1)))
         (A => S) = 0;
      if ((~(B) & CI0 & CI1))
         (A => S) = 0;
      if ((~(B) & CI0 & ~(CI1) & ~(CS)))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & CI1 & CS))
         (A => S) = 0;
      if ((B & CI0 & CI1))
         (A => S) = 0;
      if ((B & CI0 & ~(CI1) & ~(CS)))
         (A => S) = 0;
      if ((B & ~(CI0) & CI1 & CS))
         (A => S) = 0;
      if ((~(B) & CI0 & ~(CI1) & CS))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & CI1 & ~(CS)))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & ~(CI1)))
         (A => S) = 0;
      if ((A & CI0 & ~(CI1) & CS))
         (B => S) = 0;
      if ((A & ~(CI0) & CI1 & ~(CS)))
         (B => S) = 0;
      if ((A & ~(CI0) & ~(CI1)))
         (B => S) = 0;
      if ((~(A) & CI0 & CI1))
         (B => S) = 0;
      if ((~(A) & CI0 & ~(CI1) & ~(CS)))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & CI1 & CS))
         (B => S) = 0;
      if ((A & CI0 & CI1))
         (B => S) = 0;
      if ((A & CI0 & ~(CI1) & ~(CS)))
         (B => S) = 0;
      if ((A & ~(CI0) & CI1 & CS))
         (B => S) = 0;
      if ((~(A) & CI0 & ~(CI1) & CS))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & CI1 & ~(CS)))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & ~(CI1)))
         (B => S) = 0;
      if ((A & ~(B) & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((A & ~(B) & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & B & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & B & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((A & B & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((A & B & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & ~(B) & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & ~(B) & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((A & ~(B) & CI0 & CS))
         (CI1 => S) = 0;
      if ((A & ~(B) & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((~(A) & B & CI0 & CS))
         (CI1 => S) = 0;
      if ((~(A) & B & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((A & B & CI0 & CS))
         (CI1 => S) = 0;
      if ((A & B & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((~(A) & ~(B) & CI0 & CS))
         (CI1 => S) = 0;
      if ((~(A) & ~(B) & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((A & B & CI0 & ~(CI1)) | (~(A) & ~(B) & CI0 & ~(CI1)))
         (CS => S) = 0;
      if ((A & ~(B) & ~(CI0) & CI1) | (~(A) & B & ~(CI0) & CI1))
         (CS => S) = 0;
      if ((A & B & ~(CI0) & CI1) | (~(A) & ~(B) & ~(CI0) & CI1))
         (CS => S) = 0;
      if ((A & ~(B) & CI0 & ~(CI1)) | (~(A) & B & CI0 & ~(CI1)))
         (CS => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDFCSCIB_2

//%BEGIN SEH_ADDFCSCOB_1

`celldefine
module SEH_ADDFCSCOB_1 (S, CO0, CO1, A, B, CI0, CI1, CS);
   output S, CO0, CO1;
   input A, B, CI0, CI1, CS;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7, int_res_8, int_res_9, int_res_10;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A, B, CI0);
   not (int_res_1, CS);
   and (int_res_2, int_res_0, int_res_1);
   xor (int_res_3, A, B, CI1);
   and (int_res_4, int_res_3, CS);
   and (int_res_5, A, B);
   and (int_res_6, A, CI0);
   and (int_res_7, B, CI0);
   and (int_res_8, A, B);
   and (int_res_9, A, CI1);
   and (int_res_10, B, CI1);

   `ifdef VIRL_functiononly
       or  #1 (S, int_res_2, int_res_4);
       nor #1 (CO0, int_res_5, int_res_6, int_res_7);
       nor #1 (CO1, int_res_8, int_res_9, int_res_10);
   `else
       or (S, int_res_2, int_res_4);
       nor (CO0, int_res_5, int_res_6, int_res_7);
       nor (CO1, int_res_8, int_res_9, int_res_10);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI0) & CI1 & CS))
         (A => CO0) = 0;
      if ((B & ~(CI0) & CI1 & ~(CS)))
         (A => CO0) = 0;
      if ((B & ~(CI0) & ~(CI1)))
         (A => CO0) = 0;
      if ((~(B) & CI0 & CI1))
         (A => CO0) = 0;
      if ((~(B) & CI0 & ~(CI1) & CS))
         (A => CO0) = 0;
      if ((~(B) & CI0 & ~(CI1) & ~(CS)))
         (A => CO0) = 0;
      if ((A & ~(CI0) & CI1 & CS))
         (B => CO0) = 0;
      if ((A & ~(CI0) & CI1 & ~(CS)))
         (B => CO0) = 0;
      if ((A & ~(CI0) & ~(CI1)))
         (B => CO0) = 0;
      if ((~(A) & CI0 & CI1))
         (B => CO0) = 0;
      if ((~(A) & CI0 & ~(CI1) & CS))
         (B => CO0) = 0;
      if ((~(A) & CI0 & ~(CI1) & ~(CS)))
         (B => CO0) = 0;
      if ((A & ~(B) & CI1 & CS) | (~(A) & B & CI1 & CS))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & CI1 & ~(CS)) | (~(A) & B & CI1 & ~(CS)))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & ~(CI1) & CS) | (~(A) & B & ~(CI1) & CS))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & ~(CI1) & ~(CS)) | (~(A) & B & ~(CI1) & ~(CS)))
         (CI0 => CO0) = 0;
      if ((B & CI0 & ~(CI1) & CS))
         (A => CO1) = 0;
      if ((B & CI0 & ~(CI1) & ~(CS)))
         (A => CO1) = 0;
      if ((B & ~(CI0) & ~(CI1)))
         (A => CO1) = 0;
      if ((~(B) & CI0 & CI1))
         (A => CO1) = 0;
      if ((~(B) & ~(CI0) & CI1 & CS))
         (A => CO1) = 0;
      if ((~(B) & ~(CI0) & CI1 & ~(CS)))
         (A => CO1) = 0;
      if ((A & CI0 & ~(CI1) & CS))
         (B => CO1) = 0;
      if ((A & CI0 & ~(CI1) & ~(CS)))
         (B => CO1) = 0;
      if ((A & ~(CI0) & ~(CI1)))
         (B => CO1) = 0;
      if ((~(A) & CI0 & CI1))
         (B => CO1) = 0;
      if ((~(A) & ~(CI0) & CI1 & CS))
         (B => CO1) = 0;
      if ((~(A) & ~(CI0) & CI1 & ~(CS)))
         (B => CO1) = 0;
      if ((A & ~(B) & CI0 & CS) | (~(A) & B & CI0 & CS))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & CI0 & ~(CS)) | (~(A) & B & CI0 & ~(CS)))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & ~(CI0) & CS) | (~(A) & B & ~(CI0) & CS))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & ~(CI0) & ~(CS)) | (~(A) & B & ~(CI0) & ~(CS)))
         (CI1 => CO1) = 0;
      if ((B & CI0 & CI1))
         (A => S) = 0;
      if ((B & CI0 & ~(CI1) & ~(CS)))
         (A => S) = 0;
      if ((B & ~(CI0) & CI1 & CS))
         (A => S) = 0;
      if ((~(B) & CI0 & ~(CI1) & CS))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & CI1 & ~(CS)))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & ~(CI1)))
         (A => S) = 0;
      if ((B & CI0 & ~(CI1) & CS))
         (A => S) = 0;
      if ((B & ~(CI0) & CI1 & ~(CS)))
         (A => S) = 0;
      if ((B & ~(CI0) & ~(CI1)))
         (A => S) = 0;
      if ((~(B) & CI0 & CI1))
         (A => S) = 0;
      if ((~(B) & CI0 & ~(CI1) & ~(CS)))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & CI1 & CS))
         (A => S) = 0;
      if ((A & CI0 & CI1))
         (B => S) = 0;
      if ((A & CI0 & ~(CI1) & ~(CS)))
         (B => S) = 0;
      if ((A & ~(CI0) & CI1 & CS))
         (B => S) = 0;
      if ((~(A) & CI0 & ~(CI1) & CS))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & CI1 & ~(CS)))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & ~(CI1)))
         (B => S) = 0;
      if ((A & CI0 & ~(CI1) & CS))
         (B => S) = 0;
      if ((A & ~(CI0) & CI1 & ~(CS)))
         (B => S) = 0;
      if ((A & ~(CI0) & ~(CI1)))
         (B => S) = 0;
      if ((~(A) & CI0 & CI1))
         (B => S) = 0;
      if ((~(A) & CI0 & ~(CI1) & ~(CS)))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & CI1 & CS))
         (B => S) = 0;
      if ((A & B & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((A & B & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & ~(B) & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & ~(B) & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((A & ~(B) & CI1 & ~(CS)) | (~(A) & B & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((A & ~(B) & ~(CI1) & ~(CS)) | (~(A) & B & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((A & B & CI0 & CS))
         (CI1 => S) = 0;
      if ((A & B & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((~(A) & ~(B) & CI0 & CS))
         (CI1 => S) = 0;
      if ((~(A) & ~(B) & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((A & ~(B) & CI0 & CS) | (~(A) & B & CI0 & CS))
         (CI1 => S) = 0;
      if ((A & ~(B) & ~(CI0) & CS) | (~(A) & B & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((A & B & ~(CI0) & CI1) | (~(A) & ~(B) & ~(CI0) & CI1))
         (CS => S) = 0;
      if ((A & ~(B) & CI0 & ~(CI1)) | (~(A) & B & CI0 & ~(CI1)))
         (CS => S) = 0;
      if ((A & B & CI0 & ~(CI1)) | (~(A) & ~(B) & CI0 & ~(CI1)))
         (CS => S) = 0;
      if ((A & ~(B) & ~(CI0) & CI1) | (~(A) & B & ~(CI0) & CI1))
         (CS => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDFCSCOB_1

//%BEGIN SEH_ADDFCSCOB_2

`celldefine
module SEH_ADDFCSCOB_2 (S, CO0, CO1, A, B, CI0, CI1, CS);
   output S, CO0, CO1;
   input A, B, CI0, CI1, CS;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4, int_res_5, int_res_6, 
      int_res_7, int_res_8, int_res_9, int_res_10;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A, B, CI0);
   not (int_res_1, CS);
   and (int_res_2, int_res_0, int_res_1);
   xor (int_res_3, A, B, CI1);
   and (int_res_4, int_res_3, CS);
   and (int_res_5, A, B);
   and (int_res_6, A, CI0);
   and (int_res_7, B, CI0);
   and (int_res_8, A, B);
   and (int_res_9, A, CI1);
   and (int_res_10, B, CI1);

   `ifdef VIRL_functiononly
       or  #1 (S, int_res_2, int_res_4);
       nor #1 (CO0, int_res_5, int_res_6, int_res_7);
       nor #1 (CO1, int_res_8, int_res_9, int_res_10);
   `else
       or (S, int_res_2, int_res_4);
       nor (CO0, int_res_5, int_res_6, int_res_7);
       nor (CO1, int_res_8, int_res_9, int_res_10);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI0) & CI1 & CS))
         (A => CO0) = 0;
      if ((B & ~(CI0) & CI1 & ~(CS)))
         (A => CO0) = 0;
      if ((B & ~(CI0) & ~(CI1)))
         (A => CO0) = 0;
      if ((~(B) & CI0 & CI1))
         (A => CO0) = 0;
      if ((~(B) & CI0 & ~(CI1) & CS))
         (A => CO0) = 0;
      if ((~(B) & CI0 & ~(CI1) & ~(CS)))
         (A => CO0) = 0;
      if ((A & ~(CI0) & CI1 & CS))
         (B => CO0) = 0;
      if ((A & ~(CI0) & CI1 & ~(CS)))
         (B => CO0) = 0;
      if ((A & ~(CI0) & ~(CI1)))
         (B => CO0) = 0;
      if ((~(A) & CI0 & CI1))
         (B => CO0) = 0;
      if ((~(A) & CI0 & ~(CI1) & CS))
         (B => CO0) = 0;
      if ((~(A) & CI0 & ~(CI1) & ~(CS)))
         (B => CO0) = 0;
      if ((A & ~(B) & CI1 & CS) | (~(A) & B & CI1 & CS))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & CI1 & ~(CS)) | (~(A) & B & CI1 & ~(CS)))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & ~(CI1) & CS) | (~(A) & B & ~(CI1) & CS))
         (CI0 => CO0) = 0;
      if ((A & ~(B) & ~(CI1) & ~(CS)) | (~(A) & B & ~(CI1) & ~(CS)))
         (CI0 => CO0) = 0;
      if ((B & CI0 & ~(CI1) & CS))
         (A => CO1) = 0;
      if ((B & CI0 & ~(CI1) & ~(CS)))
         (A => CO1) = 0;
      if ((B & ~(CI0) & ~(CI1)))
         (A => CO1) = 0;
      if ((~(B) & CI0 & CI1))
         (A => CO1) = 0;
      if ((~(B) & ~(CI0) & CI1 & CS))
         (A => CO1) = 0;
      if ((~(B) & ~(CI0) & CI1 & ~(CS)))
         (A => CO1) = 0;
      if ((A & CI0 & ~(CI1) & CS))
         (B => CO1) = 0;
      if ((A & CI0 & ~(CI1) & ~(CS)))
         (B => CO1) = 0;
      if ((A & ~(CI0) & ~(CI1)))
         (B => CO1) = 0;
      if ((~(A) & CI0 & CI1))
         (B => CO1) = 0;
      if ((~(A) & ~(CI0) & CI1 & CS))
         (B => CO1) = 0;
      if ((~(A) & ~(CI0) & CI1 & ~(CS)))
         (B => CO1) = 0;
      if ((A & ~(B) & CI0 & CS) | (~(A) & B & CI0 & CS))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & CI0 & ~(CS)) | (~(A) & B & CI0 & ~(CS)))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & ~(CI0) & CS) | (~(A) & B & ~(CI0) & CS))
         (CI1 => CO1) = 0;
      if ((A & ~(B) & ~(CI0) & ~(CS)) | (~(A) & B & ~(CI0) & ~(CS)))
         (CI1 => CO1) = 0;
      if ((B & CI0 & CI1))
         (A => S) = 0;
      if ((B & CI0 & ~(CI1) & ~(CS)))
         (A => S) = 0;
      if ((B & ~(CI0) & CI1 & CS))
         (A => S) = 0;
      if ((~(B) & CI0 & ~(CI1) & CS))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & CI1 & ~(CS)))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & ~(CI1)))
         (A => S) = 0;
      if ((B & CI0 & ~(CI1) & CS))
         (A => S) = 0;
      if ((B & ~(CI0) & CI1 & ~(CS)))
         (A => S) = 0;
      if ((B & ~(CI0) & ~(CI1)))
         (A => S) = 0;
      if ((~(B) & CI0 & CI1))
         (A => S) = 0;
      if ((~(B) & CI0 & ~(CI1) & ~(CS)))
         (A => S) = 0;
      if ((~(B) & ~(CI0) & CI1 & CS))
         (A => S) = 0;
      if ((A & CI0 & CI1))
         (B => S) = 0;
      if ((A & CI0 & ~(CI1) & ~(CS)))
         (B => S) = 0;
      if ((A & ~(CI0) & CI1 & CS))
         (B => S) = 0;
      if ((~(A) & CI0 & ~(CI1) & CS))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & CI1 & ~(CS)))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & ~(CI1)))
         (B => S) = 0;
      if ((A & CI0 & ~(CI1) & CS))
         (B => S) = 0;
      if ((A & ~(CI0) & CI1 & ~(CS)))
         (B => S) = 0;
      if ((A & ~(CI0) & ~(CI1)))
         (B => S) = 0;
      if ((~(A) & CI0 & CI1))
         (B => S) = 0;
      if ((~(A) & CI0 & ~(CI1) & ~(CS)))
         (B => S) = 0;
      if ((~(A) & ~(CI0) & CI1 & CS))
         (B => S) = 0;
      if ((A & B & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((A & B & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & ~(B) & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((~(A) & ~(B) & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((A & ~(B) & CI1 & ~(CS)) | (~(A) & B & CI1 & ~(CS)))
         (CI0 => S) = 0;
      if ((A & ~(B) & ~(CI1) & ~(CS)) | (~(A) & B & ~(CI1) & ~(CS)))
         (CI0 => S) = 0;
      if ((A & B & CI0 & CS))
         (CI1 => S) = 0;
      if ((A & B & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((~(A) & ~(B) & CI0 & CS))
         (CI1 => S) = 0;
      if ((~(A) & ~(B) & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((A & ~(B) & CI0 & CS) | (~(A) & B & CI0 & CS))
         (CI1 => S) = 0;
      if ((A & ~(B) & ~(CI0) & CS) | (~(A) & B & ~(CI0) & CS))
         (CI1 => S) = 0;
      if ((A & B & ~(CI0) & CI1) | (~(A) & ~(B) & ~(CI0) & CI1))
         (CS => S) = 0;
      if ((A & ~(B) & CI0 & ~(CI1)) | (~(A) & B & CI0 & ~(CI1)))
         (CS => S) = 0;
      if ((A & B & CI0 & ~(CI1)) | (~(A) & ~(B) & CI0 & ~(CI1)))
         (CS => S) = 0;
      if ((A & ~(B) & ~(CI0) & CI1) | (~(A) & B & ~(CI0) & CI1))
         (CS => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDFCSCOB_2

//%BEGIN SEH_ADDF_D_1

`celldefine
module SEH_ADDF_D_1 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_D_1

//%BEGIN SEH_ADDF_D_2

`celldefine
module SEH_ADDF_D_2 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_D_2

//%BEGIN SEH_ADDF_D_4

`celldefine
module SEH_ADDF_D_4 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_D_4

//%BEGIN SEH_ADDF_D_6

`celldefine
module SEH_ADDF_D_6 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_D_6

//%BEGIN SEH_ADDF_V1_0P5

`celldefine
module SEH_ADDF_V1_0P5 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_V1_0P5

//%BEGIN SEH_ADDF_V1_1

`celldefine
module SEH_ADDF_V1_1 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_V1_1

//%BEGIN SEH_ADDF_V1_2

`celldefine
module SEH_ADDF_V1_2 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_V1_2

//%BEGIN SEH_ADDF_V1_4

`celldefine
module SEH_ADDF_V1_4 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_V1_4

//%BEGIN SEH_ADDF_V3_1

`celldefine
module SEH_ADDF_V3_1 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_V3_1

//%BEGIN SEH_ADDF_V3_1P5

`celldefine
module SEH_ADDF_V3_1P5 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_V3_1P5

//%BEGIN SEH_ADDF_V3_2

`celldefine
module SEH_ADDF_V3_2 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_V3_2

//%BEGIN SEH_ADDF_V3_3

`celldefine
module SEH_ADDF_V3_3 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_V3_3

//%BEGIN SEH_ADDF_V3_4

`celldefine
module SEH_ADDF_V3_4 (S, CO, A, B, CI);
   output S, CO;
   input A, B, CI;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A, B);
   and (int_res_1, A, CI);
   and (int_res_2, B, CI);
   `ifdef VIRL_functiononly
      xor #1 (S, A, B, CI);
      or #1 (CO, int_res_0, int_res_1, int_res_2);
   `else
      xor (S, A, B, CI);
      or (CO, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & ~(CI)))
         (A => CO) = 0;
      if ((~(B) & CI))
         (A => CO) = 0;
      if ((A & ~(CI)))
         (B => CO) = 0;
      if ((~(A) & CI))
         (B => CO) = 0;
      if ((A & ~(B)))
         (CI => CO) = 0;
      if ((~(A) & B))
         (CI => CO) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDF_V3_4

//%BEGIN SEH_ADDHCOB_1

`celldefine
module SEH_ADDHCOB_1 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       xor #1 (S, A, B);
       nand #1 (CO, A, B);
   `else
       xor (S, A, B);
       nand (CO, A, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (~(B))
         (A => S) = 0;
      if (B)
         (A => S) = 0;
      if (~(A))
         (B => S) = 0;
      if (A)
         (B => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDHCOB_1

//%BEGIN SEH_ADDHCOB_2

`celldefine
module SEH_ADDHCOB_2 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       xor #1 (S, A, B);
       nand #1 (CO, A, B);
   `else
       xor (S, A, B);
       nand (CO, A, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (~(B))
         (A => S) = 0;
      if (B)
         (A => S) = 0;
      if (~(A))
         (B => S) = 0;
      if (A)
         (B => S) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ADDHCOB_2

//%BEGIN SEH_ADDHCSCOB_1

`celldefine
module SEH_ADDHCSCOB_1 (S, CO0, CO1, A, B, CI);
   output S, CO0, CO1;
   input A, B, CI;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////



   `ifdef VIRL_functiononly
       xor #1 (S, A, B, CI);
       nand #1 (CO0, A, B);
       nor #1 (CO1, A, B);
   `else
       xor (S, A, B, CI);
       nand (CO0, A, B);
       nor (CO1, A, B);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & CI))
         (A => CO0) = 0;
      if ((B & ~(CI)))
         (A => CO0) = 0;
      if ((A & CI))
         (B => CO0) = 0;
      if ((A & ~(CI)))
         (B => CO0) = 0;
      if ((~(B) & CI))
         (A => CO1) = 0;
      if ((~(B) & ~(CI)))
         (A => CO1) = 0;
      if ((~(A) & CI))
         (B => CO1) = 0;
      if ((~(A) & ~(CI)))
         (B => CO1) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif 
endmodule
`endcelldefine

//%END SEH_ADDHCSCOB_1

//%BEGIN SEH_ADDHCSCOB_2

`celldefine
module SEH_ADDHCSCOB_2 (S, CO0, CO1, A, B, CI);
   output S, CO0, CO1;
   input A, B, CI;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////



   `ifdef VIRL_functiononly
       xor #1 (S, A, B, CI);
       nand #1 (CO0, A, B);
       nor #1 (CO1, A, B);
   `else
       xor (S, A, B, CI);
       nand (CO0, A, B);
       nor (CO1, A, B);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((B & CI))
         (A => CO0) = 0;
      if ((B & ~(CI)))
         (A => CO0) = 0;
      if ((A & CI))
         (B => CO0) = 0;
      if ((A & ~(CI)))
         (B => CO0) = 0;
      if ((~(B) & CI))
         (A => CO1) = 0;
      if ((~(B) & ~(CI)))
         (A => CO1) = 0;
      if ((~(A) & CI))
         (B => CO1) = 0;
      if ((~(A) & ~(CI)))
         (B => CO1) = 0;
      if ((B & CI))
         (A => S) = 0;
      if ((~(B) & ~(CI)))
         (A => S) = 0;
      if ((B & ~(CI)))
         (A => S) = 0;
      if ((~(B) & CI))
         (A => S) = 0;
      if ((A & CI))
         (B => S) = 0;
      if ((~(A) & ~(CI)))
         (B => S) = 0;
      if ((A & ~(CI)))
         (B => S) = 0;
      if ((~(A) & CI))
         (B => S) = 0;
      if ((A & B))
         (CI => S) = 0;
      if ((~(A) & ~(B)))
         (CI => S) = 0;
      if ((A & ~(B)))
         (CI => S) = 0;
      if ((~(A) & B))
         (CI => S) = 0;
   endspecify

   `endif 
endmodule
`endcelldefine

//%END SEH_ADDHCSCOB_2

//%BEGIN SEH_ADDH_0P5

`celldefine
module SEH_ADDH_0P5 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     xor #1 (S, A, B);
     and #1 (CO, A, B);

   `else
     xor (S, A, B);
     and (CO, A, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (~(B))
         (A => S) = 0;
      if (B)
         (A => S) = 0;
      if (~(A))
         (B => S) = 0;
      if (A)
         (B => S) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ADDH_0P5

//%BEGIN SEH_ADDH_1

`celldefine
module SEH_ADDH_1 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     xor #1 (S, A, B);
     and #1 (CO, A, B);

   `else
     xor (S, A, B);
     and (CO, A, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (~(B))
         (A => S) = 0;
      if (B)
         (A => S) = 0;
      if (~(A))
         (B => S) = 0;
      if (A)
         (B => S) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ADDH_1

//%BEGIN SEH_ADDH_2

`celldefine
module SEH_ADDH_2 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     xor #1 (S, A, B);
     and #1 (CO, A, B);

   `else
     xor (S, A, B);
     and (CO, A, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (~(B))
         (A => S) = 0;
      if (B)
         (A => S) = 0;
      if (~(A))
         (B => S) = 0;
      if (A)
         (B => S) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ADDH_2

//%BEGIN SEH_ADDH_4

`celldefine
module SEH_ADDH_4 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     xor #1 (S, A, B);
     and #1 (CO, A, B);

   `else
     xor (S, A, B);
     and (CO, A, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (~(B))
         (A => S) = 0;
      if (B)
         (A => S) = 0;
      if (~(A))
         (B => S) = 0;
      if (A)
         (B => S) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ADDH_4

//%BEGIN SEH_ADDH_D_1

`celldefine
module SEH_ADDH_D_1 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     xor #1 (S, A, B);
     and #1 (CO, A, B);

   `else
     xor (S, A, B);
     and (CO, A, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (~(B))
         (A => S) = 0;
      if (B)
         (A => S) = 0;
      if (~(A))
         (B => S) = 0;
      if (A)
         (B => S) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ADDH_D_1

//%BEGIN SEH_ADDH_D_2

`celldefine
module SEH_ADDH_D_2 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     xor #1 (S, A, B);
     and #1 (CO, A, B);

   `else
     xor (S, A, B);
     and (CO, A, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (~(B))
         (A => S) = 0;
      if (B)
         (A => S) = 0;
      if (~(A))
         (B => S) = 0;
      if (A)
         (B => S) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ADDH_D_2

//%BEGIN SEH_ADDH_D_3

`celldefine
module SEH_ADDH_D_3 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     xor #1 (S, A, B);
     and #1 (CO, A, B);

   `else
     xor (S, A, B);
     and (CO, A, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (~(B))
         (A => S) = 0;
      if (B)
         (A => S) = 0;
      if (~(A))
         (B => S) = 0;
      if (A)
         (B => S) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ADDH_D_3

//%BEGIN SEH_ADDH_D_4

`celldefine
module SEH_ADDH_D_4 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     xor #1 (S, A, B);
     and #1 (CO, A, B);

   `else
     xor (S, A, B);
     and (CO, A, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (~(B))
         (A => S) = 0;
      if (B)
         (A => S) = 0;
      if (~(A))
         (B => S) = 0;
      if (A)
         (B => S) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ADDH_D_4

//%BEGIN SEH_ADDH_D_6

`celldefine
module SEH_ADDH_D_6 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     xor #1 (S, A, B);
     and #1 (CO, A, B);

   `else
     xor (S, A, B);
     and (CO, A, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (~(B))
         (A => S) = 0;
      if (B)
         (A => S) = 0;
      if (~(A))
         (B => S) = 0;
      if (A)
         (B => S) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ADDH_D_6

//%BEGIN SEH_AN2_0P65

`celldefine
module SEH_AN2_0P65 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_0P65

//%BEGIN SEH_AN2_1

`celldefine
module SEH_AN2_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_1

//%BEGIN SEH_AN2_12

`celldefine
module SEH_AN2_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_12

//%BEGIN SEH_AN2_16

`celldefine
module SEH_AN2_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_16

//%BEGIN SEH_AN2_1P5

`celldefine
module SEH_AN2_1P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_1P5

//%BEGIN SEH_AN2_2

`celldefine
module SEH_AN2_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_2

//%BEGIN SEH_AN2_24

`celldefine
module SEH_AN2_24 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_24

//%BEGIN SEH_AN2_3

`celldefine
module SEH_AN2_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_3

//%BEGIN SEH_AN2_4

`celldefine
module SEH_AN2_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_4

//%BEGIN SEH_AN2_6

`celldefine
module SEH_AN2_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_6

//%BEGIN SEH_AN2_8

`celldefine
module SEH_AN2_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_8

//%BEGIN SEH_AN2_DG_1

`celldefine
module SEH_AN2_DG_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_DG_1

//%BEGIN SEH_AN2_DG_12

`celldefine
module SEH_AN2_DG_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_DG_12

//%BEGIN SEH_AN2_DG_16

`celldefine
module SEH_AN2_DG_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_DG_16

//%BEGIN SEH_AN2_DG_2

`celldefine
module SEH_AN2_DG_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_DG_2

//%BEGIN SEH_AN2_DG_24

`celldefine
module SEH_AN2_DG_24 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_DG_24

//%BEGIN SEH_AN2_DG_3

`celldefine
module SEH_AN2_DG_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_DG_3

//%BEGIN SEH_AN2_DG_4

`celldefine
module SEH_AN2_DG_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_DG_4

//%BEGIN SEH_AN2_DG_5

`celldefine
module SEH_AN2_DG_5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_DG_5

//%BEGIN SEH_AN2_DG_6

`celldefine
module SEH_AN2_DG_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_DG_6

//%BEGIN SEH_AN2_DG_8

`celldefine
module SEH_AN2_DG_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_DG_8

//%BEGIN SEH_AN2_S_0P5

`celldefine
module SEH_AN2_S_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_S_0P5

//%BEGIN SEH_AN2_S_1

`celldefine
module SEH_AN2_S_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_S_1

//%BEGIN SEH_AN2_S_1P5

`celldefine
module SEH_AN2_S_1P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_S_1P5

//%BEGIN SEH_AN2_S_2

`celldefine
module SEH_AN2_S_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_S_2

//%BEGIN SEH_AN2_S_3

`celldefine
module SEH_AN2_S_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_S_3

//%BEGIN SEH_AN2_S_4

`celldefine
module SEH_AN2_S_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_S_4

//%BEGIN SEH_AN2_S_8

`celldefine
module SEH_AN2_S_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     and #1 (X, A1, A2);
   `else
     and  (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN2_S_8

//%BEGIN SEH_AN3B_0P5

`celldefine
module SEH_AN3B_0P5 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, int_res_0, B1, B2);
   `else
      and (X, int_res_0, B1, B2);
   `endif

  `ifdef VIRL_functiononly

  `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AN3B_0P5

//%BEGIN SEH_AN3B_1

`celldefine
module SEH_AN3B_1 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, int_res_0, B1, B2);
   `else
      and (X, int_res_0, B1, B2);
   `endif

  `ifdef VIRL_functiononly

  `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AN3B_1

//%BEGIN SEH_AN3B_2

`celldefine
module SEH_AN3B_2 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, int_res_0, B1, B2);
   `else
      and (X, int_res_0, B1, B2);
   `endif

  `ifdef VIRL_functiononly

  `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AN3B_2

//%BEGIN SEH_AN3B_3

`celldefine
module SEH_AN3B_3 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, int_res_0, B1, B2);
   `else
      and (X, int_res_0, B1, B2);
   `endif

  `ifdef VIRL_functiononly

  `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AN3B_3

//%BEGIN SEH_AN3B_4

`celldefine
module SEH_AN3B_4 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, int_res_0, B1, B2);
   `else
      and (X, int_res_0, B1, B2);
   `endif

  `ifdef VIRL_functiononly

  `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AN3B_4

//%BEGIN SEH_AN3B_8

`celldefine
module SEH_AN3B_8 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, int_res_0, B1, B2);
   `else
      and (X, int_res_0, B1, B2);
   `endif

  `ifdef VIRL_functiononly

  `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AN3B_8

//%BEGIN SEH_AN3_0P5

`celldefine
module SEH_AN3_0P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_0P5

//%BEGIN SEH_AN3_1

`celldefine
module SEH_AN3_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_1

//%BEGIN SEH_AN3_16

`celldefine
module SEH_AN3_16 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_16

//%BEGIN SEH_AN3_2

`celldefine
module SEH_AN3_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_2

//%BEGIN SEH_AN3_3

`celldefine
module SEH_AN3_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_3

//%BEGIN SEH_AN3_4

`celldefine
module SEH_AN3_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_4

//%BEGIN SEH_AN3_6

`celldefine
module SEH_AN3_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_6

//%BEGIN SEH_AN3_8

`celldefine
module SEH_AN3_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_8

//%BEGIN SEH_AN3_S_1

`celldefine
module SEH_AN3_S_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_S_1

//%BEGIN SEH_AN3_S_2

`celldefine
module SEH_AN3_S_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_S_2

//%BEGIN SEH_AN3_S_4

`celldefine
module SEH_AN3_S_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_S_4

//%BEGIN SEH_AN3_S_8

`celldefine
module SEH_AN3_S_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3);
   `else
      and (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN3_S_8

//%BEGIN SEH_AN4B_0P5

`celldefine
module SEH_AN4B_0P5 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, int_res_0, B1, B2, B3);
   `else
      and (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4B_0P5

//%BEGIN SEH_AN4B_1

`celldefine
module SEH_AN4B_1 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, int_res_0, B1, B2, B3);
   `else
      and (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4B_1

//%BEGIN SEH_AN4B_2

`celldefine
module SEH_AN4B_2 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, int_res_0, B1, B2, B3);
   `else
      and (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4B_2

//%BEGIN SEH_AN4B_4

`celldefine
module SEH_AN4B_4 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, int_res_0, B1, B2, B3);
   `else
      and (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4B_4

//%BEGIN SEH_AN4B_8

`celldefine
module SEH_AN4B_8 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, int_res_0, B1, B2, B3);
   `else
      and (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4B_8

//%BEGIN SEH_AN4_0P5

`celldefine
module SEH_AN4_0P5 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4);
   `else
      and (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4_0P5

//%BEGIN SEH_AN4_1

`celldefine
module SEH_AN4_1 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4);
   `else
      and (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4_1

//%BEGIN SEH_AN4_2

`celldefine
module SEH_AN4_2 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4);
   `else
      and (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4_2

//%BEGIN SEH_AN4_4

`celldefine
module SEH_AN4_4 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4);
   `else
      and (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4_4

//%BEGIN SEH_AN4_6

`celldefine
module SEH_AN4_6 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4);
   `else
      and (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4_6

//%BEGIN SEH_AN4_8

`celldefine
module SEH_AN4_8 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4);
   `else
      and (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4_8

//%BEGIN SEH_AN4_S_1

`celldefine
module SEH_AN4_S_1 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4);
   `else
      and (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4_S_1

//%BEGIN SEH_AN4_S_1P5

`celldefine
module SEH_AN4_S_1P5 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4);
   `else
      and (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4_S_1P5

//%BEGIN SEH_AN4_S_2

`celldefine
module SEH_AN4_S_2 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4);
   `else
      and (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4_S_2

//%BEGIN SEH_AN4_S_3

`celldefine
module SEH_AN4_S_3 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4);
   `else
      and (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4_S_3

//%BEGIN SEH_AN4_S_4

`celldefine
module SEH_AN4_S_4 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4);
   `else
      and (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN4_S_4

//%BEGIN SEH_AN5_1

`celldefine
module SEH_AN5_1 (X, A1, A2, A3, A4, A5);
   output X;
   input A1, A2, A3, A4, A5;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4, A5);
   `else
      and (X, A1, A2, A3, A4, A5);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN5_1

//%BEGIN SEH_AN5_2

`celldefine
module SEH_AN5_2 (X, A1, A2, A3, A4, A5);
   output X;
   input A1, A2, A3, A4, A5;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4, A5);
   `else
      and (X, A1, A2, A3, A4, A5);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN5_2

//%BEGIN SEH_AN5_4

`celldefine
module SEH_AN5_4 (X, A1, A2, A3, A4, A5);
   output X;
   input A1, A2, A3, A4, A5;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4, A5);
   `else
      and (X, A1, A2, A3, A4, A5);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN5_4

//%BEGIN SEH_AN5_6

`celldefine
module SEH_AN5_6 (X, A1, A2, A3, A4, A5);
   output X;
   input A1, A2, A3, A4, A5;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4, A5);
   `else
      and (X, A1, A2, A3, A4, A5);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN5_6

//%BEGIN SEH_AN5_Y2_8

`celldefine
module SEH_AN5_Y2_8 (X, A1, A2, A3, A4, A5);
   output X;
   input A1, A2, A3, A4, A5;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4, A5);
   `else
      and (X, A1, A2, A3, A4, A5);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN5_Y2_8

//%BEGIN SEH_AN6_1

`celldefine
module SEH_AN6_1 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4, A5, A6);
   `else
      and (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN6_1

//%BEGIN SEH_AN6_2

`celldefine
module SEH_AN6_2 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4, A5, A6);
   `else
      and (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN6_2

//%BEGIN SEH_AN6_4

`celldefine
module SEH_AN6_4 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4, A5, A6);
   `else
      and (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN6_4

//%BEGIN SEH_AN6_8

`celldefine
module SEH_AN6_8 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      and #1 (X, A1, A2, A3, A4, A5, A6);
   `else
      and (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AN6_8

//%BEGIN SEH_AO211_1

`celldefine
module SEH_AO211_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B1, B2);
   `else
      or (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO211_1

//%BEGIN SEH_AO211_2

`celldefine
module SEH_AO211_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B1, B2);
   `else
      or (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO211_2

//%BEGIN SEH_AO211_4

`celldefine
module SEH_AO211_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B1, B2);
   `else
      or (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO211_4

//%BEGIN SEH_AO21B_1

`celldefine
module SEH_AO21B_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     or #1 (X, int_res_0, int_res_1);
   `else
     or (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21B_1

//%BEGIN SEH_AO21B_12

`celldefine
module SEH_AO21B_12 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     or #1 (X, int_res_0, int_res_1);
   `else
     or (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21B_12

//%BEGIN SEH_AO21B_16

`celldefine
module SEH_AO21B_16 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     or #1 (X, int_res_0, int_res_1);
   `else
     or (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21B_16

//%BEGIN SEH_AO21B_2

`celldefine
module SEH_AO21B_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     or #1 (X, int_res_0, int_res_1);
   `else
     or (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21B_2

//%BEGIN SEH_AO21B_4

`celldefine
module SEH_AO21B_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     or #1 (X, int_res_0, int_res_1);
   `else
     or (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21B_4

//%BEGIN SEH_AO21B_6

`celldefine
module SEH_AO21B_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     or #1 (X, int_res_0, int_res_1);
   `else
     or (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21B_6

//%BEGIN SEH_AO21B_8

`celldefine
module SEH_AO21B_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     or #1 (X, int_res_0, int_res_1);
   `else
     or (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21B_8

//%BEGIN SEH_AO21_0P65

`celldefine
module SEH_AO21_0P65 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_0P65

//%BEGIN SEH_AO21_1

`celldefine
module SEH_AO21_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_1

//%BEGIN SEH_AO21_2

`celldefine
module SEH_AO21_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_2

//%BEGIN SEH_AO21_4

`celldefine
module SEH_AO21_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_4

//%BEGIN SEH_AO21_8

`celldefine
module SEH_AO21_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_8

//%BEGIN SEH_AO21_DG_1

`celldefine
module SEH_AO21_DG_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_DG_1

//%BEGIN SEH_AO21_DG_10

`celldefine
module SEH_AO21_DG_10 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_DG_10

//%BEGIN SEH_AO21_DG_2

`celldefine
module SEH_AO21_DG_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_DG_2

//%BEGIN SEH_AO21_DG_3

`celldefine
module SEH_AO21_DG_3 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_DG_3

//%BEGIN SEH_AO21_DG_4

`celldefine
module SEH_AO21_DG_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_DG_4

//%BEGIN SEH_AO21_DG_6

`celldefine
module SEH_AO21_DG_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_DG_6

//%BEGIN SEH_AO21_DG_8

`celldefine
module SEH_AO21_DG_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO21_DG_8

//%BEGIN SEH_AO221_0P5

`celldefine
module SEH_AO221_0P5 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, C);
   `else
      or (X, int_res_0, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2)) | (~(A1) & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO221_0P5

//%BEGIN SEH_AO221_1

`celldefine
module SEH_AO221_1 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, C);
   `else
      or (X, int_res_0, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2)) | (~(A1) & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO221_1

//%BEGIN SEH_AO221_2

`celldefine
module SEH_AO221_2 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, C);
   `else
      or (X, int_res_0, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2)) | (~(A1) & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO221_2

//%BEGIN SEH_AO221_4

`celldefine
module SEH_AO221_4 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, C);
   `else
      or (X, int_res_0, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2)) | (~(A1) & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO221_4

//%BEGIN SEH_AO2222_0P65

`celldefine
module SEH_AO2222_0P65 (X, A1, A2, B1, B2, C1, C2, D1, D2);
   output X;
   input A1, A2, B1, B2, C1, C2, D1, D2;
   wire int_res_0, int_res_1, int_res_2, int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);
   and (int_res_3, D1, D2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, int_res_2, int_res_3);

   `else
      or  (X, int_res_0, int_res_1, int_res_2, int_res_3);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (C1 => X) = 0;
      (C2 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO2222_0P65

//%BEGIN SEH_AO2222_1

`celldefine
module SEH_AO2222_1 (X, A1, A2, B1, B2, C1, C2, D1, D2);
   output X;
   input A1, A2, B1, B2, C1, C2, D1, D2;
   wire int_res_0, int_res_1, int_res_2, int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);
   and (int_res_3, D1, D2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, int_res_2, int_res_3);

   `else
      or  (X, int_res_0, int_res_1, int_res_2, int_res_3);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (C1 => X) = 0;
      (C2 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO2222_1

//%BEGIN SEH_AO2222_2

`celldefine
module SEH_AO2222_2 (X, A1, A2, B1, B2, C1, C2, D1, D2);
   output X;
   input A1, A2, B1, B2, C1, C2, D1, D2;
   wire int_res_0, int_res_1, int_res_2, int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);
   and (int_res_3, D1, D2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, int_res_2, int_res_3);

   `else
      or  (X, int_res_0, int_res_1, int_res_2, int_res_3);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (C1 => X) = 0;
      (C2 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO2222_2

//%BEGIN SEH_AO2222_4

`celldefine
module SEH_AO2222_4 (X, A1, A2, B1, B2, C1, C2, D1, D2);
   output X;
   input A1, A2, B1, B2, C1, C2, D1, D2;
   wire int_res_0, int_res_1, int_res_2, int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);
   and (int_res_3, D1, D2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, int_res_2, int_res_3);

   `else
      or  (X, int_res_0, int_res_1, int_res_2, int_res_3);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (C1 => X) = 0;
      (C2 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO2222_4

//%BEGIN SEH_AO2222_Y2_8

`celldefine
module SEH_AO2222_Y2_8 (X, A1, A2, B1, B2, C1, C2, D1, D2);
   output X;
   input A1, A2, B1, B2, C1, C2, D1, D2;
   wire int_res_0, int_res_1, int_res_2, int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);
   and (int_res_3, D1, D2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, int_res_2, int_res_3);

   `else
      or  (X, int_res_0, int_res_1, int_res_2, int_res_3);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (C1 => X) = 0;
      (C2 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO2222_Y2_8

//%BEGIN SEH_AO222_0P65

`celldefine
module SEH_AO222_0P65 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      or  (X, int_res_0, int_res_1, int_res_2);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (C1 => X) = 0;
      (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO222_0P65

//%BEGIN SEH_AO222_1

`celldefine
module SEH_AO222_1 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      or  (X, int_res_0, int_res_1, int_res_2);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (C1 => X) = 0;
      (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO222_1

//%BEGIN SEH_AO222_2

`celldefine
module SEH_AO222_2 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      or  (X, int_res_0, int_res_1, int_res_2);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (C1 => X) = 0;
      (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO222_2

//%BEGIN SEH_AO222_4

`celldefine
module SEH_AO222_4 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      or  (X, int_res_0, int_res_1, int_res_2);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (C1 => X) = 0;
      (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO222_4

//%BEGIN SEH_AO222_6

`celldefine
module SEH_AO222_6 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      or  (X, int_res_0, int_res_1, int_res_2);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (C1 => X) = 0;
      (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO222_6

//%BEGIN SEH_AO222_Y2_8

`celldefine
module SEH_AO222_Y2_8 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      or  (X, int_res_0, int_res_1, int_res_2);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (C1 => X) = 0;
      (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO222_Y2_8

//%BEGIN SEH_AO22_0P65

`celldefine
module SEH_AO22_0P65 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_0P65

//%BEGIN SEH_AO22_1

`celldefine
module SEH_AO22_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_1

//%BEGIN SEH_AO22_2

`celldefine
module SEH_AO22_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_2

//%BEGIN SEH_AO22_4

`celldefine
module SEH_AO22_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_4

//%BEGIN SEH_AO22_6

`celldefine
module SEH_AO22_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_6

//%BEGIN SEH_AO22_8

`celldefine
module SEH_AO22_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_8

//%BEGIN SEH_AO22_DG_1

`celldefine
module SEH_AO22_DG_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_DG_1

//%BEGIN SEH_AO22_DG_10

`celldefine
module SEH_AO22_DG_10 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_DG_10

//%BEGIN SEH_AO22_DG_2

`celldefine
module SEH_AO22_DG_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_DG_2

//%BEGIN SEH_AO22_DG_3

`celldefine
module SEH_AO22_DG_3 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_DG_3

//%BEGIN SEH_AO22_DG_4

`celldefine
module SEH_AO22_DG_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_DG_4

//%BEGIN SEH_AO22_DG_6

`celldefine
module SEH_AO22_DG_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_DG_6

//%BEGIN SEH_AO22_DG_8

`celldefine
module SEH_AO22_DG_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);
   `else
      or  (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AO22_DG_8

//%BEGIN SEH_AO2BB2_0P5

`celldefine
module SEH_AO2BB2_0P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_0P5

//%BEGIN SEH_AO2BB2_1

`celldefine
module SEH_AO2BB2_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_1

//%BEGIN SEH_AO2BB2_2

`celldefine
module SEH_AO2BB2_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_2

//%BEGIN SEH_AO2BB2_4

`celldefine
module SEH_AO2BB2_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_4

//%BEGIN SEH_AO2BB2_8

`celldefine
module SEH_AO2BB2_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_8

//%BEGIN SEH_AO2BB2_DG_1

`celldefine
module SEH_AO2BB2_DG_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_DG_1

//%BEGIN SEH_AO2BB2_DG_10

`celldefine
module SEH_AO2BB2_DG_10 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_DG_10

//%BEGIN SEH_AO2BB2_DG_2

`celldefine
module SEH_AO2BB2_DG_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_DG_2

//%BEGIN SEH_AO2BB2_DG_3

`celldefine
module SEH_AO2BB2_DG_3 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_DG_3

//%BEGIN SEH_AO2BB2_DG_4

`celldefine
module SEH_AO2BB2_DG_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_DG_4

//%BEGIN SEH_AO2BB2_DG_6

`celldefine
module SEH_AO2BB2_DG_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_DG_6

//%BEGIN SEH_AO2BB2_DG_8

`celldefine
module SEH_AO2BB2_DG_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   and (int_res_2, int_res_0, int_res_1);
   and (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_2, int_res_3);
   `else
      or (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO2BB2_DG_8

//%BEGIN SEH_AO31_0P5

`celldefine
module SEH_AO31_0P5 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO31_0P5

//%BEGIN SEH_AO31_1

`celldefine
module SEH_AO31_1 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO31_1

//%BEGIN SEH_AO31_2

`celldefine
module SEH_AO31_2 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO31_2

//%BEGIN SEH_AO31_4

`celldefine
module SEH_AO31_4 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO31_4

//%BEGIN SEH_AO31_8

`celldefine
module SEH_AO31_8 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B);
   `else
      or (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AO31_8

//%BEGIN SEH_AO32_0P5

`celldefine
module SEH_AO32_0P5 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2);
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);     
   `else
      or (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((A2 & A3 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2) | (~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1) | (~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
   endspecify

   `endif 
endmodule
`endcelldefine

//%END SEH_AO32_0P5

//%BEGIN SEH_AO32_1

`celldefine
module SEH_AO32_1 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2);
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);     
   `else
      or (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((A2 & A3 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2) | (~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1) | (~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
   endspecify

   `endif 
endmodule
`endcelldefine

//%END SEH_AO32_1

//%BEGIN SEH_AO32_2

`celldefine
module SEH_AO32_2 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2);
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);     
   `else
      or (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((A2 & A3 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2) | (~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1) | (~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
   endspecify

   `endif 
endmodule
`endcelldefine

//%END SEH_AO32_2

//%BEGIN SEH_AO32_4

`celldefine
module SEH_AO32_4 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2);
   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, int_res_1);     
   `else
      or (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((A2 & A3 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2) | (~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1) | (~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
   endspecify

   `endif 
endmodule
`endcelldefine

//%END SEH_AO32_4

//%BEGIN SEH_AOA211_DG_1

`celldefine
module SEH_AOA211_DG_1 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_1, C);
   `else
       and (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOA211_DG_1

//%BEGIN SEH_AOA211_DG_10

`celldefine
module SEH_AOA211_DG_10 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_1, C);
   `else
       and (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOA211_DG_10

//%BEGIN SEH_AOA211_DG_2

`celldefine
module SEH_AOA211_DG_2 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_1, C);
   `else
       and (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOA211_DG_2

//%BEGIN SEH_AOA211_DG_4

`celldefine
module SEH_AOA211_DG_4 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_1, C);
   `else
       and (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOA211_DG_4

//%BEGIN SEH_AOA211_DG_8

`celldefine
module SEH_AOA211_DG_8 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_1, C);
   `else
       and (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOA211_DG_8

//%BEGIN SEH_AOAI211_0P5

`celldefine
module SEH_AOAI211_0P5 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_0P5

//%BEGIN SEH_AOAI211_0P75

`celldefine
module SEH_AOAI211_0P75 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_0P75

//%BEGIN SEH_AOAI211_1

`celldefine
module SEH_AOAI211_1 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_1

//%BEGIN SEH_AOAI211_10

`celldefine
module SEH_AOAI211_10 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_10

//%BEGIN SEH_AOAI211_12

`celldefine
module SEH_AOAI211_12 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_12

//%BEGIN SEH_AOAI211_2

`celldefine
module SEH_AOAI211_2 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_2

//%BEGIN SEH_AOAI211_3

`celldefine
module SEH_AOAI211_3 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_3

//%BEGIN SEH_AOAI211_4

`celldefine
module SEH_AOAI211_4 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_4

//%BEGIN SEH_AOAI211_6

`celldefine
module SEH_AOAI211_6 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_6

//%BEGIN SEH_AOAI211_8

`celldefine
module SEH_AOAI211_8 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_8

//%BEGIN SEH_AOAI211_G_0P5

`celldefine
module SEH_AOAI211_G_0P5 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_G_0P5

//%BEGIN SEH_AOAI211_G_0P75

`celldefine
module SEH_AOAI211_G_0P75 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_G_0P75

//%BEGIN SEH_AOAI211_G_1

`celldefine
module SEH_AOAI211_G_1 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_G_1

//%BEGIN SEH_AOAI211_G_12

`celldefine
module SEH_AOAI211_G_12 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_G_12

//%BEGIN SEH_AOAI211_G_2

`celldefine
module SEH_AOAI211_G_2 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_G_2

//%BEGIN SEH_AOAI211_G_3

`celldefine
module SEH_AOAI211_G_3 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_G_3

//%BEGIN SEH_AOAI211_G_4

`celldefine
module SEH_AOAI211_G_4 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_G_4

//%BEGIN SEH_AOAI211_G_6

`celldefine
module SEH_AOAI211_G_6 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_G_6

//%BEGIN SEH_AOAI211_G_8

`celldefine
module SEH_AOAI211_G_8 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   or (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nand #1 (X, int_res_1, C);
   `else
      nand (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & C))
         (B => X) = 0;
      if ((~(A1) & A2 & C))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & C))
         (B => X) = 0;
      if ((A1 & A2 & B))
         (C => X) = 0;
      if ((A1 & A2 & ~(B)))
         (C => X) = 0;
      if ((A1 & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & B))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOAI211_G_8

//%BEGIN SEH_AOI211_0P5

`celldefine
module SEH_AOI211_0P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_0P5

//%BEGIN SEH_AOI211_0P75

`celldefine
module SEH_AOI211_0P75 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_0P75

//%BEGIN SEH_AOI211_1

`celldefine
module SEH_AOI211_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_1

//%BEGIN SEH_AOI211_12

`celldefine
module SEH_AOI211_12 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_12

//%BEGIN SEH_AOI211_1P5

`celldefine
module SEH_AOI211_1P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_1P5

//%BEGIN SEH_AOI211_2

`celldefine
module SEH_AOI211_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_2

//%BEGIN SEH_AOI211_3

`celldefine
module SEH_AOI211_3 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_3

//%BEGIN SEH_AOI211_4

`celldefine
module SEH_AOI211_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_4

//%BEGIN SEH_AOI211_6

`celldefine
module SEH_AOI211_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_6

//%BEGIN SEH_AOI211_8

`celldefine
module SEH_AOI211_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_8

//%BEGIN SEH_AOI211_G_0P5

`celldefine
module SEH_AOI211_G_0P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_G_0P5

//%BEGIN SEH_AOI211_G_0P75

`celldefine
module SEH_AOI211_G_0P75 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_G_0P75

//%BEGIN SEH_AOI211_G_1

`celldefine
module SEH_AOI211_G_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_G_1

//%BEGIN SEH_AOI211_G_2

`celldefine
module SEH_AOI211_G_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_G_2

//%BEGIN SEH_AOI211_G_3

`celldefine
module SEH_AOI211_G_3 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_G_3

//%BEGIN SEH_AOI211_G_4

`celldefine
module SEH_AOI211_G_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_G_4

//%BEGIN SEH_AOI211_G_5

`celldefine
module SEH_AOI211_G_5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_G_5

//%BEGIN SEH_AOI211_G_6

`celldefine
module SEH_AOI211_G_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_G_6

//%BEGIN SEH_AOI211_G_8

`celldefine
module SEH_AOI211_G_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
     nor #1 (X, int_res_0, B1, B2);
  `else
     nor (X, int_res_0, B1, B2);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI211_G_8

//%BEGIN SEH_AOI21B_0P5

`celldefine
module SEH_AOI21B_0P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1);
   `else
       nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AOI21B_0P5

//%BEGIN SEH_AOI21B_1

`celldefine
module SEH_AOI21B_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1);
   `else
       nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AOI21B_1

//%BEGIN SEH_AOI21B_2

`celldefine
module SEH_AOI21B_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1);
   `else
       nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AOI21B_2

//%BEGIN SEH_AOI21B_3

`celldefine
module SEH_AOI21B_3 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1);
   `else
       nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AOI21B_3

//%BEGIN SEH_AOI21B_4

`celldefine
module SEH_AOI21B_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1);
   `else
       nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AOI21B_4

//%BEGIN SEH_AOI21B_6

`celldefine
module SEH_AOI21B_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1);
   `else
       nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AOI21B_6

//%BEGIN SEH_AOI21B_8

`celldefine
module SEH_AOI21B_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1);
   `else
       nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif
 
endmodule
`endcelldefine

//%END SEH_AOI21B_8

//%BEGIN SEH_AOI21_0P5

`celldefine
module SEH_AOI21_0P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_0P5

//%BEGIN SEH_AOI21_0P75

`celldefine
module SEH_AOI21_0P75 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_0P75

//%BEGIN SEH_AOI21_1

`celldefine
module SEH_AOI21_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_1

//%BEGIN SEH_AOI21_2

`celldefine
module SEH_AOI21_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_2

//%BEGIN SEH_AOI21_3

`celldefine
module SEH_AOI21_3 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_3

//%BEGIN SEH_AOI21_4

`celldefine
module SEH_AOI21_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_4

//%BEGIN SEH_AOI21_6

`celldefine
module SEH_AOI21_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_6

//%BEGIN SEH_AOI21_8

`celldefine
module SEH_AOI21_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_8

//%BEGIN SEH_AOI21_G_0P5

`celldefine
module SEH_AOI21_G_0P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_G_0P5

//%BEGIN SEH_AOI21_G_0P75

`celldefine
module SEH_AOI21_G_0P75 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_G_0P75

//%BEGIN SEH_AOI21_G_1

`celldefine
module SEH_AOI21_G_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_G_1

//%BEGIN SEH_AOI21_G_12

`celldefine
module SEH_AOI21_G_12 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_G_12

//%BEGIN SEH_AOI21_G_2

`celldefine
module SEH_AOI21_G_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_G_2

//%BEGIN SEH_AOI21_G_3

`celldefine
module SEH_AOI21_G_3 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_G_3

//%BEGIN SEH_AOI21_G_4

`celldefine
module SEH_AOI21_G_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_G_4

//%BEGIN SEH_AOI21_G_6

`celldefine
module SEH_AOI21_G_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_G_6

//%BEGIN SEH_AOI21_G_8

`celldefine
module SEH_AOI21_G_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_G_8

//%BEGIN SEH_AOI21_S_0P5

`celldefine
module SEH_AOI21_S_0P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_S_0P5

//%BEGIN SEH_AOI21_S_1

`celldefine
module SEH_AOI21_S_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_S_1

//%BEGIN SEH_AOI21_S_2

`celldefine
module SEH_AOI21_S_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_S_2

//%BEGIN SEH_AOI21_S_4

`celldefine
module SEH_AOI21_S_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_S_4

//%BEGIN SEH_AOI21_T_0P5

`celldefine
module SEH_AOI21_T_0P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_T_0P5

//%BEGIN SEH_AOI21_T_1

`celldefine
module SEH_AOI21_T_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_T_1

//%BEGIN SEH_AOI21_T_12

`celldefine
module SEH_AOI21_T_12 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_T_12

//%BEGIN SEH_AOI21_T_1P5

`celldefine
module SEH_AOI21_T_1P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_T_1P5

//%BEGIN SEH_AOI21_T_2

`celldefine
module SEH_AOI21_T_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_T_2

//%BEGIN SEH_AOI21_T_3

`celldefine
module SEH_AOI21_T_3 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_T_3

//%BEGIN SEH_AOI21_T_4

`celldefine
module SEH_AOI21_T_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_T_4

//%BEGIN SEH_AOI21_T_6

`celldefine
module SEH_AOI21_T_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_T_6

//%BEGIN SEH_AOI21_T_8

`celldefine
module SEH_AOI21_T_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     nor #1  (X, int_res_0, B);
   `else
     nor (X, int_res_0, B);

   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
      if ((~(A1) & ~(A2)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI21_T_8

//%BEGIN SEH_AOI221_0P5

`celldefine
module SEH_AOI221_0P5 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1, C);
  `else
      nor (X, int_res_0, int_res_1, C);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      if ((A2 & B1 & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2)) | (~(A1) & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI221_0P5

//%BEGIN SEH_AOI221_1

`celldefine
module SEH_AOI221_1 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1, C);
  `else
      nor (X, int_res_0, int_res_1, C);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      if ((A2 & B1 & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2)) | (~(A1) & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI221_1

//%BEGIN SEH_AOI221_2

`celldefine
module SEH_AOI221_2 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1, C);
  `else
      nor (X, int_res_0, int_res_1, C);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      if ((A2 & B1 & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2)) | (~(A1) & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI221_2

//%BEGIN SEH_AOI221_4

`celldefine
module SEH_AOI221_4 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1, C);
  `else
      nor (X, int_res_0, int_res_1, C);
  `endif

  `ifdef VIRL_functiononly

  `else

   specify
      if ((A2 & B1 & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2)) | (~(A1) & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2)))
         (C => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_AOI221_4

//%BEGIN SEH_AOI222_0P5

`celldefine
module SEH_AOI222_0P5 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
       nor (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A2 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A1 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI222_0P5

//%BEGIN SEH_AOI222_1

`celldefine
module SEH_AOI222_1 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
       nor (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A2 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A1 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI222_1

//%BEGIN SEH_AOI222_2

`celldefine
module SEH_AOI222_2 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
       nor (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A2 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A1 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI222_2

//%BEGIN SEH_AOI222_3

`celldefine
module SEH_AOI222_3 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
       nor (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A2 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A1 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI222_3

//%BEGIN SEH_AOI222_4

`celldefine
module SEH_AOI222_4 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
       nor (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A2 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A1 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI222_4

//%BEGIN SEH_AOI222_8

`celldefine
module SEH_AOI222_8 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);
   and (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
       nor (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A2 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & B1 & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2 & ~(C1) & ~(C2)) | (A1 & ~(B1) & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2) & ~(C1) & ~(C2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2 & ~(C1) & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(C1) & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C2))
         (C1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C2))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & C1))
         (C2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & C1))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI222_8

//%BEGIN SEH_AOI22_0P5

`celldefine
module SEH_AOI22_0P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_0P5

//%BEGIN SEH_AOI22_0P75

`celldefine
module SEH_AOI22_0P75 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_0P75

//%BEGIN SEH_AOI22_1

`celldefine
module SEH_AOI22_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_1

//%BEGIN SEH_AOI22_10

`celldefine
module SEH_AOI22_10 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_10

//%BEGIN SEH_AOI22_12

`celldefine
module SEH_AOI22_12 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_12

//%BEGIN SEH_AOI22_2

`celldefine
module SEH_AOI22_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_2

//%BEGIN SEH_AOI22_3

`celldefine
module SEH_AOI22_3 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_3

//%BEGIN SEH_AOI22_4

`celldefine
module SEH_AOI22_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_4

//%BEGIN SEH_AOI22_5

`celldefine
module SEH_AOI22_5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_5

//%BEGIN SEH_AOI22_6

`celldefine
module SEH_AOI22_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_6

//%BEGIN SEH_AOI22_8

`celldefine
module SEH_AOI22_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_8

//%BEGIN SEH_AOI22_S_0P5

`celldefine
module SEH_AOI22_S_0P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_S_0P5

//%BEGIN SEH_AOI22_S_1

`celldefine
module SEH_AOI22_S_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_S_1

//%BEGIN SEH_AOI22_S_1P5

`celldefine
module SEH_AOI22_S_1P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_S_1P5

//%BEGIN SEH_AOI22_S_2

`celldefine
module SEH_AOI22_S_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_S_2

//%BEGIN SEH_AOI22_S_4

`celldefine
module SEH_AOI22_S_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_S_4

//%BEGIN SEH_AOI22_T_0P5

`celldefine
module SEH_AOI22_T_0P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_T_0P5

//%BEGIN SEH_AOI22_T_0P75

`celldefine
module SEH_AOI22_T_0P75 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_T_0P75

//%BEGIN SEH_AOI22_T_1

`celldefine
module SEH_AOI22_T_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_T_1

//%BEGIN SEH_AOI22_T_1P5

`celldefine
module SEH_AOI22_T_1P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_T_1P5

//%BEGIN SEH_AOI22_T_2

`celldefine
module SEH_AOI22_T_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_T_2

//%BEGIN SEH_AOI22_T_3

`celldefine
module SEH_AOI22_T_3 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_T_3

//%BEGIN SEH_AOI22_T_4

`celldefine
module SEH_AOI22_T_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_T_4

//%BEGIN SEH_AOI22_T_6

`celldefine
module SEH_AOI22_T_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_T_6

//%BEGIN SEH_AOI22_T_8

`celldefine
module SEH_AOI22_T_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI22_T_8

//%BEGIN SEH_AOI31_0P5

`celldefine
module SEH_AOI31_0P5 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_0P5

//%BEGIN SEH_AOI31_0P75

`celldefine
module SEH_AOI31_0P75 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_0P75

//%BEGIN SEH_AOI31_1

`celldefine
module SEH_AOI31_1 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_1

//%BEGIN SEH_AOI31_12

`celldefine
module SEH_AOI31_12 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_12

//%BEGIN SEH_AOI31_2

`celldefine
module SEH_AOI31_2 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_2

//%BEGIN SEH_AOI31_3

`celldefine
module SEH_AOI31_3 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_3

//%BEGIN SEH_AOI31_4

`celldefine
module SEH_AOI31_4 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_4

//%BEGIN SEH_AOI31_6

`celldefine
module SEH_AOI31_6 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_6

//%BEGIN SEH_AOI31_8

`celldefine
module SEH_AOI31_8 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_8

//%BEGIN SEH_AOI31_G_1

`celldefine
module SEH_AOI31_G_1 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_G_1

//%BEGIN SEH_AOI31_G_2

`celldefine
module SEH_AOI31_G_2 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_G_2

//%BEGIN SEH_AOI31_G_3

`celldefine
module SEH_AOI31_G_3 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_G_3

//%BEGIN SEH_AOI31_G_4

`celldefine
module SEH_AOI31_G_4 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_G_4

//%BEGIN SEH_AOI31_G_6

`celldefine
module SEH_AOI31_G_6 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_G_6

//%BEGIN SEH_AOI31_G_8

`celldefine
module SEH_AOI31_G_8 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_G_8

//%BEGIN SEH_AOI31_T_1

`celldefine
module SEH_AOI31_T_1 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_T_1

//%BEGIN SEH_AOI31_T_2

`celldefine
module SEH_AOI31_T_2 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_T_2

//%BEGIN SEH_AOI31_T_3

`celldefine
module SEH_AOI31_T_3 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_T_3

//%BEGIN SEH_AOI31_T_4

`celldefine
module SEH_AOI31_T_4 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_T_4

//%BEGIN SEH_AOI31_T_6

`celldefine
module SEH_AOI31_T_6 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_T_6

//%BEGIN SEH_AOI31_T_8

`celldefine
module SEH_AOI31_T_8 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);
   `else
        nor (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (B => X) = 0;
      if ((A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)) | (~(A1) & ~(A2) & A3))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI31_T_8

//%BEGIN SEH_AOI32_1

`celldefine
module SEH_AOI32_1 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2);
   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);      
   `else
      nor (X, int_res_0, int_res_1);     
   `endif

   `ifdef VIRL_functiononly
   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((A2 & A3 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2) | (~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1) | (~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_AOI32_1

//%BEGIN SEH_AOI32_2

`celldefine
module SEH_AOI32_2 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2);
   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);      
   `else
      nor (X, int_res_0, int_res_1);     
   `endif

   `ifdef VIRL_functiononly
   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((A2 & A3 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2) | (~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1) | (~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_AOI32_2

//%BEGIN SEH_AOI32_4

`celldefine
module SEH_AOI32_4 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2);
   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);      
   `else
      nor (X, int_res_0, int_res_1);     
   `endif

   `ifdef VIRL_functiononly
   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((A2 & A3 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2) | (~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1) | (~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_AOI32_4

//%BEGIN SEH_AOI32_8

`celldefine
module SEH_AOI32_8 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2);
   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);      
   `else
      nor (X, int_res_0, int_res_1);     
   `endif

   `ifdef VIRL_functiononly
   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((A2 & A3 & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2) | (~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1) | (~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_AOI32_8

//%BEGIN SEH_AOI33_1

`celldefine
module SEH_AOI33_1 (X, A1, A2, A3, B1, B2, B3);
   output X;
   input A1, A2, A3, B1, B2, B3;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2, B3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & A3 & B1 & B2 & ~(B3)))
         (A1 => X) = 0;
      if ((A2 & A3 & B1 & ~(B2) & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & B1 & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2 & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2 & ~(B3)) | (A2 & A3 & ~(B1) & ~(B2) & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & B2 & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2) & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2 & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2 & ~(B3)) | (A1 & A3 & ~(B1) & ~(B2) & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(B3)) | (A1 & A2 & ~(B1) & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2 & B3) | (~(A1) & ~(A2) & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1 & B3) | (~(A1) & ~(A2) & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1 & B2) | (~(A1) & ~(A2) & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1 & B2))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI33_1

//%BEGIN SEH_AOI33_2

`celldefine
module SEH_AOI33_2 (X, A1, A2, A3, B1, B2, B3);
   output X;
   input A1, A2, A3, B1, B2, B3;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2, B3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & A3 & B1 & B2 & ~(B3)))
         (A1 => X) = 0;
      if ((A2 & A3 & B1 & ~(B2) & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & B1 & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2 & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2 & ~(B3)) | (A2 & A3 & ~(B1) & ~(B2) & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & B2 & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2) & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2 & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2 & ~(B3)) | (A1 & A3 & ~(B1) & ~(B2) & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(B3)) | (A1 & A2 & ~(B1) & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2 & B3) | (~(A1) & ~(A2) & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1 & B3) | (~(A1) & ~(A2) & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1 & B2) | (~(A1) & ~(A2) & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1 & B2))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI33_2

//%BEGIN SEH_AOI33_4

`celldefine
module SEH_AOI33_4 (X, A1, A2, A3, B1, B2, B3);
   output X;
   input A1, A2, A3, B1, B2, B3;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2, B3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & A3 & B1 & B2 & ~(B3)))
         (A1 => X) = 0;
      if ((A2 & A3 & B1 & ~(B2) & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & B1 & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2 & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2 & ~(B3)) | (A2 & A3 & ~(B1) & ~(B2) & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & B2 & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2) & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2 & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2 & ~(B3)) | (A1 & A3 & ~(B1) & ~(B2) & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(B3)) | (A1 & A2 & ~(B1) & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2 & B3) | (~(A1) & ~(A2) & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1 & B3) | (~(A1) & ~(A2) & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1 & B2) | (~(A1) & ~(A2) & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1 & B2))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI33_4

//%BEGIN SEH_AOI33_6

`celldefine
module SEH_AOI33_6 (X, A1, A2, A3, B1, B2, B3);
   output X;
   input A1, A2, A3, B1, B2, B3;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2, A3);
   and (int_res_1, B1, B2, B3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_0, int_res_1);
   `else
      nor (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      if ((A2 & A3 & B1 & B2 & ~(B3)))
         (A1 => X) = 0;
      if ((A2 & A3 & B1 & ~(B2) & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & B1 & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2 & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & B2 & ~(B3)) | (A2 & A3 & ~(B1) & ~(B2) & B3))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(B1) & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((A1 & A3 & B1 & B2 & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2) & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & B1 & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2 & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & B2 & ~(B3)) | (A1 & A3 & ~(B1) & ~(B2) & B3))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(B1) & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(B3)) | (A1 & A2 & ~(B1) & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2 & B3) | (~(A1) & ~(A2) & A3 & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1 & B3) | (~(A1) & ~(A2) & A3 & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1 & B2) | (~(A1) & ~(A2) & A3 & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & B1 & B2))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_AOI33_6

//%BEGIN SEH_BENC_2

`celldefine
module SEH_BENC_2 (S, A, X, M0, M1, M2);
   output S, A, X;
   input M0, M1, M2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, M2);
   or (int_res_1, M1, M0);
   not (int_res_2, M1);
   not (int_res_3, M0);
   or (int_res_4, int_res_2, int_res_3);

   `ifdef VIRL_functiononly
       and #1 (S, int_res_0, int_res_1);
       and #1 (A, M2, int_res_4);
       xnor #1 (X, M1, M0);        
   `else
       and (S, int_res_0, int_res_1);
       and (A, M2, int_res_4);
       xnor (X, M1, M0);        
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      (M0 => A) = 0;
      (M1 => A) = 0;
      if ((M0 & ~(M1)))
         (M2 => A) = 0;
      if ((~(M0) & M1))
         (M2 => A) = 0;
      if ((~(M0) & ~(M1)))
         (M2 => A) = 0;
      (M0 => S) = 0;
      (M1 => S) = 0;
      if ((M0 & M1))
         (M2 => S) = 0;
      if ((M0 & ~(M1)))
         (M2 => S) = 0;
      if ((~(M0) & M1))
         (M2 => S) = 0;
      if ((M1 & M2))
         (M0 => X) = 0;
      if ((M1 & ~(M2)))
         (M0 => X) = 0;
      if ((~(M1) & M2))
         (M0 => X) = 0;
      if ((~(M1) & ~(M2)))
         (M0 => X) = 0;
      if ((M0 & M2))
         (M1 => X) = 0;
      if ((M0 & ~(M2)))
         (M1 => X) = 0;
      if ((~(M0) & M2))
         (M1 => X) = 0;
      if ((~(M0) & ~(M2)))
         (M1 => X) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_BENC_2

//%BEGIN SEH_BENC_4

`celldefine
module SEH_BENC_4 (S, A, X, M0, M1, M2);
   output S, A, X;
   input M0, M1, M2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, M2);
   or (int_res_1, M1, M0);
   not (int_res_2, M1);
   not (int_res_3, M0);
   or (int_res_4, int_res_2, int_res_3);

   `ifdef VIRL_functiononly
       and #1 (S, int_res_0, int_res_1);
       and #1 (A, M2, int_res_4);
       xnor #1 (X, M1, M0);        
   `else
       and (S, int_res_0, int_res_1);
       and (A, M2, int_res_4);
       xnor (X, M1, M0);        
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      (M0 => A) = 0;
      (M1 => A) = 0;
      if ((M0 & ~(M1)))
         (M2 => A) = 0;
      if ((~(M0) & M1))
         (M2 => A) = 0;
      if ((~(M0) & ~(M1)))
         (M2 => A) = 0;
      (M0 => S) = 0;
      (M1 => S) = 0;
      if ((M0 & M1))
         (M2 => S) = 0;
      if ((M0 & ~(M1)))
         (M2 => S) = 0;
      if ((~(M0) & M1))
         (M2 => S) = 0;
      if ((M1 & M2))
         (M0 => X) = 0;
      if ((M1 & ~(M2)))
         (M0 => X) = 0;
      if ((~(M1) & M2))
         (M0 => X) = 0;
      if ((~(M1) & ~(M2)))
         (M0 => X) = 0;
      if ((M0 & M2))
         (M1 => X) = 0;
      if ((M0 & ~(M2)))
         (M1 => X) = 0;
      if ((~(M0) & M2))
         (M1 => X) = 0;
      if ((~(M0) & ~(M2)))
         (M1 => X) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_BENC_4

//%BEGIN SEH_BENC_8

`celldefine
module SEH_BENC_8 (S, A, X, M0, M1, M2);
   output S, A, X;
   input M0, M1, M2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3, int_res_4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, M2);
   or (int_res_1, M1, M0);
   not (int_res_2, M1);
   not (int_res_3, M0);
   or (int_res_4, int_res_2, int_res_3);

   `ifdef VIRL_functiononly
       and #1 (S, int_res_0, int_res_1);
       and #1 (A, M2, int_res_4);
       xnor #1 (X, M1, M0);        
   `else
       and (S, int_res_0, int_res_1);
       and (A, M2, int_res_4);
       xnor (X, M1, M0);        
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      (M0 => A) = 0;
      (M1 => A) = 0;
      if ((M0 & ~(M1)))
         (M2 => A) = 0;
      if ((~(M0) & M1))
         (M2 => A) = 0;
      if ((~(M0) & ~(M1)))
         (M2 => A) = 0;
      (M0 => S) = 0;
      (M1 => S) = 0;
      if ((M0 & M1))
         (M2 => S) = 0;
      if ((M0 & ~(M1)))
         (M2 => S) = 0;
      if ((~(M0) & M1))
         (M2 => S) = 0;
      if ((M1 & M2))
         (M0 => X) = 0;
      if ((M1 & ~(M2)))
         (M0 => X) = 0;
      if ((~(M1) & M2))
         (M0 => X) = 0;
      if ((~(M1) & ~(M2)))
         (M0 => X) = 0;
      if ((M0 & M2))
         (M1 => X) = 0;
      if ((M0 & ~(M2)))
         (M1 => X) = 0;
      if ((~(M0) & M2))
         (M1 => X) = 0;
      if ((~(M0) & ~(M2)))
         (M1 => X) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_BENC_8

//%BEGIN SEH_BMUXI_1

`celldefine
module SEH_BMUXI_1 (PP, S, A, X, M0, M1);
   output PP;
   input S, A, X, M0, M1;

   wire int_res_0, int_res_1, int_res__M1,
      int_res_2, int_res_3, int_res__M0, int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, S);
   not (int_res_1, A);
   mux2 (int_res__M1, int_res_1, int_res_0, M1);
   not (int_res_2, S);
   not (int_res_3, A);
   mux2 (int_res__M0, int_res_3, int_res_2, M0);
   mux2 (int_res_mux1, int_res__M0, int_res__M1, X);

   `ifdef VIRL_functiononly
       not #1 (PP, int_res_mux1);        
   `else
       not (PP, int_res_mux1);        
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((M0 & M1))
         (A => PP) = 0;
      if ((M0 & ~(M1) & X))
         (A => PP) = 0;
      if ((~(M0) & M1 & ~(X)))
         (A => PP) = 0;
      if ((A & M1 & ~(S) & X))
         (M0 => PP) = 0;
      if ((A & ~(M1) & ~(S) & X))
         (M0 => PP) = 0;
      if ((~(A) & M1 & S & X))
         (M0 => PP) = 0;
      if ((~(A) & ~(M1) & S & X))
         (M0 => PP) = 0;
      if ((A & M0 & ~(S) & ~(X)))
         (M1 => PP) = 0;
      if ((A & ~(M0) & ~(S) & ~(X)))
         (M1 => PP) = 0;
      if ((~(A) & M0 & S & ~(X)))
         (M1 => PP) = 0;
      if ((~(A) & ~(M0) & S & ~(X)))
         (M1 => PP) = 0;
      if ((M0 & ~(M1) & ~(X)))
         (S => PP) = 0;
      if ((~(M0) & M1 & X))
         (S => PP) = 0;
      if ((~(M0) & ~(M1)))
         (S => PP) = 0;
      if ((A & M0 & ~(M1) & ~(S)))
         (X => PP) = 0;
      if ((~(A) & ~(M0) & M1 & S))
         (X => PP) = 0;
      if ((A & ~(M0) & M1 & ~(S)))
         (X => PP) = 0;
      if ((~(A) & M0 & ~(M1) & S))
         (X => PP) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_BMUXI_1

//%BEGIN SEH_BMUXI_2

`celldefine
module SEH_BMUXI_2 (PP, S, A, X, M0, M1);
   output PP;
   input S, A, X, M0, M1;

   wire int_res_0, int_res_1, int_res__M1,
      int_res_2, int_res_3, int_res__M0, int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, S);
   not (int_res_1, A);
   mux2 (int_res__M1, int_res_1, int_res_0, M1);
   not (int_res_2, S);
   not (int_res_3, A);
   mux2 (int_res__M0, int_res_3, int_res_2, M0);
   mux2 (int_res_mux1, int_res__M0, int_res__M1, X);

   `ifdef VIRL_functiononly
       not #1 (PP, int_res_mux1);        
   `else
       not (PP, int_res_mux1);        
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((M0 & M1))
         (A => PP) = 0;
      if ((M0 & ~(M1) & X))
         (A => PP) = 0;
      if ((~(M0) & M1 & ~(X)))
         (A => PP) = 0;
      if ((A & M1 & ~(S) & X))
         (M0 => PP) = 0;
      if ((A & ~(M1) & ~(S) & X))
         (M0 => PP) = 0;
      if ((~(A) & M1 & S & X))
         (M0 => PP) = 0;
      if ((~(A) & ~(M1) & S & X))
         (M0 => PP) = 0;
      if ((A & M0 & ~(S) & ~(X)))
         (M1 => PP) = 0;
      if ((A & ~(M0) & ~(S) & ~(X)))
         (M1 => PP) = 0;
      if ((~(A) & M0 & S & ~(X)))
         (M1 => PP) = 0;
      if ((~(A) & ~(M0) & S & ~(X)))
         (M1 => PP) = 0;
      if ((M0 & ~(M1) & ~(X)))
         (S => PP) = 0;
      if ((~(M0) & M1 & X))
         (S => PP) = 0;
      if ((~(M0) & ~(M1)))
         (S => PP) = 0;
      if ((A & M0 & ~(M1) & ~(S)))
         (X => PP) = 0;
      if ((~(A) & ~(M0) & M1 & S))
         (X => PP) = 0;
      if ((A & ~(M0) & M1 & ~(S)))
         (X => PP) = 0;
      if ((~(A) & M0 & ~(M1) & S))
         (X => PP) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_BMUXI_2

//%BEGIN SEH_BMUX_1

`celldefine
module SEH_BMUX_1 (PP, S, A, X, M0, M1);
   output PP;
   input S, A, X, M0, M1;

   wire int_res_0, int_res_1, int_res__M1,
	int_res_2, int_res_3, int_res__M0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, S);
   not (int_res_1, A);
   mux2 (int_res__M1, int_res_1, int_res_0, M1);
   not (int_res_2, S);
   not (int_res_3, A);
   mux2 (int_res__M0, int_res_3, int_res_2, M0);

   `ifdef VIRL_functiononly
       mux2 #1 (PP, int_res__M0, int_res__M1, X);
   `else
       mux2 (PP, int_res__M0, int_res__M1, X);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((M0 & M1))
         (A => PP) = 0;
      if ((M0 & ~(M1) & X))
         (A => PP) = 0;
      if ((~(M0) & M1 & ~(X)))
         (A => PP) = 0;
      if ((~(A) & M1 & S & X))
         (M0 => PP) = 0;
      if ((~(A) & ~(M1) & S & X))
         (M0 => PP) = 0;
      if ((A & M1 & ~(S) & X))
         (M0 => PP) = 0;
      if ((A & ~(M1) & ~(S) & X))
         (M0 => PP) = 0;
      if ((~(A) & M0 & S & ~(X)))
         (M1 => PP) = 0;
      if ((~(A) & ~(M0) & S & ~(X)))
         (M1 => PP) = 0;
      if ((A & M0 & ~(S) & ~(X)))
         (M1 => PP) = 0;
      if ((A & ~(M0) & ~(S) & ~(X)))
         (M1 => PP) = 0;
      if ((M0 & ~(M1) & ~(X)))
         (S => PP) = 0;
      if ((~(M0) & M1 & X))
         (S => PP) = 0;
      if ((~(M0) & ~(M1)))
         (S => PP) = 0;
      if ((A & ~(M0) & M1 & ~(S)))
         (X => PP) = 0;
      if ((~(A) & M0 & ~(M1) & S))
         (X => PP) = 0;
      if ((A & M0 & ~(M1) & ~(S)))
         (X => PP) = 0;
      if ((~(A) & ~(M0) & M1 & S))
         (X => PP) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_BMUX_1

//%BEGIN SEH_BMUX_2

`celldefine
module SEH_BMUX_2 (PP, S, A, X, M0, M1);
   output PP;
   input S, A, X, M0, M1;

   wire int_res_0, int_res_1, int_res__M1,
	int_res_2, int_res_3, int_res__M0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, S);
   not (int_res_1, A);
   mux2 (int_res__M1, int_res_1, int_res_0, M1);
   not (int_res_2, S);
   not (int_res_3, A);
   mux2 (int_res__M0, int_res_3, int_res_2, M0);

   `ifdef VIRL_functiononly
       mux2 #1 (PP, int_res__M0, int_res__M1, X);
   `else
       mux2 (PP, int_res__M0, int_res__M1, X);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      if ((M0 & M1))
         (A => PP) = 0;
      if ((M0 & ~(M1) & X))
         (A => PP) = 0;
      if ((~(M0) & M1 & ~(X)))
         (A => PP) = 0;
      if ((~(A) & M1 & S & X))
         (M0 => PP) = 0;
      if ((~(A) & ~(M1) & S & X))
         (M0 => PP) = 0;
      if ((A & M1 & ~(S) & X))
         (M0 => PP) = 0;
      if ((A & ~(M1) & ~(S) & X))
         (M0 => PP) = 0;
      if ((~(A) & M0 & S & ~(X)))
         (M1 => PP) = 0;
      if ((~(A) & ~(M0) & S & ~(X)))
         (M1 => PP) = 0;
      if ((A & M0 & ~(S) & ~(X)))
         (M1 => PP) = 0;
      if ((A & ~(M0) & ~(S) & ~(X)))
         (M1 => PP) = 0;
      if ((M0 & ~(M1) & ~(X)))
         (S => PP) = 0;
      if ((~(M0) & M1 & X))
         (S => PP) = 0;
      if ((~(M0) & ~(M1)))
         (S => PP) = 0;
      if ((A & ~(M0) & M1 & ~(S)))
         (X => PP) = 0;
      if ((~(A) & M0 & ~(M1) & S))
         (X => PP) = 0;
      if ((A & M0 & ~(M1) & ~(S)))
         (X => PP) = 0;
      if ((~(A) & ~(M0) & M1 & S))
         (X => PP) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_BMUX_2

//%BEGIN SEH_BUF_1

`celldefine
module SEH_BUF_1 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_1

//%BEGIN SEH_BUF_10

`celldefine
module SEH_BUF_10 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_10

//%BEGIN SEH_BUF_12

`celldefine
module SEH_BUF_12 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_12

//%BEGIN SEH_BUF_16

`celldefine
module SEH_BUF_16 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_16

//%BEGIN SEH_BUF_1P5

`celldefine
module SEH_BUF_1P5 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_1P5

//%BEGIN SEH_BUF_2

`celldefine
module SEH_BUF_2 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_2

//%BEGIN SEH_BUF_20

`celldefine
module SEH_BUF_20 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_20

//%BEGIN SEH_BUF_24

`celldefine
module SEH_BUF_24 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_24

//%BEGIN SEH_BUF_3

`celldefine
module SEH_BUF_3 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_3

//%BEGIN SEH_BUF_4

`celldefine
module SEH_BUF_4 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_4

//%BEGIN SEH_BUF_6

`celldefine
module SEH_BUF_6 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_6

//%BEGIN SEH_BUF_8

`celldefine
module SEH_BUF_8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_8

//%BEGIN SEH_BUF_CTV1Y2_12

`celldefine
module SEH_BUF_CTV1Y2_12 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTV1Y2_12

//%BEGIN SEH_BUF_CTV1Y2_16

`celldefine
module SEH_BUF_CTV1Y2_16 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTV1Y2_16

//%BEGIN SEH_BUF_CTV1Y2_24

`celldefine
module SEH_BUF_CTV1Y2_24 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTV1Y2_24

//%BEGIN SEH_BUF_CTV1Y2_32

`celldefine
module SEH_BUF_CTV1Y2_32 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTV1Y2_32

//%BEGIN SEH_BUF_CTV1Y2_4

`celldefine
module SEH_BUF_CTV1Y2_4 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTV1Y2_4

//%BEGIN SEH_BUF_CTV1Y2_48

`celldefine
module SEH_BUF_CTV1Y2_48 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTV1Y2_48

//%BEGIN SEH_BUF_CTV1Y2_6

`celldefine
module SEH_BUF_CTV1Y2_6 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTV1Y2_6

//%BEGIN SEH_BUF_CTV1Y2_64

`celldefine
module SEH_BUF_CTV1Y2_64 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTV1Y2_64

//%BEGIN SEH_BUF_CTV1Y2_8

`celldefine
module SEH_BUF_CTV1Y2_8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTV1Y2_8

//%BEGIN SEH_BUF_CTY2_12

`celldefine
module SEH_BUF_CTY2_12 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTY2_12

//%BEGIN SEH_BUF_CTY2_16

`celldefine
module SEH_BUF_CTY2_16 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTY2_16

//%BEGIN SEH_BUF_CTY2_20

`celldefine
module SEH_BUF_CTY2_20 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTY2_20

//%BEGIN SEH_BUF_CTY2_24

`celldefine
module SEH_BUF_CTY2_24 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTY2_24

//%BEGIN SEH_BUF_CTY2_32

`celldefine
module SEH_BUF_CTY2_32 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTY2_32

//%BEGIN SEH_BUF_CTY2_4

`celldefine
module SEH_BUF_CTY2_4 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTY2_4

//%BEGIN SEH_BUF_CTY2_48

`celldefine
module SEH_BUF_CTY2_48 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTY2_48

//%BEGIN SEH_BUF_CTY2_64

`celldefine
module SEH_BUF_CTY2_64 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTY2_64

//%BEGIN SEH_BUF_CTY2_8

`celldefine
module SEH_BUF_CTY2_8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_CTY2_8

//%BEGIN SEH_BUF_D_1

`celldefine
module SEH_BUF_D_1 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_D_1

//%BEGIN SEH_BUF_D_12

`celldefine
module SEH_BUF_D_12 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_D_12

//%BEGIN SEH_BUF_D_16

`celldefine
module SEH_BUF_D_16 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_D_16

//%BEGIN SEH_BUF_D_2

`celldefine
module SEH_BUF_D_2 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_D_2

//%BEGIN SEH_BUF_D_3

`celldefine
module SEH_BUF_D_3 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_D_3

//%BEGIN SEH_BUF_D_4

`celldefine
module SEH_BUF_D_4 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_D_4

//%BEGIN SEH_BUF_D_5

`celldefine
module SEH_BUF_D_5 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_D_5

//%BEGIN SEH_BUF_D_6

`celldefine
module SEH_BUF_D_6 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_D_6

//%BEGIN SEH_BUF_D_8

`celldefine
module SEH_BUF_D_8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_D_8

//%BEGIN SEH_BUF_S_1

`celldefine
module SEH_BUF_S_1 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_1

//%BEGIN SEH_BUF_S_12

`celldefine
module SEH_BUF_S_12 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_12

//%BEGIN SEH_BUF_S_16

`celldefine
module SEH_BUF_S_16 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_16

//%BEGIN SEH_BUF_S_1P25

`celldefine
module SEH_BUF_S_1P25 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_1P25

//%BEGIN SEH_BUF_S_1P5

`celldefine
module SEH_BUF_S_1P5 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_1P5

//%BEGIN SEH_BUF_S_2

`celldefine
module SEH_BUF_S_2 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_2

//%BEGIN SEH_BUF_S_24

`celldefine
module SEH_BUF_S_24 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_24

//%BEGIN SEH_BUF_S_3

`celldefine
module SEH_BUF_S_3 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_3

//%BEGIN SEH_BUF_S_32

`celldefine
module SEH_BUF_S_32 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_32

//%BEGIN SEH_BUF_S_4

`celldefine
module SEH_BUF_S_4 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_4

//%BEGIN SEH_BUF_S_6

`celldefine
module SEH_BUF_S_6 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_6

//%BEGIN SEH_BUF_S_8

`celldefine
module SEH_BUF_S_8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (X, A);
   `else
       buf (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_BUF_S_8

//%BEGIN SEH_CAPL8

`celldefine
module SEH_CAPL8 ();
endmodule
`endcelldefine

//%END SEH_CAPL8

//%BEGIN SEH_CAPLNOPG8

`celldefine
module SEH_CAPLNOPG8 ();
endmodule
`endcelldefine

//%END SEH_CAPLNOPG8

//%BEGIN SEH_CAPLV2Y8

`celldefine
module SEH_CAPLV2Y8 ();
endmodule
`endcelldefine

//%END SEH_CAPLV2Y8

//%BEGIN SEH_CAPR8

`celldefine
module SEH_CAPR8 ();
endmodule
`endcelldefine

//%END SEH_CAPR8

//%BEGIN SEH_CAPRNOPG8

`celldefine
module SEH_CAPRNOPG8 ();
endmodule
`endcelldefine

//%END SEH_CAPRNOPG8

//%BEGIN SEH_CAPRV2Y8

`celldefine
module SEH_CAPRV2Y8 ();
endmodule
`endcelldefine

//%END SEH_CAPRV2Y8

//%BEGIN SEH_CKGTNLT_1

`celldefine
module SEH_CKGTNLT_1 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_1

//%BEGIN SEH_CKGTNLT_12

`celldefine
module SEH_CKGTNLT_12 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_12

//%BEGIN SEH_CKGTNLT_16

`celldefine
module SEH_CKGTNLT_16 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_16

//%BEGIN SEH_CKGTNLT_2

`celldefine
module SEH_CKGTNLT_2 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_2

//%BEGIN SEH_CKGTNLT_3

`celldefine
module SEH_CKGTNLT_3 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_3

//%BEGIN SEH_CKGTNLT_4

`celldefine
module SEH_CKGTNLT_4 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_4

//%BEGIN SEH_CKGTNLT_6

`celldefine
module SEH_CKGTNLT_6 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_6

//%BEGIN SEH_CKGTNLT_8

`celldefine
module SEH_CKGTNLT_8 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_8

//%BEGIN SEH_CKGTNLT_CTY2_12

`celldefine
module SEH_CKGTNLT_CTY2_12 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_CTY2_12

//%BEGIN SEH_CKGTNLT_CTY2_16

`celldefine
module SEH_CKGTNLT_CTY2_16 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_CTY2_16

//%BEGIN SEH_CKGTNLT_CTY2_24

`celldefine
module SEH_CKGTNLT_CTY2_24 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_CTY2_24

//%BEGIN SEH_CKGTNLT_CTY2_32

`celldefine
module SEH_CKGTNLT_CTY2_32 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_CTY2_32

//%BEGIN SEH_CKGTNLT_CTY2_4

`celldefine
module SEH_CKGTNLT_CTY2_4 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_CTY2_4

//%BEGIN SEH_CKGTNLT_CTY2_6

`celldefine
module SEH_CKGTNLT_CTY2_6 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_CTY2_6

//%BEGIN SEH_CKGTNLT_CTY2_8

`celldefine
module SEH_CKGTNLT_CTY2_8 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__prectrl, int_res_iq, iq_y;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, delayed_CK, int_res__prectrl);
   not (iq_y, int_res_iq);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #0 (Q, iq_y, delayed_CK);
   `else
       or (Q, iq_y, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else


   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((~(EN) & ~(SE)))
         (posedge CK => (Q+:1'b1)) = 0;
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      $setuphold (negedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTNLT_CTY2_8

//%BEGIN SEH_CKGTPLS_V3_1

`celldefine
module SEH_CKGTPLS_V3_1 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res_postctrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
`endif
   buf (delayed_SE, SE);

   not (int_res__CK, delayed_CK);
   latch (int_res_iq, viol_0, int_res__CK, delayed_EN);
   or (int_res_postctrl, int_res_iq, delayed_SE);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      and #0 (Q, int_res_postctrl, delayed_CK);
   `else
      and (Q, int_res_postctrl, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, EN__bar, SE__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, EN, SE__bar);
   and (cond1, EN, SE);
   not (EN__bar, EN);
   and (cond2, EN__bar, SE);
   and (cond3, EN__bar, SE__bar);

   specify
      (SE => Q) = 0;
      if ((EN & SE))
         (CK => Q) = 0;
      if ((EN & ~(SE)))
         (CK => Q) = 0;
      if ((~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& SE, posedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& SE, negedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $recovery (negedge SE &&& ~EN, posedge CK &&& ~EN, 0, viol_0);
      $hold (negedge CK &&& EN, posedge SE &&& EN, 0, viol_0);
      $hold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, viol_0);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLS_V3_1

//%BEGIN SEH_CKGTPLS_V3_12

`celldefine
module SEH_CKGTPLS_V3_12 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res_postctrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
`endif
   buf (delayed_SE, SE);

   not (int_res__CK, delayed_CK);
   latch (int_res_iq, viol_0, int_res__CK, delayed_EN);
   or (int_res_postctrl, int_res_iq, delayed_SE);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      and #0 (Q, int_res_postctrl, delayed_CK);
   `else
      and (Q, int_res_postctrl, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, EN__bar, SE__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, EN, SE__bar);
   and (cond1, EN, SE);
   not (EN__bar, EN);
   and (cond2, EN__bar, SE);
   and (cond3, EN__bar, SE__bar);

   specify
      (SE => Q) = 0;
      if ((EN & SE))
         (CK => Q) = 0;
      if ((EN & ~(SE)))
         (CK => Q) = 0;
      if ((~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& SE, posedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& SE, negedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $recovery (negedge SE &&& ~EN, posedge CK &&& ~EN, 0, viol_0);
      $hold (negedge CK &&& EN, posedge SE &&& EN, 0, viol_0);
      $hold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, viol_0);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLS_V3_12

//%BEGIN SEH_CKGTPLS_V3_16

`celldefine
module SEH_CKGTPLS_V3_16 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res_postctrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
`endif
   buf (delayed_SE, SE);

   not (int_res__CK, delayed_CK);
   latch (int_res_iq, viol_0, int_res__CK, delayed_EN);
   or (int_res_postctrl, int_res_iq, delayed_SE);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      and #0 (Q, int_res_postctrl, delayed_CK);
   `else
      and (Q, int_res_postctrl, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, EN__bar, SE__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, EN, SE__bar);
   and (cond1, EN, SE);
   not (EN__bar, EN);
   and (cond2, EN__bar, SE);
   and (cond3, EN__bar, SE__bar);

   specify
      (SE => Q) = 0;
      if ((EN & SE))
         (CK => Q) = 0;
      if ((EN & ~(SE)))
         (CK => Q) = 0;
      if ((~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& SE, posedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& SE, negedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $recovery (negedge SE &&& ~EN, posedge CK &&& ~EN, 0, viol_0);
      $hold (negedge CK &&& EN, posedge SE &&& EN, 0, viol_0);
      $hold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, viol_0);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLS_V3_16

//%BEGIN SEH_CKGTPLS_V3_2

`celldefine
module SEH_CKGTPLS_V3_2 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res_postctrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
`endif
   buf (delayed_SE, SE);

   not (int_res__CK, delayed_CK);
   latch (int_res_iq, viol_0, int_res__CK, delayed_EN);
   or (int_res_postctrl, int_res_iq, delayed_SE);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      and #0 (Q, int_res_postctrl, delayed_CK);
   `else
      and (Q, int_res_postctrl, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, EN__bar, SE__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, EN, SE__bar);
   and (cond1, EN, SE);
   not (EN__bar, EN);
   and (cond2, EN__bar, SE);
   and (cond3, EN__bar, SE__bar);

   specify
      (SE => Q) = 0;
      if ((EN & SE))
         (CK => Q) = 0;
      if ((EN & ~(SE)))
         (CK => Q) = 0;
      if ((~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& SE, posedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& SE, negedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $recovery (negedge SE &&& ~EN, posedge CK &&& ~EN, 0, viol_0);
      $hold (negedge CK &&& EN, posedge SE &&& EN, 0, viol_0);
      $hold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, viol_0);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLS_V3_2

//%BEGIN SEH_CKGTPLS_V3_3

`celldefine
module SEH_CKGTPLS_V3_3 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res_postctrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
`endif
   buf (delayed_SE, SE);

   not (int_res__CK, delayed_CK);
   latch (int_res_iq, viol_0, int_res__CK, delayed_EN);
   or (int_res_postctrl, int_res_iq, delayed_SE);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      and #0 (Q, int_res_postctrl, delayed_CK);
   `else
      and (Q, int_res_postctrl, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, EN__bar, SE__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, EN, SE__bar);
   and (cond1, EN, SE);
   not (EN__bar, EN);
   and (cond2, EN__bar, SE);
   and (cond3, EN__bar, SE__bar);

   specify
      (SE => Q) = 0;
      if ((EN & SE))
         (CK => Q) = 0;
      if ((EN & ~(SE)))
         (CK => Q) = 0;
      if ((~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& SE, posedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& SE, negedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $recovery (negedge SE &&& ~EN, posedge CK &&& ~EN, 0, viol_0);
      $hold (negedge CK &&& EN, posedge SE &&& EN, 0, viol_0);
      $hold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, viol_0);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLS_V3_3

//%BEGIN SEH_CKGTPLS_V3_4

`celldefine
module SEH_CKGTPLS_V3_4 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res_postctrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
`endif
   buf (delayed_SE, SE);

   not (int_res__CK, delayed_CK);
   latch (int_res_iq, viol_0, int_res__CK, delayed_EN);
   or (int_res_postctrl, int_res_iq, delayed_SE);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      and #0 (Q, int_res_postctrl, delayed_CK);
   `else
      and (Q, int_res_postctrl, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, EN__bar, SE__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, EN, SE__bar);
   and (cond1, EN, SE);
   not (EN__bar, EN);
   and (cond2, EN__bar, SE);
   and (cond3, EN__bar, SE__bar);

   specify
      (SE => Q) = 0;
      if ((EN & SE))
         (CK => Q) = 0;
      if ((EN & ~(SE)))
         (CK => Q) = 0;
      if ((~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& SE, posedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& SE, negedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $recovery (negedge SE &&& ~EN, posedge CK &&& ~EN, 0, viol_0);
      $hold (negedge CK &&& EN, posedge SE &&& EN, 0, viol_0);
      $hold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, viol_0);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLS_V3_4

//%BEGIN SEH_CKGTPLS_V3_6

`celldefine
module SEH_CKGTPLS_V3_6 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res_postctrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
`endif
   buf (delayed_SE, SE);

   not (int_res__CK, delayed_CK);
   latch (int_res_iq, viol_0, int_res__CK, delayed_EN);
   or (int_res_postctrl, int_res_iq, delayed_SE);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      and #0 (Q, int_res_postctrl, delayed_CK);
   `else
      and (Q, int_res_postctrl, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, EN__bar, SE__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, EN, SE__bar);
   and (cond1, EN, SE);
   not (EN__bar, EN);
   and (cond2, EN__bar, SE);
   and (cond3, EN__bar, SE__bar);

   specify
      (SE => Q) = 0;
      if ((EN & SE))
         (CK => Q) = 0;
      if ((EN & ~(SE)))
         (CK => Q) = 0;
      if ((~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& SE, posedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& SE, negedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $recovery (negedge SE &&& ~EN, posedge CK &&& ~EN, 0, viol_0);
      $hold (negedge CK &&& EN, posedge SE &&& EN, 0, viol_0);
      $hold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, viol_0);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLS_V3_6

//%BEGIN SEH_CKGTPLS_V3_8

`celldefine
module SEH_CKGTPLS_V3_8 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res_postctrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
`endif
   buf (delayed_SE, SE);

   not (int_res__CK, delayed_CK);
   latch (int_res_iq, viol_0, int_res__CK, delayed_EN);
   or (int_res_postctrl, int_res_iq, delayed_SE);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      and #0 (Q, int_res_postctrl, delayed_CK);
   `else
      and (Q, int_res_postctrl, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, EN__bar, SE__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, EN, SE__bar);
   and (cond1, EN, SE);
   not (EN__bar, EN);
   and (cond2, EN__bar, SE);
   and (cond3, EN__bar, SE__bar);

   specify
      (SE => Q) = 0;
      if ((EN & SE))
         (CK => Q) = 0;
      if ((EN & ~(SE)))
         (CK => Q) = 0;
      if ((~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& SE, posedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& SE, negedge EN &&& SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $recovery (negedge SE &&& ~EN, posedge CK &&& ~EN, 0, viol_0);
      $hold (negedge CK &&& EN, posedge SE &&& EN, 0, viol_0);
      $hold (negedge CK &&& ~EN, posedge SE &&& ~EN, 0, viol_0);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLS_V3_8

//%BEGIN SEH_CKGTPLT_CTY2_12

`celldefine
module SEH_CKGTPLT_CTY2_12 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_CTY2_12

//%BEGIN SEH_CKGTPLT_CTY2_16

`celldefine
module SEH_CKGTPLT_CTY2_16 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_CTY2_16

//%BEGIN SEH_CKGTPLT_CTY2_24

`celldefine
module SEH_CKGTPLT_CTY2_24 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_CTY2_24

//%BEGIN SEH_CKGTPLT_CTY2_32

`celldefine
module SEH_CKGTPLT_CTY2_32 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_CTY2_32

//%BEGIN SEH_CKGTPLT_CTY2_4

`celldefine
module SEH_CKGTPLT_CTY2_4 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_CTY2_4

//%BEGIN SEH_CKGTPLT_CTY2_48

`celldefine
module SEH_CKGTPLT_CTY2_48 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_CTY2_48

//%BEGIN SEH_CKGTPLT_CTY2_6

`celldefine
module SEH_CKGTPLT_CTY2_6 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_CTY2_6

//%BEGIN SEH_CKGTPLT_CTY2_64

`celldefine
module SEH_CKGTPLT_CTY2_64 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_CTY2_64

//%BEGIN SEH_CKGTPLT_CTY2_8

`celldefine
module SEH_CKGTPLT_CTY2_8 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_CTY2_8

//%BEGIN SEH_CKGTPLT_V5_1

`celldefine
module SEH_CKGTPLT_V5_1 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_V5_1

//%BEGIN SEH_CKGTPLT_V5_12

`celldefine
module SEH_CKGTPLT_V5_12 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_V5_12

//%BEGIN SEH_CKGTPLT_V5_16

`celldefine
module SEH_CKGTPLT_V5_16 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_V5_16

//%BEGIN SEH_CKGTPLT_V5_2

`celldefine
module SEH_CKGTPLT_V5_2 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_V5_2

//%BEGIN SEH_CKGTPLT_V5_3

`celldefine
module SEH_CKGTPLT_V5_3 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_V5_3

//%BEGIN SEH_CKGTPLT_V5_4

`celldefine
module SEH_CKGTPLT_V5_4 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_V5_4

//%BEGIN SEH_CKGTPLT_V5_6

`celldefine
module SEH_CKGTPLT_V5_6 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_V5_6

//%BEGIN SEH_CKGTPLT_V5_8

`celldefine
module SEH_CKGTPLT_V5_8 (Q, CK, EN, SE);
   output Q;
   input CK, EN, SE;

   reg viol_0;
   wire delayed_CK, delayed_EN, delayed_SE;

   wire int_res__CK, int_res__prectrl, int_res_iq;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_EN, EN);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   or (int_res__prectrl, delayed_EN, delayed_SE);
   latch (int_res_iq, viol_0, int_res__CK, int_res__prectrl);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       and #0 (Q, int_res_iq, delayed_CK);
   `else
       and (Q, int_res_iq, delayed_CK);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, EN__bar;
   wire int_twire_0, SE__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (int_twire_0, EN__bar, SE);
   or (cond0, EN, int_twire_0);
   not (SE__bar, SE);
   and (cond1, EN__bar, SE__bar);

   specify
      if ((EN) | (~(EN) & SE))
         (CK => Q) = 0;
      if ((~(EN) & ~(SE)))
         (negedge CK => (Q+:1'b0)) = 0;
      $setuphold (posedge CK &&& ~SE, posedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~SE, negedge EN &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~EN, posedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& ~EN, negedge SE &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_CKGTPLT_V5_8

//%BEGIN SEH_DCAP16

`celldefine
module SEH_DCAP16 ();
endmodule
`endcelldefine

//%END SEH_DCAP16

//%BEGIN SEH_DCAP32

`celldefine
module SEH_DCAP32 ();
endmodule
`endcelldefine

//%END SEH_DCAP32

//%BEGIN SEH_DCAP4

`celldefine
module SEH_DCAP4 ();
endmodule
`endcelldefine

//%END SEH_DCAP4

//%BEGIN SEH_DCAP64

`celldefine
module SEH_DCAP64 ();
endmodule
`endcelldefine

//%END SEH_DCAP64

//%BEGIN SEH_DCAP8

`celldefine
module SEH_DCAP8 ();
endmodule
`endcelldefine

//%END SEH_DCAP8

//%BEGIN SEH_DEL_L4_1

`celldefine
module SEH_DEL_L4_1 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     buf #1 (X, A);
   `else
     buf (X, A);
   `endif

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_DEL_L4_1

//%BEGIN SEH_DEL_L4_2

`celldefine
module SEH_DEL_L4_2 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     buf #1 (X, A);
   `else
     buf (X, A);
   `endif

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_DEL_L4_2

//%BEGIN SEH_DEL_L4_4

`celldefine
module SEH_DEL_L4_4 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     buf #1 (X, A);
   `else
     buf (X, A);
   `endif

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_DEL_L4_4

//%BEGIN SEH_DEL_L4_8

`celldefine
module SEH_DEL_L4_8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     buf #1 (X, A);
   `else
     buf (X, A);
   `endif

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_DEL_L4_8

//%BEGIN SEH_DEL_L6_1

`celldefine
module SEH_DEL_L6_1 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     buf #1 (X, A);
   `else
     buf (X, A);
   `endif

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_DEL_L6_1

//%BEGIN SEH_DEL_L6_2

`celldefine
module SEH_DEL_L6_2 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     buf #1 (X, A);
   `else
     buf (X, A);
   `endif

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_DEL_L6_2

//%BEGIN SEH_DEL_L6_4

`celldefine
module SEH_DEL_L6_4 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     buf #1 (X, A);
   `else
     buf (X, A);
   `endif

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_DEL_L6_4

//%BEGIN SEH_DEL_L6_8

`celldefine
module SEH_DEL_L6_8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     buf #1 (X, A);
   `else
     buf (X, A);
   `endif

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_DEL_L6_8

//%BEGIN SEH_EN2_0P5

`celldefine
module SEH_EN2_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_0P5

//%BEGIN SEH_EN2_1

`celldefine
module SEH_EN2_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_1

//%BEGIN SEH_EN2_2

`celldefine
module SEH_EN2_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_2

//%BEGIN SEH_EN2_3

`celldefine
module SEH_EN2_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_3

//%BEGIN SEH_EN2_4

`celldefine
module SEH_EN2_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_4

//%BEGIN SEH_EN2_5

`celldefine
module SEH_EN2_5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_5

//%BEGIN SEH_EN2_6

`celldefine
module SEH_EN2_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_6

//%BEGIN SEH_EN2_8

`celldefine
module SEH_EN2_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_8

//%BEGIN SEH_EN2_DG_1

`celldefine
module SEH_EN2_DG_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_DG_1

//%BEGIN SEH_EN2_DG_12

`celldefine
module SEH_EN2_DG_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_DG_12

//%BEGIN SEH_EN2_DG_16

`celldefine
module SEH_EN2_DG_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_DG_16

//%BEGIN SEH_EN2_DG_2

`celldefine
module SEH_EN2_DG_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_DG_2

//%BEGIN SEH_EN2_DG_4

`celldefine
module SEH_EN2_DG_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_DG_4

//%BEGIN SEH_EN2_DG_6

`celldefine
module SEH_EN2_DG_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_DG_6

//%BEGIN SEH_EN2_DG_8

`celldefine
module SEH_EN2_DG_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_DG_8

//%BEGIN SEH_EN2_GY2_16

`celldefine
module SEH_EN2_GY2_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_GY2_16

//%BEGIN SEH_EN2_G_1

`celldefine
module SEH_EN2_G_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_G_1

//%BEGIN SEH_EN2_G_12

`celldefine
module SEH_EN2_G_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_G_12

//%BEGIN SEH_EN2_G_2

`celldefine
module SEH_EN2_G_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_G_2

//%BEGIN SEH_EN2_G_3

`celldefine
module SEH_EN2_G_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_G_3

//%BEGIN SEH_EN2_G_4

`celldefine
module SEH_EN2_G_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_G_4

//%BEGIN SEH_EN2_G_6

`celldefine
module SEH_EN2_G_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_G_6

//%BEGIN SEH_EN2_G_8

`celldefine
module SEH_EN2_G_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_G_8

//%BEGIN SEH_EN2_S_0P5

`celldefine
module SEH_EN2_S_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_S_0P5

//%BEGIN SEH_EN2_S_1

`celldefine
module SEH_EN2_S_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_S_1

//%BEGIN SEH_EN2_S_2

`celldefine
module SEH_EN2_S_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_S_2

//%BEGIN SEH_EN2_S_3

`celldefine
module SEH_EN2_S_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_S_3

//%BEGIN SEH_EN2_S_4

`celldefine
module SEH_EN2_S_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_S_4

//%BEGIN SEH_EN2_S_6

`celldefine
module SEH_EN2_S_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_S_6

//%BEGIN SEH_EN2_S_8

`celldefine
module SEH_EN2_S_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       xnor #1 (X, A1, A2);
   `else
       xnor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (A2)
         (A1 => X) = 0;
      if (~(A2))
         (A1 => X) = 0;
      if (A1)
         (A2 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_EN2_S_8

//%BEGIN SEH_EN3_1

`celldefine
module SEH_EN3_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
        xnor #1 (X, A1, A2, A3);
   `else
        xnor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN3_1

//%BEGIN SEH_EN3_2

`celldefine
module SEH_EN3_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
        xnor #1 (X, A1, A2, A3);
   `else
        xnor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN3_2

//%BEGIN SEH_EN3_3

`celldefine
module SEH_EN3_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
        xnor #1 (X, A1, A2, A3);
   `else
        xnor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN3_3

//%BEGIN SEH_EN3_4

`celldefine
module SEH_EN3_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
        xnor #1 (X, A1, A2, A3);
   `else
        xnor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN3_4

//%BEGIN SEH_EN3_6

`celldefine
module SEH_EN3_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
        xnor #1 (X, A1, A2, A3);
   `else
        xnor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN3_6

//%BEGIN SEH_EN3_DGY2_10

`celldefine
module SEH_EN3_DGY2_10 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
        xnor #1 (X, A1, A2, A3);
   `else
        xnor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN3_DGY2_10

//%BEGIN SEH_EN3_DG_1

`celldefine
module SEH_EN3_DG_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
        xnor #1 (X, A1, A2, A3);
   `else
        xnor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN3_DG_1

//%BEGIN SEH_EN3_DG_2

`celldefine
module SEH_EN3_DG_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
        xnor #1 (X, A1, A2, A3);
   `else
        xnor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN3_DG_2

//%BEGIN SEH_EN3_DG_3

`celldefine
module SEH_EN3_DG_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
        xnor #1 (X, A1, A2, A3);
   `else
        xnor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN3_DG_3

//%BEGIN SEH_EN3_DG_4

`celldefine
module SEH_EN3_DG_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
        xnor #1 (X, A1, A2, A3);
   `else
        xnor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN3_DG_4

//%BEGIN SEH_EN3_DG_8

`celldefine
module SEH_EN3_DG_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
        xnor #1 (X, A1, A2, A3);
   `else
        xnor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN3_DG_8

//%BEGIN SEH_EN4_DGY2_8

`celldefine
module SEH_EN4_DGY2_8 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xnor #1 (X, A1, A2, A3, A4);

   `else
         xnor (X, A1, A2, A3, A4);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3 & A4) | (~(A2) & A3 & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & ~(A4)) | (~(A2) & ~(A3) & A4))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(A4)) | (~(A2) & A3 & A4))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & A4) | (~(A2) & ~(A3) & ~(A4)))
         (A1 => X) = 0;
      if ((A1 & A3 & A4))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & A4))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & A4))
         (A2 => X) = 0;
      if ((~(A1) & A3 & A4))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & A2 & A4) | (A1 & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((~(A1) & A2 & ~(A4)) | (~(A1) & ~(A2) & A4))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A4)) | (A1 & ~(A2) & A4))
         (A3 => X) = 0;
      if ((~(A1) & A2 & A4) | (~(A1) & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (A4 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & A3))
         (A4 => X) = 0;
      if ((~(A1) & A2 & A3))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN4_DGY2_8

//%BEGIN SEH_EN4_DG_1

`celldefine
module SEH_EN4_DG_1 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xnor #1 (X, A1, A2, A3, A4);

   `else
         xnor (X, A1, A2, A3, A4);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3 & A4) | (~(A2) & A3 & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & ~(A4)) | (~(A2) & ~(A3) & A4))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(A4)) | (~(A2) & A3 & A4))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & A4) | (~(A2) & ~(A3) & ~(A4)))
         (A1 => X) = 0;
      if ((A1 & A3 & A4))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & A4))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & A4))
         (A2 => X) = 0;
      if ((~(A1) & A3 & A4))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & A2 & A4) | (A1 & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((~(A1) & A2 & ~(A4)) | (~(A1) & ~(A2) & A4))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A4)) | (A1 & ~(A2) & A4))
         (A3 => X) = 0;
      if ((~(A1) & A2 & A4) | (~(A1) & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (A4 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & A3))
         (A4 => X) = 0;
      if ((~(A1) & A2 & A3))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN4_DG_1

//%BEGIN SEH_EN4_DG_2

`celldefine
module SEH_EN4_DG_2 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xnor #1 (X, A1, A2, A3, A4);

   `else
         xnor (X, A1, A2, A3, A4);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3 & A4) | (~(A2) & A3 & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & ~(A4)) | (~(A2) & ~(A3) & A4))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(A4)) | (~(A2) & A3 & A4))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & A4) | (~(A2) & ~(A3) & ~(A4)))
         (A1 => X) = 0;
      if ((A1 & A3 & A4))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & A4))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & A4))
         (A2 => X) = 0;
      if ((~(A1) & A3 & A4))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & A2 & A4) | (A1 & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((~(A1) & A2 & ~(A4)) | (~(A1) & ~(A2) & A4))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A4)) | (A1 & ~(A2) & A4))
         (A3 => X) = 0;
      if ((~(A1) & A2 & A4) | (~(A1) & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (A4 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & A3))
         (A4 => X) = 0;
      if ((~(A1) & A2 & A3))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN4_DG_2

//%BEGIN SEH_EN4_DG_3

`celldefine
module SEH_EN4_DG_3 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xnor #1 (X, A1, A2, A3, A4);

   `else
         xnor (X, A1, A2, A3, A4);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3 & A4) | (~(A2) & A3 & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & ~(A4)) | (~(A2) & ~(A3) & A4))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(A4)) | (~(A2) & A3 & A4))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & A4) | (~(A2) & ~(A3) & ~(A4)))
         (A1 => X) = 0;
      if ((A1 & A3 & A4))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & A4))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & A4))
         (A2 => X) = 0;
      if ((~(A1) & A3 & A4))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & A2 & A4) | (A1 & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((~(A1) & A2 & ~(A4)) | (~(A1) & ~(A2) & A4))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A4)) | (A1 & ~(A2) & A4))
         (A3 => X) = 0;
      if ((~(A1) & A2 & A4) | (~(A1) & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (A4 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & A3))
         (A4 => X) = 0;
      if ((~(A1) & A2 & A3))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN4_DG_3

//%BEGIN SEH_EN4_DG_4

`celldefine
module SEH_EN4_DG_4 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xnor #1 (X, A1, A2, A3, A4);

   `else
         xnor (X, A1, A2, A3, A4);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3 & A4) | (~(A2) & A3 & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & ~(A4)) | (~(A2) & ~(A3) & A4))
         (A1 => X) = 0;
      if ((A2 & A3 & ~(A4)) | (~(A2) & A3 & A4))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & A4) | (~(A2) & ~(A3) & ~(A4)))
         (A1 => X) = 0;
      if ((A1 & A3 & A4))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & A4))
         (A2 => X) = 0;
      if ((A1 & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & A4))
         (A2 => X) = 0;
      if ((~(A1) & A3 & A4))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & A2 & A4) | (A1 & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((~(A1) & A2 & ~(A4)) | (~(A1) & ~(A2) & A4))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A4)) | (A1 & ~(A2) & A4))
         (A3 => X) = 0;
      if ((~(A1) & A2 & A4) | (~(A1) & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (A4 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & A3))
         (A4 => X) = 0;
      if ((~(A1) & A2 & A3))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EN4_DG_4

//%BEGIN SEH_EO2_0P5

`celldefine
module SEH_EO2_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_0P5

//%BEGIN SEH_EO2_1

`celldefine
module SEH_EO2_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_1

//%BEGIN SEH_EO2_2

`celldefine
module SEH_EO2_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_2

//%BEGIN SEH_EO2_3

`celldefine
module SEH_EO2_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_3

//%BEGIN SEH_EO2_4

`celldefine
module SEH_EO2_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_4

//%BEGIN SEH_EO2_6

`celldefine
module SEH_EO2_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_6

//%BEGIN SEH_EO2_8

`celldefine
module SEH_EO2_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_8

//%BEGIN SEH_EO2_CTY2_16

`celldefine
module SEH_EO2_CTY2_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_CTY2_16

//%BEGIN SEH_EO2_CTY2_4

`celldefine
module SEH_EO2_CTY2_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_CTY2_4

//%BEGIN SEH_EO2_CTY2_6

`celldefine
module SEH_EO2_CTY2_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_CTY2_6

//%BEGIN SEH_EO2_CTY2_8

`celldefine
module SEH_EO2_CTY2_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_CTY2_8

//%BEGIN SEH_EO2_DG_1

`celldefine
module SEH_EO2_DG_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_DG_1

//%BEGIN SEH_EO2_DG_16

`celldefine
module SEH_EO2_DG_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_DG_16

//%BEGIN SEH_EO2_DG_2

`celldefine
module SEH_EO2_DG_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_DG_2

//%BEGIN SEH_EO2_DG_4

`celldefine
module SEH_EO2_DG_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_DG_4

//%BEGIN SEH_EO2_DG_8

`celldefine
module SEH_EO2_DG_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_DG_8

//%BEGIN SEH_EO2_GY2_16

`celldefine
module SEH_EO2_GY2_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_GY2_16

//%BEGIN SEH_EO2_G_1

`celldefine
module SEH_EO2_G_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_G_1

//%BEGIN SEH_EO2_G_10

`celldefine
module SEH_EO2_G_10 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_G_10

//%BEGIN SEH_EO2_G_2

`celldefine
module SEH_EO2_G_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_G_2

//%BEGIN SEH_EO2_G_3

`celldefine
module SEH_EO2_G_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_G_3

//%BEGIN SEH_EO2_G_4

`celldefine
module SEH_EO2_G_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_G_4

//%BEGIN SEH_EO2_G_8

`celldefine
module SEH_EO2_G_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_G_8

//%BEGIN SEH_EO2_S_0P5

`celldefine
module SEH_EO2_S_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_S_0P5

//%BEGIN SEH_EO2_S_1

`celldefine
module SEH_EO2_S_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_S_1

//%BEGIN SEH_EO2_S_2

`celldefine
module SEH_EO2_S_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_S_2

//%BEGIN SEH_EO2_S_3

`celldefine
module SEH_EO2_S_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_S_3

//%BEGIN SEH_EO2_S_4

`celldefine
module SEH_EO2_S_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_S_4

//%BEGIN SEH_EO2_S_5

`celldefine
module SEH_EO2_S_5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_S_5

//%BEGIN SEH_EO2_S_6

`celldefine
module SEH_EO2_S_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_S_6

//%BEGIN SEH_EO2_S_8

`celldefine
module SEH_EO2_S_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2);
   `else
         xor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if (~(A2))
         (A1 => X) = 0;
      if (A2)
         (A1 => X) = 0;
      if (~(A1))
         (A2 => X) = 0;
      if (A1)
         (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO2_S_8

//%BEGIN SEH_EO3_0P5

`celldefine
module SEH_EO3_0P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2, A3);
   `else
         xor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO3_0P5

//%BEGIN SEH_EO3_1

`celldefine
module SEH_EO3_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2, A3);
   `else
         xor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO3_1

//%BEGIN SEH_EO3_2

`celldefine
module SEH_EO3_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2, A3);
   `else
         xor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO3_2

//%BEGIN SEH_EO3_3

`celldefine
module SEH_EO3_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2, A3);
   `else
         xor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO3_3

//%BEGIN SEH_EO3_4

`celldefine
module SEH_EO3_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2, A3);
   `else
         xor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO3_4

//%BEGIN SEH_EO3_6

`celldefine
module SEH_EO3_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2, A3);
   `else
         xor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO3_6

//%BEGIN SEH_EO3_DGY2_10

`celldefine
module SEH_EO3_DGY2_10 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2, A3);
   `else
         xor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO3_DGY2_10

//%BEGIN SEH_EO3_DG_1

`celldefine
module SEH_EO3_DG_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2, A3);
   `else
         xor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO3_DG_1

//%BEGIN SEH_EO3_DG_2

`celldefine
module SEH_EO3_DG_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2, A3);
   `else
         xor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO3_DG_2

//%BEGIN SEH_EO3_DG_4

`celldefine
module SEH_EO3_DG_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2, A3);
   `else
         xor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO3_DG_4

//%BEGIN SEH_EO3_DG_8

`celldefine
module SEH_EO3_DG_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         xor #1 (X, A1, A2, A3);
   `else
         xor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3)))
         (A1 => X) = 0;
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & A3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3)))
         (A2 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & A2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2)))
         (A3 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO3_DG_8

//%BEGIN SEH_EO4_DGY2_8

`celldefine
module SEH_EO4_DGY2_8 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        xor #1 (X, A1, A2, A3, A4);

   `else
        xor (X, A1, A2, A3, A4);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3 & ~(A4)) | (~(A2) & A3 & A4))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & A4) | (~(A2) & ~(A3) & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & A3 & A4) | (~(A2) & A3 & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & ~(A4)) | (~(A2) & ~(A3) & A4))
         (A1 => X) = 0;
      if ((A1 & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & A4))
         (A2 => X) = 0;
      if ((~(A1) & A3 & A4))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & A3 & A4))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & A4))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(A4)) | (A1 & ~(A2) & A4))
         (A3 => X) = 0;
      if ((~(A1) & A2 & A4) | (~(A1) & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((A1 & A2 & A4) | (A1 & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((~(A1) & A2 & ~(A4)) | (~(A1) & ~(A2) & A4))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & A3))
         (A4 => X) = 0;
      if ((~(A1) & A2 & A3))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & A2 & A3))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO4_DGY2_8

//%BEGIN SEH_EO4_DG_1

`celldefine
module SEH_EO4_DG_1 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        xor #1 (X, A1, A2, A3, A4);

   `else
        xor (X, A1, A2, A3, A4);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3 & ~(A4)) | (~(A2) & A3 & A4))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & A4) | (~(A2) & ~(A3) & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & A3 & A4) | (~(A2) & A3 & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & ~(A4)) | (~(A2) & ~(A3) & A4))
         (A1 => X) = 0;
      if ((A1 & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & A4))
         (A2 => X) = 0;
      if ((~(A1) & A3 & A4))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & A3 & A4))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & A4))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(A4)) | (A1 & ~(A2) & A4))
         (A3 => X) = 0;
      if ((~(A1) & A2 & A4) | (~(A1) & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((A1 & A2 & A4) | (A1 & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((~(A1) & A2 & ~(A4)) | (~(A1) & ~(A2) & A4))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & A3))
         (A4 => X) = 0;
      if ((~(A1) & A2 & A3))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & A2 & A3))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO4_DG_1

//%BEGIN SEH_EO4_DG_2

`celldefine
module SEH_EO4_DG_2 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        xor #1 (X, A1, A2, A3, A4);

   `else
        xor (X, A1, A2, A3, A4);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3 & ~(A4)) | (~(A2) & A3 & A4))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & A4) | (~(A2) & ~(A3) & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & A3 & A4) | (~(A2) & A3 & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & ~(A4)) | (~(A2) & ~(A3) & A4))
         (A1 => X) = 0;
      if ((A1 & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & A4))
         (A2 => X) = 0;
      if ((~(A1) & A3 & A4))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & A3 & A4))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & A4))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(A4)) | (A1 & ~(A2) & A4))
         (A3 => X) = 0;
      if ((~(A1) & A2 & A4) | (~(A1) & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((A1 & A2 & A4) | (A1 & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((~(A1) & A2 & ~(A4)) | (~(A1) & ~(A2) & A4))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & A3))
         (A4 => X) = 0;
      if ((~(A1) & A2 & A3))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & A2 & A3))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO4_DG_2

//%BEGIN SEH_EO4_DG_3

`celldefine
module SEH_EO4_DG_3 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        xor #1 (X, A1, A2, A3, A4);

   `else
        xor (X, A1, A2, A3, A4);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3 & ~(A4)) | (~(A2) & A3 & A4))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & A4) | (~(A2) & ~(A3) & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & A3 & A4) | (~(A2) & A3 & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & ~(A4)) | (~(A2) & ~(A3) & A4))
         (A1 => X) = 0;
      if ((A1 & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & A4))
         (A2 => X) = 0;
      if ((~(A1) & A3 & A4))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & A3 & A4))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & A4))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(A4)) | (A1 & ~(A2) & A4))
         (A3 => X) = 0;
      if ((~(A1) & A2 & A4) | (~(A1) & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((A1 & A2 & A4) | (A1 & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((~(A1) & A2 & ~(A4)) | (~(A1) & ~(A2) & A4))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & A3))
         (A4 => X) = 0;
      if ((~(A1) & A2 & A3))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & A2 & A3))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO4_DG_3

//%BEGIN SEH_EO4_DG_4

`celldefine
module SEH_EO4_DG_4 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        xor #1 (X, A1, A2, A3, A4);

   `else
        xor (X, A1, A2, A3, A4);

   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & A3 & ~(A4)) | (~(A2) & A3 & A4))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & A4) | (~(A2) & ~(A3) & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & A3 & A4) | (~(A2) & A3 & ~(A4)))
         (A1 => X) = 0;
      if ((A2 & ~(A3) & ~(A4)) | (~(A2) & ~(A3) & A4))
         (A1 => X) = 0;
      if ((A1 & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & A4))
         (A2 => X) = 0;
      if ((~(A1) & A3 & A4))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((A1 & A3 & A4))
         (A2 => X) = 0;
      if ((A1 & ~(A3) & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & A3 & ~(A4)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & A4))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(A4)) | (A1 & ~(A2) & A4))
         (A3 => X) = 0;
      if ((~(A1) & A2 & A4) | (~(A1) & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((A1 & A2 & A4) | (A1 & ~(A2) & ~(A4)))
         (A3 => X) = 0;
      if ((~(A1) & A2 & ~(A4)) | (~(A1) & ~(A2) & A4))
         (A3 => X) = 0;
      if ((A1 & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & A3))
         (A4 => X) = 0;
      if ((~(A1) & A2 & A3))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((A1 & A2 & A3))
         (A4 => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (A4 => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_EO4_DG_4

//%BEGIN SEH_FCMPR42_4

`celldefine
module SEH_FCMPR42_4 (S, C, COUT, I0, I1, I2, I3, CIN);
   output S, C, COUT;
   input I0, I1, I2, I3, CIN;

   wire int_res_0, int_res_1, int_res_2, int_res_3, int_res_4, int_res_5, int_res_6, int_res_7, int_res_8, int_res_9;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, I0, I1);
   and (int_res_1, I2, I3);
   or  (int_res_2, int_res_0, int_res_1);
   not (int_res_3, int_res_2);
   xor (int_res_4, I0, I1, I2, I3);
   not (int_res_5, int_res_4);
   not (int_res_6, CIN);
   and (int_res_7, int_res_6, int_res_4);
   and (int_res_8, int_res_3, int_res_5);
   or  (int_res_9, int_res_7, int_res_8);
   or (int_res_10, I0, I1);
   or (int_res_11, I2, I3);   
      
   `ifdef VIRL_functiononly
      xor #1 (S, I0, I1,  I2, I3, CIN);
      and #1 (COUT, int_res_10, int_res_11);
      not #1 (C,int_res_9);
   `else
      xor (S, I0, I1,  I2, I3, CIN);
      and (COUT, int_res_10, int_res_11);
      not (C,int_res_9);
   `endif
     


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly

   `else


   specify
      if ((I0 & I1 & I2 & ~(I3)) | (I0 & I1 & ~(I2) & I3) | (I0 & ~(I1) & I2 & I3) | (~(I0) & I1 & I2 & I3))
         (CIN => C) = 0;
      if ((I0 & ~(I1) & ~(I2) & ~(I3)) | (~(I0) & I1 & ~(I2) & ~(I3)) | (~(I0) & ~(I1) & I2 & ~(I3)) | (~(I0) & ~(I1) & ~(I2) & I3))
         (CIN => C) = 0;
      if ((CIN & I1 & I2 & ~(I3)))
         (I0 => C) = 0;
      if ((CIN & I1 & ~(I2) & I3))
         (I0 => C) = 0;
      if ((CIN & ~(I1) & ~(I2) & ~(I3)))
         (I0 => C) = 0;
      if ((~(CIN) & I1 & I2 & I3))
         (I0 => C) = 0;
      if ((~(CIN) & I1 & ~(I2) & ~(I3)))
         (I0 => C) = 0;
      if ((CIN & ~(I1) & I2 & ~(I3)))
         (I0 => C) = 0;
      if ((CIN & ~(I1) & ~(I2) & I3))
         (I0 => C) = 0;
      if ((~(CIN) & ~(I1) & I2 & I3))
         (I0 => C) = 0;
      if ((CIN & I0 & I2 & ~(I3)))
         (I1 => C) = 0;
      if ((CIN & I0 & ~(I2) & I3))
         (I1 => C) = 0;
      if ((CIN & ~(I0) & ~(I2) & ~(I3)))
         (I1 => C) = 0;
      if ((~(CIN) & I0 & I2 & I3))
         (I1 => C) = 0;
      if ((~(CIN) & I0 & ~(I2) & ~(I3)))
         (I1 => C) = 0;
      if ((CIN & ~(I0) & I2 & ~(I3)))
         (I1 => C) = 0;
      if ((CIN & ~(I0) & ~(I2) & I3))
         (I1 => C) = 0;
      if ((~(CIN) & ~(I0) & I2 & I3))
         (I1 => C) = 0;
      if ((CIN & I0 & ~(I1) & I3))
         (I2 => C) = 0;
      if ((CIN & ~(I0) & I1 & I3))
         (I2 => C) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I3)))
         (I2 => C) = 0;
      if ((~(CIN) & I0 & I1 & I3))
         (I2 => C) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I3))
         (I2 => C) = 0;
      if ((CIN & I0 & ~(I1) & ~(I3)))
         (I2 => C) = 0;
      if ((CIN & ~(I0) & I1 & ~(I3)))
         (I2 => C) = 0;
      if ((~(CIN) & I0 & I1 & ~(I3)))
         (I2 => C) = 0;
      if ((CIN & I0 & ~(I1) & I2))
         (I3 => C) = 0;
      if ((CIN & ~(I0) & I1 & I2))
         (I3 => C) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I2)))
         (I3 => C) = 0;
      if ((~(CIN) & I0 & I1 & I2))
         (I3 => C) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I2))
         (I3 => C) = 0;
      if ((CIN & I0 & ~(I1) & ~(I2)))
         (I3 => C) = 0;
      if ((CIN & ~(I0) & I1 & ~(I2)))
         (I3 => C) = 0;
      if ((~(CIN) & I0 & I1 & ~(I2)))
         (I3 => C) = 0;
      if ((CIN & ~(I1) & I2 & I3))
         (I0 => COUT) = 0;
      if ((CIN & ~(I1) & I2 & ~(I3)))
         (I0 => COUT) = 0;
      if ((CIN & ~(I1) & ~(I2) & I3))
         (I0 => COUT) = 0;
      if ((~(CIN) & ~(I1) & I2 & I3))
         (I0 => COUT) = 0;
      if ((~(CIN) & ~(I1) & I2 & ~(I3)))
         (I0 => COUT) = 0;
      if ((~(CIN) & ~(I1) & ~(I2) & I3))
         (I0 => COUT) = 0;
      if ((CIN & ~(I0) & I2 & I3))
         (I1 => COUT) = 0;
      if ((CIN & ~(I0) & I2 & ~(I3)))
         (I1 => COUT) = 0;
      if ((CIN & ~(I0) & ~(I2) & I3))
         (I1 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I2 & I3))
         (I1 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I2 & ~(I3)))
         (I1 => COUT) = 0;
      if ((~(CIN) & ~(I0) & ~(I2) & I3))
         (I1 => COUT) = 0;
      if ((CIN & I0 & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((CIN & I0 & ~(I1) & ~(I3)))
         (I2 => COUT) = 0;
      if ((CIN & ~(I0) & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((~(CIN) & I0 & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I3)))
         (I2 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((CIN & I0 & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((CIN & I0 & ~(I1) & ~(I2)))
         (I3 => COUT) = 0;
      if ((CIN & ~(I0) & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((~(CIN) & I0 & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I2)))
         (I3 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((I0 & I1 & I2 & I3) | (I0 & I1 & ~(I2) & ~(I3)) | (~(I0) & ~(I1) & I2 & I3))
         (CIN => S) = 0;
      if ((I0 & ~(I1) & I2 & ~(I3)) | (I0 & ~(I1) & ~(I2) & I3) | (~(I0) & I1 & I2 & ~(I3)) | (~(I0) & I1 & ~(I2) & I3) | (~(I0) & ~(I1) & ~(I2) & ~(I3)))
         (CIN => S) = 0;
      if ((I0 & I1 & I2 & ~(I3)) | (I0 & I1 & ~(I2) & I3) | (I0 & ~(I1) & I2 & I3) | (~(I0) & I1 & I2 & I3))
         (CIN => S) = 0;
      if ((I0 & ~(I1) & ~(I2) & ~(I3)) | (~(I0) & I1 & ~(I2) & ~(I3)) | (~(I0) & ~(I1) & I2 & ~(I3)) | (~(I0) & ~(I1) & ~(I2) & I3))
         (CIN => S) = 0;
      if ((CIN & I1 & I2 & I3))
         (I0 => S) = 0;
      if ((CIN & I1 & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & ~(I2) & I3))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & ~(I2) & I3))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & I2 & I3))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & I1 & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & I1 & ~(I2) & I3))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & I2 & I3))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & I2 & I3))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & ~(I2) & I3))
         (I0 => S) = 0;
      if ((CIN & I0 & I2 & I3))
         (I1 => S) = 0;
      if ((CIN & I0 & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & ~(I2) & I3))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & ~(I2) & I3))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & I2 & I3))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & I0 & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & I0 & ~(I2) & I3))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & I2 & I3))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & I2 & I3))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I2) & I3))
         (I1 => S) = 0;
      if ((CIN & I0 & I1 & I3))
         (I2 => S) = 0;
      if ((CIN & I0 & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & I3))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & I3))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & I3))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & I0 & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & I0 & ~(I1) & I3))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & I1 & I3))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & I1 & I3))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I3))
         (I2 => S) = 0;
      if ((CIN & I0 & I1 & I2))
         (I3 => S) = 0;
      if ((CIN & I0 & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & I2))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & I2))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & I2))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & I0 & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & I0 & ~(I1) & I2))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & I1 & I2))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & I1 & I2))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I2))
         (I3 => S) = 0;
   endspecify

   `endif


endmodule
`endcelldefine

//%END SEH_FCMPR42_4

//%BEGIN SEH_FCMPR42_6

`celldefine
module SEH_FCMPR42_6 (S, C, COUT, I0, I1, I2, I3, CIN);
   output S, C, COUT;
   input I0, I1, I2, I3, CIN;

   wire int_res_0, int_res_1, int_res_2, int_res_3, int_res_4, int_res_5, int_res_6, int_res_7, int_res_8, int_res_9;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, I0, I1);
   and (int_res_1, I2, I3);
   or  (int_res_2, int_res_0, int_res_1);
   not (int_res_3, int_res_2);
   xor (int_res_4, I0, I1, I2, I3);
   not (int_res_5, int_res_4);
   not (int_res_6, CIN);
   and (int_res_7, int_res_6, int_res_4);
   and (int_res_8, int_res_3, int_res_5);
   or  (int_res_9, int_res_7, int_res_8);
   or (int_res_10, I0, I1);
   or (int_res_11, I2, I3);   
      
   `ifdef VIRL_functiononly
      xor #1 (S, I0, I1,  I2, I3, CIN);
      and #1 (COUT, int_res_10, int_res_11);
      not #1 (C,int_res_9);
   `else
      xor (S, I0, I1,  I2, I3, CIN);
      and (COUT, int_res_10, int_res_11);
      not (C,int_res_9);
   `endif
     


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly

   `else


   specify
      if ((I0 & I1 & I2 & ~(I3)) | (I0 & I1 & ~(I2) & I3) | (I0 & ~(I1) & I2 & I3) | (~(I0) & I1 & I2 & I3))
         (CIN => C) = 0;
      if ((I0 & ~(I1) & ~(I2) & ~(I3)) | (~(I0) & I1 & ~(I2) & ~(I3)) | (~(I0) & ~(I1) & I2 & ~(I3)) | (~(I0) & ~(I1) & ~(I2) & I3))
         (CIN => C) = 0;
      if ((CIN & I1 & I2 & ~(I3)))
         (I0 => C) = 0;
      if ((CIN & I1 & ~(I2) & I3))
         (I0 => C) = 0;
      if ((CIN & ~(I1) & ~(I2) & ~(I3)))
         (I0 => C) = 0;
      if ((~(CIN) & I1 & I2 & I3))
         (I0 => C) = 0;
      if ((~(CIN) & I1 & ~(I2) & ~(I3)))
         (I0 => C) = 0;
      if ((CIN & ~(I1) & I2 & ~(I3)))
         (I0 => C) = 0;
      if ((CIN & ~(I1) & ~(I2) & I3))
         (I0 => C) = 0;
      if ((~(CIN) & ~(I1) & I2 & I3))
         (I0 => C) = 0;
      if ((CIN & I0 & I2 & ~(I3)))
         (I1 => C) = 0;
      if ((CIN & I0 & ~(I2) & I3))
         (I1 => C) = 0;
      if ((CIN & ~(I0) & ~(I2) & ~(I3)))
         (I1 => C) = 0;
      if ((~(CIN) & I0 & I2 & I3))
         (I1 => C) = 0;
      if ((~(CIN) & I0 & ~(I2) & ~(I3)))
         (I1 => C) = 0;
      if ((CIN & ~(I0) & I2 & ~(I3)))
         (I1 => C) = 0;
      if ((CIN & ~(I0) & ~(I2) & I3))
         (I1 => C) = 0;
      if ((~(CIN) & ~(I0) & I2 & I3))
         (I1 => C) = 0;
      if ((CIN & I0 & ~(I1) & I3))
         (I2 => C) = 0;
      if ((CIN & ~(I0) & I1 & I3))
         (I2 => C) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I3)))
         (I2 => C) = 0;
      if ((~(CIN) & I0 & I1 & I3))
         (I2 => C) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I3))
         (I2 => C) = 0;
      if ((CIN & I0 & ~(I1) & ~(I3)))
         (I2 => C) = 0;
      if ((CIN & ~(I0) & I1 & ~(I3)))
         (I2 => C) = 0;
      if ((~(CIN) & I0 & I1 & ~(I3)))
         (I2 => C) = 0;
      if ((CIN & I0 & ~(I1) & I2))
         (I3 => C) = 0;
      if ((CIN & ~(I0) & I1 & I2))
         (I3 => C) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I2)))
         (I3 => C) = 0;
      if ((~(CIN) & I0 & I1 & I2))
         (I3 => C) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I2))
         (I3 => C) = 0;
      if ((CIN & I0 & ~(I1) & ~(I2)))
         (I3 => C) = 0;
      if ((CIN & ~(I0) & I1 & ~(I2)))
         (I3 => C) = 0;
      if ((~(CIN) & I0 & I1 & ~(I2)))
         (I3 => C) = 0;
      if ((CIN & ~(I1) & I2 & I3))
         (I0 => COUT) = 0;
      if ((CIN & ~(I1) & I2 & ~(I3)))
         (I0 => COUT) = 0;
      if ((CIN & ~(I1) & ~(I2) & I3))
         (I0 => COUT) = 0;
      if ((~(CIN) & ~(I1) & I2 & I3))
         (I0 => COUT) = 0;
      if ((~(CIN) & ~(I1) & I2 & ~(I3)))
         (I0 => COUT) = 0;
      if ((~(CIN) & ~(I1) & ~(I2) & I3))
         (I0 => COUT) = 0;
      if ((CIN & ~(I0) & I2 & I3))
         (I1 => COUT) = 0;
      if ((CIN & ~(I0) & I2 & ~(I3)))
         (I1 => COUT) = 0;
      if ((CIN & ~(I0) & ~(I2) & I3))
         (I1 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I2 & I3))
         (I1 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I2 & ~(I3)))
         (I1 => COUT) = 0;
      if ((~(CIN) & ~(I0) & ~(I2) & I3))
         (I1 => COUT) = 0;
      if ((CIN & I0 & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((CIN & I0 & ~(I1) & ~(I3)))
         (I2 => COUT) = 0;
      if ((CIN & ~(I0) & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((~(CIN) & I0 & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I3)))
         (I2 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((CIN & I0 & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((CIN & I0 & ~(I1) & ~(I2)))
         (I3 => COUT) = 0;
      if ((CIN & ~(I0) & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((~(CIN) & I0 & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I2)))
         (I3 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((I0 & I1 & I2 & I3) | (I0 & I1 & ~(I2) & ~(I3)) | (~(I0) & ~(I1) & I2 & I3))
         (CIN => S) = 0;
      if ((I0 & ~(I1) & I2 & ~(I3)) | (I0 & ~(I1) & ~(I2) & I3) | (~(I0) & I1 & I2 & ~(I3)) | (~(I0) & I1 & ~(I2) & I3) | (~(I0) & ~(I1) & ~(I2) & ~(I3)))
         (CIN => S) = 0;
      if ((I0 & I1 & I2 & ~(I3)) | (I0 & I1 & ~(I2) & I3) | (I0 & ~(I1) & I2 & I3) | (~(I0) & I1 & I2 & I3))
         (CIN => S) = 0;
      if ((I0 & ~(I1) & ~(I2) & ~(I3)) | (~(I0) & I1 & ~(I2) & ~(I3)) | (~(I0) & ~(I1) & I2 & ~(I3)) | (~(I0) & ~(I1) & ~(I2) & I3))
         (CIN => S) = 0;
      if ((CIN & I1 & I2 & I3))
         (I0 => S) = 0;
      if ((CIN & I1 & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & ~(I2) & I3))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & ~(I2) & I3))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & I2 & I3))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & I1 & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & I1 & ~(I2) & I3))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & I2 & I3))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & I2 & I3))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & ~(I2) & I3))
         (I0 => S) = 0;
      if ((CIN & I0 & I2 & I3))
         (I1 => S) = 0;
      if ((CIN & I0 & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & ~(I2) & I3))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & ~(I2) & I3))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & I2 & I3))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & I0 & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & I0 & ~(I2) & I3))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & I2 & I3))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & I2 & I3))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I2) & I3))
         (I1 => S) = 0;
      if ((CIN & I0 & I1 & I3))
         (I2 => S) = 0;
      if ((CIN & I0 & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & I3))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & I3))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & I3))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & I0 & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & I0 & ~(I1) & I3))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & I1 & I3))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & I1 & I3))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I3))
         (I2 => S) = 0;
      if ((CIN & I0 & I1 & I2))
         (I3 => S) = 0;
      if ((CIN & I0 & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & I2))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & I2))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & I2))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & I0 & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & I0 & ~(I1) & I2))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & I1 & I2))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & I1 & I2))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I2))
         (I3 => S) = 0;
   endspecify

   `endif


endmodule
`endcelldefine

//%END SEH_FCMPR42_6

//%BEGIN SEH_FCMPR42_8

`celldefine
module SEH_FCMPR42_8 (S, C, COUT, I0, I1, I2, I3, CIN);
   output S, C, COUT;
   input I0, I1, I2, I3, CIN;

   wire int_res_0, int_res_1, int_res_2, int_res_3, int_res_4, int_res_5, int_res_6, int_res_7, int_res_8, int_res_9;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, I0, I1);
   and (int_res_1, I2, I3);
   or  (int_res_2, int_res_0, int_res_1);
   not (int_res_3, int_res_2);
   xor (int_res_4, I0, I1, I2, I3);
   not (int_res_5, int_res_4);
   not (int_res_6, CIN);
   and (int_res_7, int_res_6, int_res_4);
   and (int_res_8, int_res_3, int_res_5);
   or  (int_res_9, int_res_7, int_res_8);
   or (int_res_10, I0, I1);
   or (int_res_11, I2, I3);   
      
   `ifdef VIRL_functiononly
      xor #1 (S, I0, I1,  I2, I3, CIN);
      and #1 (COUT, int_res_10, int_res_11);
      not #1 (C,int_res_9);
   `else
      xor (S, I0, I1,  I2, I3, CIN);
      and (COUT, int_res_10, int_res_11);
      not (C,int_res_9);
   `endif
     


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   `ifdef VIRL_functiononly

   `else


   specify
      if ((I0 & I1 & I2 & ~(I3)) | (I0 & I1 & ~(I2) & I3) | (I0 & ~(I1) & I2 & I3) | (~(I0) & I1 & I2 & I3))
         (CIN => C) = 0;
      if ((I0 & ~(I1) & ~(I2) & ~(I3)) | (~(I0) & I1 & ~(I2) & ~(I3)) | (~(I0) & ~(I1) & I2 & ~(I3)) | (~(I0) & ~(I1) & ~(I2) & I3))
         (CIN => C) = 0;
      if ((CIN & I1 & I2 & ~(I3)))
         (I0 => C) = 0;
      if ((CIN & I1 & ~(I2) & I3))
         (I0 => C) = 0;
      if ((CIN & ~(I1) & ~(I2) & ~(I3)))
         (I0 => C) = 0;
      if ((~(CIN) & I1 & I2 & I3))
         (I0 => C) = 0;
      if ((~(CIN) & I1 & ~(I2) & ~(I3)))
         (I0 => C) = 0;
      if ((CIN & ~(I1) & I2 & ~(I3)))
         (I0 => C) = 0;
      if ((CIN & ~(I1) & ~(I2) & I3))
         (I0 => C) = 0;
      if ((~(CIN) & ~(I1) & I2 & I3))
         (I0 => C) = 0;
      if ((CIN & I0 & I2 & ~(I3)))
         (I1 => C) = 0;
      if ((CIN & I0 & ~(I2) & I3))
         (I1 => C) = 0;
      if ((CIN & ~(I0) & ~(I2) & ~(I3)))
         (I1 => C) = 0;
      if ((~(CIN) & I0 & I2 & I3))
         (I1 => C) = 0;
      if ((~(CIN) & I0 & ~(I2) & ~(I3)))
         (I1 => C) = 0;
      if ((CIN & ~(I0) & I2 & ~(I3)))
         (I1 => C) = 0;
      if ((CIN & ~(I0) & ~(I2) & I3))
         (I1 => C) = 0;
      if ((~(CIN) & ~(I0) & I2 & I3))
         (I1 => C) = 0;
      if ((CIN & I0 & ~(I1) & I3))
         (I2 => C) = 0;
      if ((CIN & ~(I0) & I1 & I3))
         (I2 => C) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I3)))
         (I2 => C) = 0;
      if ((~(CIN) & I0 & I1 & I3))
         (I2 => C) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I3))
         (I2 => C) = 0;
      if ((CIN & I0 & ~(I1) & ~(I3)))
         (I2 => C) = 0;
      if ((CIN & ~(I0) & I1 & ~(I3)))
         (I2 => C) = 0;
      if ((~(CIN) & I0 & I1 & ~(I3)))
         (I2 => C) = 0;
      if ((CIN & I0 & ~(I1) & I2))
         (I3 => C) = 0;
      if ((CIN & ~(I0) & I1 & I2))
         (I3 => C) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I2)))
         (I3 => C) = 0;
      if ((~(CIN) & I0 & I1 & I2))
         (I3 => C) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I2))
         (I3 => C) = 0;
      if ((CIN & I0 & ~(I1) & ~(I2)))
         (I3 => C) = 0;
      if ((CIN & ~(I0) & I1 & ~(I2)))
         (I3 => C) = 0;
      if ((~(CIN) & I0 & I1 & ~(I2)))
         (I3 => C) = 0;
      if ((CIN & ~(I1) & I2 & I3))
         (I0 => COUT) = 0;
      if ((CIN & ~(I1) & I2 & ~(I3)))
         (I0 => COUT) = 0;
      if ((CIN & ~(I1) & ~(I2) & I3))
         (I0 => COUT) = 0;
      if ((~(CIN) & ~(I1) & I2 & I3))
         (I0 => COUT) = 0;
      if ((~(CIN) & ~(I1) & I2 & ~(I3)))
         (I0 => COUT) = 0;
      if ((~(CIN) & ~(I1) & ~(I2) & I3))
         (I0 => COUT) = 0;
      if ((CIN & ~(I0) & I2 & I3))
         (I1 => COUT) = 0;
      if ((CIN & ~(I0) & I2 & ~(I3)))
         (I1 => COUT) = 0;
      if ((CIN & ~(I0) & ~(I2) & I3))
         (I1 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I2 & I3))
         (I1 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I2 & ~(I3)))
         (I1 => COUT) = 0;
      if ((~(CIN) & ~(I0) & ~(I2) & I3))
         (I1 => COUT) = 0;
      if ((CIN & I0 & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((CIN & I0 & ~(I1) & ~(I3)))
         (I2 => COUT) = 0;
      if ((CIN & ~(I0) & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((~(CIN) & I0 & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I3)))
         (I2 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I3)))
         (I2 => COUT) = 0;
      if ((CIN & I0 & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((CIN & I0 & ~(I1) & ~(I2)))
         (I3 => COUT) = 0;
      if ((CIN & ~(I0) & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((~(CIN) & I0 & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I2)))
         (I3 => COUT) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I2)))
         (I3 => COUT) = 0;
      if ((I0 & I1 & I2 & I3) | (I0 & I1 & ~(I2) & ~(I3)) | (~(I0) & ~(I1) & I2 & I3))
         (CIN => S) = 0;
      if ((I0 & ~(I1) & I2 & ~(I3)) | (I0 & ~(I1) & ~(I2) & I3) | (~(I0) & I1 & I2 & ~(I3)) | (~(I0) & I1 & ~(I2) & I3) | (~(I0) & ~(I1) & ~(I2) & ~(I3)))
         (CIN => S) = 0;
      if ((I0 & I1 & I2 & ~(I3)) | (I0 & I1 & ~(I2) & I3) | (I0 & ~(I1) & I2 & I3) | (~(I0) & I1 & I2 & I3))
         (CIN => S) = 0;
      if ((I0 & ~(I1) & ~(I2) & ~(I3)) | (~(I0) & I1 & ~(I2) & ~(I3)) | (~(I0) & ~(I1) & I2 & ~(I3)) | (~(I0) & ~(I1) & ~(I2) & I3))
         (CIN => S) = 0;
      if ((CIN & I1 & I2 & I3))
         (I0 => S) = 0;
      if ((CIN & I1 & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & ~(I2) & I3))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & ~(I2) & I3))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & I2 & I3))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & I1 & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((CIN & I1 & ~(I2) & I3))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & I2 & I3))
         (I0 => S) = 0;
      if ((CIN & ~(I1) & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & I2 & I3))
         (I0 => S) = 0;
      if ((~(CIN) & I1 & ~(I2) & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & I2 & ~(I3)))
         (I0 => S) = 0;
      if ((~(CIN) & ~(I1) & ~(I2) & I3))
         (I0 => S) = 0;
      if ((CIN & I0 & I2 & I3))
         (I1 => S) = 0;
      if ((CIN & I0 & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & ~(I2) & I3))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & ~(I2) & I3))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & I2 & I3))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & I0 & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((CIN & I0 & ~(I2) & I3))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & I2 & I3))
         (I1 => S) = 0;
      if ((CIN & ~(I0) & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & I2 & I3))
         (I1 => S) = 0;
      if ((~(CIN) & I0 & ~(I2) & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & I2 & ~(I3)))
         (I1 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I2) & I3))
         (I1 => S) = 0;
      if ((CIN & I0 & I1 & I3))
         (I2 => S) = 0;
      if ((CIN & I0 & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & I3))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & I3))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & I3))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & I0 & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((CIN & I0 & ~(I1) & I3))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & I1 & I3))
         (I2 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & I1 & I3))
         (I2 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I3)))
         (I2 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I3))
         (I2 => S) = 0;
      if ((CIN & I0 & I1 & I2))
         (I3 => S) = 0;
      if ((CIN & I0 & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & I2))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & I2))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & I2))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & I0 & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((CIN & I0 & ~(I1) & I2))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & I1 & I2))
         (I3 => S) = 0;
      if ((CIN & ~(I0) & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & I1 & I2))
         (I3 => S) = 0;
      if ((~(CIN) & I0 & ~(I1) & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & I1 & ~(I2)))
         (I3 => S) = 0;
      if ((~(CIN) & ~(I0) & ~(I1) & I2))
         (I3 => S) = 0;
   endspecify

   `endif


endmodule
`endcelldefine

//%END SEH_FCMPR42_8

//%BEGIN SEH_FDAO22PQ_1

`celldefine
module SEH_FDAO22PQ_1 (Q, CK, A1, A2, B1, B2);
   output Q;
   input CK, A1, A2, B1, B2;

   reg viol_0;
   wire delayed_CK, delayed_A1, delayed_A2,
        delayed_B1, delayed_B2;

   wire int_res__DA, int_res__DB, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////
   `ifdef _fv
      buf (delayed_CK, CK);
      buf (delayed_A1, A1);
      buf (delayed_A2, A2);
      buf (delayed_B1, B1);
      buf (delayed_B2, B2);
   `endif

   and (int_res__DA, delayed_A1, delayed_A2);
   and (int_res__DB, delayed_B1, delayed_B2);
   or (int_res__D, int_res__DA, int_res__DB);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
   `else
        buf (Q, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire A1__bar, A2__bar, B1__bar;
   wire B2__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6;


   // Additional timing gates
   not (B2__bar, B2);
   and (cond0, A2, B1, B2__bar);
   not (B1__bar, B1);
   and (cond1, A2, B1__bar);
   and (cond2, A1, B1, B2__bar);
   and (cond3, A1, B1__bar);
   not (A2__bar, A2);
   and (cond4, A1, A2__bar, B2);
   not (A1__bar, A1);
   and (cond5, A1__bar, A2, B2);
   and (cond6, A1__bar, A2__bar, B2);
   and (cond7, A1, A2__bar, B1);
   and (cond8, A1__bar, A2, B1);
   and (cond9, A1__bar, A2__bar, B1);
   and (int_twire_0, A1, A2);
   and (int_twire_1, A1, A2__bar, B1, B2);
   and (int_twire_2, A1__bar, B1, B2);
   or (cond10, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, A1, A2__bar, B1, B2__bar);
   and (int_twire_4, A1__bar, B1, B2__bar);
   and (int_twire_5, A1, A2__bar, B1__bar);
   and (int_twire_6, A1__bar, B1__bar);
   or (cond11, int_twire_3, int_twire_4, int_twire_5, int_twire_6);

   specify
      (posedge CK => (Q+:((A1 && A2) || (A1 && !(A2) && B1 && B2) || (!(A1) && B1 && B2)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond0, negedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, posedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, negedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, posedge A2 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond2, negedge A2 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond3, posedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond3, negedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, posedge B1 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond4, negedge B1 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond5, posedge B1 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond5, negedge B1 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond6, posedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond6, negedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, posedge B2 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond7, negedge B2 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond8, posedge B2 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond8, negedge B2 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond9, posedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond9, negedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDAO22PQ_1

//%BEGIN SEH_FDNQ_1

`celldefine
module SEH_FDNQ_1 (Q, CK, D);
   output Q;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res__CK, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif

   not (int_res__CK, delayed_CK);
   dff_err (xcr_0, int_res__CK, delayed_D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, int_res__CK, delayed_D, xcr_0);
   `else
        dff (Q, viol_0, int_res__CK, delayed_D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDNQ_1

//%BEGIN SEH_FDNQ_2

`celldefine
module SEH_FDNQ_2 (Q, CK, D);
   output Q;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res__CK, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif

   not (int_res__CK, delayed_CK);
   dff_err (xcr_0, int_res__CK, delayed_D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, int_res__CK, delayed_D, xcr_0);
   `else
        dff (Q, viol_0, int_res__CK, delayed_D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDNQ_2

//%BEGIN SEH_FDNQ_4

`celldefine
module SEH_FDNQ_4 (Q, CK, D);
   output Q;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res__CK, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif

   not (int_res__CK, delayed_CK);
   dff_err (xcr_0, int_res__CK, delayed_D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, int_res__CK, delayed_D, xcr_0);
   `else
        dff (Q, viol_0, int_res__CK, delayed_D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDNQ_4

//%BEGIN SEH_FDNRBQ_1

`celldefine
module SEH_FDNRBQ_1 (Q, CK, D, RD);
   output Q;
   input CK, D, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RD;

   wire int_res__CK, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, int_res__CK, delayed_D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `else
        dff_r (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, D__bar;


   // Additional timing gates
   and (cond0, CK, D);
   not (D__bar, D);
   and (cond1, CK, D__bar);
   not (CK__bar, CK);
   and (cond2, CK__bar, D);
   and (cond3, CK__bar, D__bar);
   and (cond4, D, RD);
   and (cond5, D__bar, RD);

   specify
      if ((CK & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge RD &&& D, negedge CK &&& D, 0, viol_0);
      $hold (negedge CK &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge RD &&& cond2, 0, 0, viol_0);
      $width (negedge RD &&& cond3, 0, 0, viol_0);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDNRBQ_1

//%BEGIN SEH_FDNRBQ_2

`celldefine
module SEH_FDNRBQ_2 (Q, CK, D, RD);
   output Q;
   input CK, D, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RD;

   wire int_res__CK, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, int_res__CK, delayed_D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `else
        dff_r (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, D__bar;


   // Additional timing gates
   and (cond0, CK, D);
   not (D__bar, D);
   and (cond1, CK, D__bar);
   not (CK__bar, CK);
   and (cond2, CK__bar, D);
   and (cond3, CK__bar, D__bar);
   and (cond4, D, RD);
   and (cond5, D__bar, RD);

   specify
      if ((CK & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge RD &&& D, negedge CK &&& D, 0, viol_0);
      $hold (negedge CK &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge RD &&& cond2, 0, 0, viol_0);
      $width (negedge RD &&& cond3, 0, 0, viol_0);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDNRBQ_2

//%BEGIN SEH_FDNRBQ_4

`celldefine
module SEH_FDNRBQ_4 (Q, CK, D, RD);
   output Q;
   input CK, D, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RD;

   wire int_res__CK, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, int_res__CK, delayed_D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `else
        dff_r (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, D__bar;


   // Additional timing gates
   and (cond0, CK, D);
   not (D__bar, D);
   and (cond1, CK, D__bar);
   not (CK__bar, CK);
   and (cond2, CK__bar, D);
   and (cond3, CK__bar, D__bar);
   and (cond4, D, RD);
   and (cond5, D__bar, RD);

   specify
      if ((CK & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge RD &&& D, negedge CK &&& D, 0, viol_0);
      $hold (negedge CK &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge RD &&& cond2, 0, 0, viol_0);
      $width (negedge RD &&& cond3, 0, 0, viol_0);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDNRBQ_4

//%BEGIN SEH_FDNRBQ_V2_1

`celldefine
module SEH_FDNRBQ_V2_1 (Q, CK, D, RD);
   output Q;
   input CK, D, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RD;

   wire int_res__CK, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, int_res__CK, delayed_D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `else
        dff_r (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, D__bar;


   // Additional timing gates
   and (cond0, CK, D);
   not (D__bar, D);
   and (cond1, CK, D__bar);
   and (cond2, D, RD);
   and (cond3, D__bar, RD);

   specify
      if ((CK & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      if (~(CK))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge RD &&& D, negedge CK &&& D, 0, viol_0);
      $hold (negedge CK &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge RD &&& ~CK, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (posedge CK &&& cond3, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDNRBQ_V2_1

//%BEGIN SEH_FDNRBQ_V2_2

`celldefine
module SEH_FDNRBQ_V2_2 (Q, CK, D, RD);
   output Q;
   input CK, D, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RD;

   wire int_res__CK, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, int_res__CK, delayed_D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `else
        dff_r (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, D__bar;


   // Additional timing gates
   and (cond0, CK, D);
   not (D__bar, D);
   and (cond1, CK, D__bar);
   and (cond2, D, RD);
   and (cond3, D__bar, RD);

   specify
      if ((CK & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      if (~(CK))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge RD &&& D, negedge CK &&& D, 0, viol_0);
      $hold (negedge CK &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge RD &&& ~CK, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (posedge CK &&& cond3, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDNRBQ_V2_2

//%BEGIN SEH_FDNRBQ_V2_4

`celldefine
module SEH_FDNRBQ_V2_4 (Q, CK, D, RD);
   output Q;
   input CK, D, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RD;

   wire int_res__CK, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, int_res__CK, delayed_D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `else
        dff_r (Q, viol_0, int_res__CK, delayed_D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, D__bar;


   // Additional timing gates
   and (cond0, CK, D);
   not (D__bar, D);
   and (cond1, CK, D__bar);
   and (cond2, D, RD);
   and (cond3, D__bar, RD);

   specify
      if ((CK & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      if (~(CK))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge RD &&& D, negedge CK &&& D, 0, viol_0);
      $hold (negedge CK &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge RD &&& ~CK, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (posedge CK &&& cond3, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDNRBQ_V2_4

//%BEGIN SEH_FDNRBSBQ_1

`celldefine
module SEH_FDNRBSBQ_1 (Q, CK, D, RD, SD);
   output Q;
   input CK, D, RD, SD;

   reg viol_0;
   wire delayed_D, delayed_CK,
	delayed_RD, delayed_SD;

   wire int_res__CK, int_res__RD, int_res__SD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);
`endif


   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   not (int_res__SD, delayed_SD);
   dff_sr_err (xcr_0, int_res__CK, delayed_D, int_res__SD, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
 
   `ifdef VIRL_functiononly
        dff_sr_0 #1 (Q, viol_0, int_res__CK, delayed_D, int_res__SD, int_res__RD, xcr_0);
    `else
        dff_sr_0 (Q, viol_0, int_res__CK, delayed_D, int_res__SD, int_res__RD, xcr_0);
    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, D__bar;


   // Additional timing gates
   and (cond0, RD, SD);
   and (cond1, D, SD);
   and (cond2, CK, D);
   not (D__bar, D);
   and (cond3, CK, D__bar);
   and (cond4, CK, D, SD);
   and (cond5, CK, D__bar, SD);
   not (CK__bar, CK);
   and (cond6, CK__bar, SD);
   and (cond7, D__bar, RD);
   and (cond8, CK, D, RD);
   and (cond9, CK, D__bar, RD);
   and (cond10, CK__bar, RD);
   and (cond11, D, RD, SD);
   and (cond12, D__bar, RD, SD);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge SD &&& cond2, posedge RD &&& cond2, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond3, posedge RD &&& cond3, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& ~CK, posedge RD &&& ~CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& ~CK, posedge SD &&& ~CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond1, negedge CK &&& cond1, 0, viol_0);
      $hold (negedge CK &&& cond1, posedge RD &&& cond1, 0, viol_0);
      $recovery (posedge SD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge RD &&& cond4, 0, 0, viol_0);
      $width (negedge RD &&& cond5, 0, 0, viol_0);
      $width (negedge RD &&& cond6, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (negedge SD &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
      $width (posedge CK &&& cond12, 0, 0, viol_0);
      $width (negedge CK &&& cond12, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_FDNRBSBQ_1

//%BEGIN SEH_FDNRBSBQ_2

`celldefine
module SEH_FDNRBSBQ_2 (Q, CK, D, RD, SD);
   output Q;
   input CK, D, RD, SD;

   reg viol_0;
   wire delayed_D, delayed_CK,
	delayed_RD, delayed_SD;

   wire int_res__CK, int_res__RD, int_res__SD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);
`endif


   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   not (int_res__SD, delayed_SD);
   dff_sr_err (xcr_0, int_res__CK, delayed_D, int_res__SD, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
 
   `ifdef VIRL_functiononly
        dff_sr_0 #1 (Q, viol_0, int_res__CK, delayed_D, int_res__SD, int_res__RD, xcr_0);
    `else
        dff_sr_0 (Q, viol_0, int_res__CK, delayed_D, int_res__SD, int_res__RD, xcr_0);
    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, D__bar;


   // Additional timing gates
   and (cond0, RD, SD);
   and (cond1, D, SD);
   and (cond2, CK, D);
   not (D__bar, D);
   and (cond3, CK, D__bar);
   and (cond4, CK, D, SD);
   and (cond5, CK, D__bar, SD);
   not (CK__bar, CK);
   and (cond6, CK__bar, SD);
   and (cond7, D__bar, RD);
   and (cond8, CK, D, RD);
   and (cond9, CK, D__bar, RD);
   and (cond10, CK__bar, RD);
   and (cond11, D, RD, SD);
   and (cond12, D__bar, RD, SD);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge SD &&& cond2, posedge RD &&& cond2, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond3, posedge RD &&& cond3, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& ~CK, posedge RD &&& ~CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& ~CK, posedge SD &&& ~CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond1, negedge CK &&& cond1, 0, viol_0);
      $hold (negedge CK &&& cond1, posedge RD &&& cond1, 0, viol_0);
      $recovery (posedge SD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge RD &&& cond4, 0, 0, viol_0);
      $width (negedge RD &&& cond5, 0, 0, viol_0);
      $width (negedge RD &&& cond6, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (negedge SD &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
      $width (posedge CK &&& cond12, 0, 0, viol_0);
      $width (negedge CK &&& cond12, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_FDNRBSBQ_2

//%BEGIN SEH_FDNRBSBQ_4

`celldefine
module SEH_FDNRBSBQ_4 (Q, CK, D, RD, SD);
   output Q;
   input CK, D, RD, SD;

   reg viol_0;
   wire delayed_D, delayed_CK,
	delayed_RD, delayed_SD;

   wire int_res__CK, int_res__RD, int_res__SD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);
`endif


   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   not (int_res__SD, delayed_SD);
   dff_sr_err (xcr_0, int_res__CK, delayed_D, int_res__SD, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
 
   `ifdef VIRL_functiononly
        dff_sr_0 #1 (Q, viol_0, int_res__CK, delayed_D, int_res__SD, int_res__RD, xcr_0);
    `else
        dff_sr_0 (Q, viol_0, int_res__CK, delayed_D, int_res__SD, int_res__RD, xcr_0);
    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, D__bar;


   // Additional timing gates
   and (cond0, RD, SD);
   and (cond1, D, SD);
   and (cond2, CK, D);
   not (D__bar, D);
   and (cond3, CK, D__bar);
   and (cond4, CK, D, SD);
   and (cond5, CK, D__bar, SD);
   not (CK__bar, CK);
   and (cond6, CK__bar, SD);
   and (cond7, D__bar, RD);
   and (cond8, CK, D, RD);
   and (cond9, CK, D__bar, RD);
   and (cond10, CK__bar, RD);
   and (cond11, D, RD, SD);
   and (cond12, D__bar, RD, SD);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      (negedge CK => (Q+:D)) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge SD &&& cond2, posedge RD &&& cond2, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond3, posedge RD &&& cond3, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& ~CK, posedge RD &&& ~CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& ~CK, posedge SD &&& ~CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond1, negedge CK &&& cond1, 0, viol_0);
      $hold (negedge CK &&& cond1, posedge RD &&& cond1, 0, viol_0);
      $recovery (posedge SD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge RD &&& cond4, 0, 0, viol_0);
      $width (negedge RD &&& cond5, 0, 0, viol_0);
      $width (negedge RD &&& cond6, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (negedge SD &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
      $width (posedge CK &&& cond12, 0, 0, viol_0);
      $width (negedge CK &&& cond12, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_FDNRBSBQ_4

//%BEGIN SEH_FDPCBQ_1

`celldefine
module SEH_FDPCBQ_1 (Q, CK, D, RS);
   output Q;
   input CK, D, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RS;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_RS, RS);
`endif


   and (int_res__D, delayed_D, delayed_RS);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
       dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, D__bar;
   wire int_twire_0, RS__bar;


   // Additional timing gates
   and (cond0, D, RS);
   not (D__bar, D);
   not (RS__bar, RS);
   and (int_twire_0, D, RS__bar);
   or (cond1, int_twire_0, D__bar);

   specify
      (posedge CK => (Q+:((D && RS)))) = 1;
      $setuphold (posedge CK &&& RS, posedge D &&& RS, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& RS, negedge D &&& RS, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& D, posedge RS &&& D, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& D, negedge RS &&& D, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPCBQ_1

//%BEGIN SEH_FDPCBQ_2

`celldefine
module SEH_FDPCBQ_2 (Q, CK, D, RS);
   output Q;
   input CK, D, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RS;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_RS, RS);
`endif


   and (int_res__D, delayed_D, delayed_RS);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
       dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, D__bar;
   wire int_twire_0, RS__bar;


   // Additional timing gates
   and (cond0, D, RS);
   not (D__bar, D);
   not (RS__bar, RS);
   and (int_twire_0, D, RS__bar);
   or (cond1, int_twire_0, D__bar);

   specify
      (posedge CK => (Q+:((D && RS)))) = 1;
      $setuphold (posedge CK &&& RS, posedge D &&& RS, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& RS, negedge D &&& RS, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& D, posedge RS &&& D, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& D, negedge RS &&& D, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPCBQ_2

//%BEGIN SEH_FDPCBQ_4

`celldefine
module SEH_FDPCBQ_4 (Q, CK, D, RS);
   output Q;
   input CK, D, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RS;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_RS, RS);
`endif


   and (int_res__D, delayed_D, delayed_RS);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
       dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, D__bar;
   wire int_twire_0, RS__bar;


   // Additional timing gates
   and (cond0, D, RS);
   not (D__bar, D);
   not (RS__bar, RS);
   and (int_twire_0, D, RS__bar);
   or (cond1, int_twire_0, D__bar);

   specify
      (posedge CK => (Q+:((D && RS)))) = 1;
      $setuphold (posedge CK &&& RS, posedge D &&& RS, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& RS, negedge D &&& RS, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& D, posedge RS &&& D, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& D, negedge RS &&& D, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPCBQ_4

//%BEGIN SEH_FDPHQ_1

`celldefine
module SEH_FDPHQ_1 (Q, CK, D, EN);
   output Q;
   input CK, D, EN;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_EN;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_EN, EN);
`endif


   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

       buf #1 (Q, int_res_iq);

   `else
       buf (Q, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, D__bar;
   wire EN__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (cond0, D, EN__bar);
   not (D__bar, D);
   and (cond1, D__bar, EN__bar);

   specify
      (posedge CK => (Q+:((EN && Q) || (!(EN) && D)))) = 1;
      $setuphold (posedge CK &&& ~EN, posedge D &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~EN, negedge D &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& D, posedge EN &&& D, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& D, negedge EN &&& D, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~D, posedge EN &&& ~D, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~D, negedge EN &&& ~D, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPHQ_1

//%BEGIN SEH_FDPHQ_2

`celldefine
module SEH_FDPHQ_2 (Q, CK, D, EN);
   output Q;
   input CK, D, EN;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_EN;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_EN, EN);
`endif


   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

       buf #1 (Q, int_res_iq);

   `else
       buf (Q, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, D__bar;
   wire EN__bar;


   // Additional timing gates
   not (EN__bar, EN);
   and (cond0, D, EN__bar);
   not (D__bar, D);
   and (cond1, D__bar, EN__bar);

   specify
      (posedge CK => (Q+:((EN && Q) || (!(EN) && D)))) = 1;
      $setuphold (posedge CK &&& ~EN, posedge D &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~EN, negedge D &&& ~EN, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& D, posedge EN &&& D, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& D, negedge EN &&& D, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~D, posedge EN &&& ~D, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& ~D, negedge EN &&& ~D, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPHQ_2

//%BEGIN SEH_FDPHRBSBQ_1

`celldefine
module SEH_FDPHRBSBQ_1 (Q, CK, D, EN, RD, SD);
   output Q;
   input CK, D, EN, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_EN, delayed_RD,
        delayed_SD;
   wire int_res__D, int_res__RD, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_EN, EN);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);


   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   not (int_res__RD, delayed_RD);
   not (int_res__SD, delayed_SD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

        buf #1 (Q, int_res_iq);

   `else

        buf (Q, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, cond27, D__bar;
   wire EN__bar, int_twire_0, int_twire_1;


   // Additional timing gates
   not (EN__bar, EN);
   and (cond0, EN__bar, RD, SD);
   and (cond1, D, RD, SD);
   not (D__bar, D);
   and (cond2, D__bar, RD, SD);
   and (cond3, D, EN__bar, SD);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, D);
   and (int_twire_1, CK__bar, D__bar, EN);
   or (cond4, int_twire_0, int_twire_1);
   and (cond5, CK__bar, D__bar, EN__bar);
   and (cond6, CK, D, EN, SD);
   and (cond7, CK, EN__bar, SD);
   and (cond8, CK, D__bar, EN, SD);
   and (cond9, CK__bar, D, EN, SD);
   and (cond10, CK__bar, D, EN__bar, SD);
   and (cond11, CK__bar, D__bar, EN, SD);
   and (cond12, CK__bar, D__bar, EN__bar, SD);
   and (cond13, D__bar, EN__bar, RD);
   and (cond14, CK, D, EN);
   and (cond15, CK, EN__bar);
   and (cond16, CK, D__bar, EN);
   and (cond17, CK__bar, D, EN);
   and (cond18, CK__bar, D__bar, EN);
   and (cond19, CK, D, EN, RD);
   and (cond20, CK, EN__bar, RD);
   and (cond21, CK, D__bar, EN, RD);
   and (cond22, CK__bar, D, EN, RD);
   and (cond23, CK__bar, D, EN__bar, RD);
   and (cond24, CK__bar, D__bar, EN, RD);
   and (cond25, CK__bar, D__bar, EN__bar, RD);
   and (cond26, D, EN__bar, RD, SD);
   and (cond27, D__bar, EN__bar, RD, SD);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(EN) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & ~(EN) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((EN && Q) || (!(EN) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond4, posedge RD &&& cond4, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond5, posedge RD &&& cond5, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& cond14, posedge SD &&& cond14, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond15, posedge SD &&& cond15, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond16, posedge SD &&& cond16, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond17, posedge SD &&& cond17, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond18, posedge SD &&& cond18, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond3, posedge CK &&& cond3, 0, viol_0);
      $hold (posedge CK &&& cond3, posedge RD &&& cond3, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $width (negedge RD &&& cond6, 0, 0, viol_0);
      $width (negedge RD &&& cond7, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond19, 0, 0, viol_0);
      $width (negedge SD &&& cond20, 0, 0, viol_0);
      $width (negedge SD &&& cond21, 0, 0, viol_0);
      $width (negedge SD &&& cond22, 0, 0, viol_0);
      $width (negedge SD &&& cond23, 0, 0, viol_0);
      $width (negedge SD &&& cond24, 0, 0, viol_0);
      $width (negedge SD &&& cond25, 0, 0, viol_0);
      $width (posedge CK &&& cond26, 0, 0, viol_0);
      $width (negedge CK &&& cond26, 0, 0, viol_0);
      $width (posedge CK &&& cond27, 0, 0, viol_0);
      $width (negedge CK &&& cond27, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPHRBSBQ_1

//%BEGIN SEH_FDPHRBSBQ_2

`celldefine
module SEH_FDPHRBSBQ_2 (Q, CK, D, EN, RD, SD);
   output Q;
   input CK, D, EN, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_EN, delayed_RD,
        delayed_SD;
   wire int_res__D, int_res__RD, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_EN, EN);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);


   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   not (int_res__RD, delayed_RD);
   not (int_res__SD, delayed_SD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly

        buf #1 (Q, int_res_iq);

   `else

        buf (Q, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, cond27, D__bar;
   wire EN__bar, int_twire_0, int_twire_1;


   // Additional timing gates
   not (EN__bar, EN);
   and (cond0, EN__bar, RD, SD);
   and (cond1, D, RD, SD);
   not (D__bar, D);
   and (cond2, D__bar, RD, SD);
   and (cond3, D, EN__bar, SD);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, D);
   and (int_twire_1, CK__bar, D__bar, EN);
   or (cond4, int_twire_0, int_twire_1);
   and (cond5, CK__bar, D__bar, EN__bar);
   and (cond6, CK, D, EN, SD);
   and (cond7, CK, EN__bar, SD);
   and (cond8, CK, D__bar, EN, SD);
   and (cond9, CK__bar, D, EN, SD);
   and (cond10, CK__bar, D, EN__bar, SD);
   and (cond11, CK__bar, D__bar, EN, SD);
   and (cond12, CK__bar, D__bar, EN__bar, SD);
   and (cond13, D__bar, EN__bar, RD);
   and (cond14, CK, D, EN);
   and (cond15, CK, EN__bar);
   and (cond16, CK, D__bar, EN);
   and (cond17, CK__bar, D, EN);
   and (cond18, CK__bar, D__bar, EN);
   and (cond19, CK, D, EN, RD);
   and (cond20, CK, EN__bar, RD);
   and (cond21, CK, D__bar, EN, RD);
   and (cond22, CK__bar, D, EN, RD);
   and (cond23, CK__bar, D, EN__bar, RD);
   and (cond24, CK__bar, D__bar, EN, RD);
   and (cond25, CK__bar, D__bar, EN__bar, RD);
   and (cond26, D, EN__bar, RD, SD);
   and (cond27, D__bar, EN__bar, RD, SD);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(EN) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & ~(EN) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((EN && Q) || (!(EN) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond4, posedge RD &&& cond4, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond5, posedge RD &&& cond5, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& cond14, posedge SD &&& cond14, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond15, posedge SD &&& cond15, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond16, posedge SD &&& cond16, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond17, posedge SD &&& cond17, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond18, posedge SD &&& cond18, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond3, posedge CK &&& cond3, 0, viol_0);
      $hold (posedge CK &&& cond3, posedge RD &&& cond3, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $width (negedge RD &&& cond6, 0, 0, viol_0);
      $width (negedge RD &&& cond7, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond19, 0, 0, viol_0);
      $width (negedge SD &&& cond20, 0, 0, viol_0);
      $width (negedge SD &&& cond21, 0, 0, viol_0);
      $width (negedge SD &&& cond22, 0, 0, viol_0);
      $width (negedge SD &&& cond23, 0, 0, viol_0);
      $width (negedge SD &&& cond24, 0, 0, viol_0);
      $width (negedge SD &&& cond25, 0, 0, viol_0);
      $width (posedge CK &&& cond26, 0, 0, viol_0);
      $width (negedge CK &&& cond26, 0, 0, viol_0);
      $width (posedge CK &&& cond27, 0, 0, viol_0);
      $width (negedge CK &&& cond27, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPHRBSBQ_2

//%BEGIN SEH_FDPMQ_1

`celldefine
module SEH_FDPMQ_1 (Q, CK, D0, D1, S);
   output Q;
   input CK, D0, D1, S;

   reg viol_0;
   wire delayed_CK, delayed_D0, delayed_D1, delayed_S;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D0, D0);
   buf (delayed_D1, D1);
   buf (delayed_S, S);
`endif


   mux2 (int_res__D, delayed_D1, delayed_D0, delayed_S);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
         dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, D0__bar;
   wire D1__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, S__bar;


   // Additional timing gates
   not (S__bar, S);
   and (cond0, D1, S__bar);
   not (D1__bar, D1);
   and (cond1, D1__bar, S__bar);
   and (cond2, D0, S);
   not (D0__bar, D0);
   and (cond3, D0__bar, S);
   and (cond4, D0__bar, D1);
   and (cond5, D0, D1__bar);
   and (int_twire_0, D0, D1);
   and (int_twire_1, D0, D1__bar, S__bar);
   and (int_twire_2, D0__bar, D1, S);
   or (cond6, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D0, D1__bar, S);
   and (int_twire_4, D0__bar, D1, S__bar);
   and (int_twire_5, D0__bar, D1__bar);
   or (cond7, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((D0 && D1) || (D0 && !(D1) && !(S)) || (!(D0) && D1 && S)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond0, negedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, posedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, negedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond2, posedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond2, negedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, posedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, negedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond4, posedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond4, negedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, posedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, negedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $width (posedge CK &&& cond6, 0, 0, viol_0);
      $width (negedge CK &&& cond6, 0, 0, viol_0);
      $width (posedge CK &&& cond7, 0, 0, viol_0);
      $width (negedge CK &&& cond7, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPMQ_1

//%BEGIN SEH_FDPQB_1

`celldefine
module SEH_FDPQB_1 (QN, CK, D);
   output QN;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);
   dff (int_res_iq, viol_0, delayed_CK, delayed_D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (posedge CK => (QN+:!D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQB_1

//%BEGIN SEH_FDPQB_1P5

`celldefine
module SEH_FDPQB_1P5 (QN, CK, D);
   output QN;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);
   dff (int_res_iq, viol_0, delayed_CK, delayed_D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (posedge CK => (QN+:!D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQB_1P5

//%BEGIN SEH_FDPQB_2

`celldefine
module SEH_FDPQB_2 (QN, CK, D);
   output QN;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);
   dff (int_res_iq, viol_0, delayed_CK, delayed_D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (posedge CK => (QN+:!D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQB_2

//%BEGIN SEH_FDPQB_3

`celldefine
module SEH_FDPQB_3 (QN, CK, D);
   output QN;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);
   dff (int_res_iq, viol_0, delayed_CK, delayed_D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (posedge CK => (QN+:!D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQB_3

//%BEGIN SEH_FDPQB_4

`celldefine
module SEH_FDPQB_4 (QN, CK, D);
   output QN;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);
   dff (int_res_iq, viol_0, delayed_CK, delayed_D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (posedge CK => (QN+:!D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQB_4

//%BEGIN SEH_FDPQB_V2_1

`celldefine
module SEH_FDPQB_V2_1 (QN, CK, D);
   output QN;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);
   dff (int_res_iq, viol_0, delayed_CK, delayed_D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (posedge CK => (QN+:!D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQB_V2_1

//%BEGIN SEH_FDPQB_V2_1P5

`celldefine
module SEH_FDPQB_V2_1P5 (QN, CK, D);
   output QN;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);
   dff (int_res_iq, viol_0, delayed_CK, delayed_D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (posedge CK => (QN+:!D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQB_V2_1P5

//%BEGIN SEH_FDPQB_V2_2

`celldefine
module SEH_FDPQB_V2_2 (QN, CK, D);
   output QN;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);
   dff (int_res_iq, viol_0, delayed_CK, delayed_D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (posedge CK => (QN+:!D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQB_V2_2

//%BEGIN SEH_FDPQB_V2_3

`celldefine
module SEH_FDPQB_V2_3 (QN, CK, D);
   output QN;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);
   dff (int_res_iq, viol_0, delayed_CK, delayed_D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (posedge CK => (QN+:!D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQB_V2_3

//%BEGIN SEH_FDPQB_V2_4

`celldefine
module SEH_FDPQB_V2_4 (QN, CK, D);
   output QN;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);
   dff (int_res_iq, viol_0, delayed_CK, delayed_D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (posedge CK => (QN+:!D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQB_V2_4

//%BEGIN SEH_FDPQ_1

`celldefine
module SEH_FDPQ_1 (Q, CK, D);
   output Q;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////




   specify
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQ_1

//%BEGIN SEH_FDPQ_2

`celldefine
module SEH_FDPQ_2 (Q, CK, D);
   output Q;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////




   specify
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQ_2

//%BEGIN SEH_FDPQ_4

`celldefine
module SEH_FDPQ_4 (Q, CK, D);
   output Q;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////




   specify
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQ_4

//%BEGIN SEH_FDPQ_V2_1

`celldefine
module SEH_FDPQ_V2_1 (Q, CK, D);
   output Q;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////




   specify
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQ_V2_1

//%BEGIN SEH_FDPQ_V2_1P5

`celldefine
module SEH_FDPQ_V2_1P5 (Q, CK, D);
   output Q;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////




   specify
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQ_V2_1P5

//%BEGIN SEH_FDPQ_V2_2

`celldefine
module SEH_FDPQ_V2_2 (Q, CK, D);
   output Q;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////




   specify
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQ_V2_2

//%BEGIN SEH_FDPQ_V2_3

`celldefine
module SEH_FDPQ_V2_3 (Q, CK, D);
   output Q;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////




   specify
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQ_V2_3

//%BEGIN SEH_FDPQ_V2_4

`celldefine
module SEH_FDPQ_V2_4 (Q, CK, D);
   output Q;
   input CK, D;

   reg viol_0;
   wire delayed_CK, delayed_D;

   wire xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif


   dff_err (xcr_0, delayed_CK, delayed_D);

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, delayed_D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////




   specify
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK, posedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK, negedge D, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $width (posedge CK &&& D, 0, 0, viol_0);
      $width (negedge CK &&& D, 0, 0, viol_0);
      $width (posedge CK &&& ~D, 0, 0, viol_0);
      $width (negedge CK &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPQ_V2_4

//%BEGIN SEH_FDPRBQ_1

`celldefine
module SEH_FDPRBQ_1 (Q, CK, D, RD);
   output Q;
   input CK, D, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RD;

   wire int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

  
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, delayed_D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         dff_r #1 (Q, viol_0, delayed_CK, delayed_D, int_res__RD, xcr_0);
   `else
         dff_r (Q, viol_0, delayed_CK, delayed_D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, D__bar;


   // Additional timing gates
   and (cond0, CK, D);
   not (D__bar, D);
   and (cond1, CK, D__bar);
   not (CK__bar, CK);
   and (cond2, CK__bar, D);
   and (cond3, CK__bar, D__bar);
   and (cond4, D, RD);
   and (cond5, D__bar, RD);

   specify
      if ((CK & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge RD &&& D, posedge CK &&& D, 0, viol_0);
      $hold (posedge CK &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge RD &&& cond2, 0, 0, viol_0);
      $width (negedge RD &&& cond3, 0, 0, viol_0);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPRBQ_1

//%BEGIN SEH_FDPRBQ_2

`celldefine
module SEH_FDPRBQ_2 (Q, CK, D, RD);
   output Q;
   input CK, D, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RD;

   wire int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

  
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, delayed_D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         dff_r #1 (Q, viol_0, delayed_CK, delayed_D, int_res__RD, xcr_0);
   `else
         dff_r (Q, viol_0, delayed_CK, delayed_D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, D__bar;


   // Additional timing gates
   and (cond0, CK, D);
   not (D__bar, D);
   and (cond1, CK, D__bar);
   not (CK__bar, CK);
   and (cond2, CK__bar, D);
   and (cond3, CK__bar, D__bar);
   and (cond4, D, RD);
   and (cond5, D__bar, RD);

   specify
      if ((CK & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge RD &&& D, posedge CK &&& D, 0, viol_0);
      $hold (posedge CK &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge RD &&& cond2, 0, 0, viol_0);
      $width (negedge RD &&& cond3, 0, 0, viol_0);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPRBQ_2

//%BEGIN SEH_FDPRBQ_4

`celldefine
module SEH_FDPRBQ_4 (Q, CK, D, RD);
   output Q;
   input CK, D, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RD;

   wire int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

  
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, delayed_D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         dff_r #1 (Q, viol_0, delayed_CK, delayed_D, int_res__RD, xcr_0);
   `else
         dff_r (Q, viol_0, delayed_CK, delayed_D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, D__bar;


   // Additional timing gates
   and (cond0, CK, D);
   not (D__bar, D);
   and (cond1, CK, D__bar);
   not (CK__bar, CK);
   and (cond2, CK__bar, D);
   and (cond3, CK__bar, D__bar);
   and (cond4, D, RD);
   and (cond5, D__bar, RD);

   specify
      if ((CK & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge RD &&& D, posedge CK &&& D, 0, viol_0);
      $hold (posedge CK &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge RD &&& cond2, 0, 0, viol_0);
      $width (negedge RD &&& cond3, 0, 0, viol_0);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPRBQ_4

//%BEGIN SEH_FDPRBQ_V2_1P5

`celldefine
module SEH_FDPRBQ_V2_1P5 (Q, CK, D, RD);
   output Q;
   input CK, D, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RD;

   wire int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

  
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, delayed_D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         dff_r #1 (Q, viol_0, delayed_CK, delayed_D, int_res__RD, xcr_0);
   `else
         dff_r (Q, viol_0, delayed_CK, delayed_D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, D__bar;


   // Additional timing gates
   not (CK__bar, CK);
   and (cond0, CK__bar, D);
   not (D__bar, D);
   and (cond1, CK__bar, D__bar);
   and (cond2, D, RD);
   and (cond3, D__bar, RD);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge RD &&& D, posedge CK &&& D, 0, viol_0);
      $hold (posedge CK &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (posedge CK &&& cond3, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPRBQ_V2_1P5

//%BEGIN SEH_FDPRBQ_V2_3

`celldefine
module SEH_FDPRBQ_V2_3 (Q, CK, D, RD);
   output Q;
   input CK, D, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_RD;

   wire int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

  
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, delayed_D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         dff_r #1 (Q, viol_0, delayed_CK, delayed_D, int_res__RD, xcr_0);
   `else
         dff_r (Q, viol_0, delayed_CK, delayed_D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, D__bar;


   // Additional timing gates
   not (CK__bar, CK);
   and (cond0, CK__bar, D);
   not (D__bar, D);
   and (cond1, CK__bar, D__bar);
   and (cond2, D, RD);
   and (cond3, D__bar, RD);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge RD &&& D, posedge CK &&& D, 0, viol_0);
      $hold (posedge CK &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (posedge CK &&& cond3, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPRBQ_V2_3

//%BEGIN SEH_FDPRBSBQ_1

`celldefine
module SEH_FDPRBSBQ_1 (Q, CK, D, RD, SD);
   output Q;
   input CK, D, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_RD, delayed_SD;

   wire int_res__SD, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_D, D);
   buf (delayed_CK, CK);
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);
`endif


   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, delayed_D, int_res__SD, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_sr_0 #1 (Q, viol_0, delayed_CK, delayed_D, int_res__SD, int_res__RD, xcr_0);
   `else
        dff_sr_0 (Q, viol_0, delayed_CK, delayed_D, int_res__SD, int_res__RD, xcr_0); 

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, D__bar;


   // Additional timing gates
   and (cond0, RD, SD);
   and (cond1, D, SD);
   not (CK__bar, CK);
   and (cond2, CK__bar, D);
   not (D__bar, D);
   and (cond3, CK__bar, D__bar);
   and (cond4, CK, SD);
   and (cond5, CK__bar, D, SD);
   and (cond6, CK__bar, D__bar, SD);
   and (cond7, D__bar, RD);
   and (cond8, CK, RD);
   and (cond9, CK__bar, D, RD);
   and (cond10, CK__bar, D__bar, RD);
   and (cond11, D, RD, SD);
   and (cond12, D__bar, RD, SD);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond2, posedge RD &&& cond2, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond3, posedge RD &&& cond3, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond1, posedge CK &&& cond1, 0, viol_0);
      $hold (posedge CK &&& cond1, posedge RD &&& cond1, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge RD &&& cond4, 0, 0, viol_0);
      $width (negedge RD &&& cond5, 0, 0, viol_0);
      $width (negedge RD &&& cond6, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (negedge SD &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
      $width (posedge CK &&& cond12, 0, 0, viol_0);
      $width (negedge CK &&& cond12, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPRBSBQ_1

//%BEGIN SEH_FDPRBSBQ_2

`celldefine
module SEH_FDPRBSBQ_2 (Q, CK, D, RD, SD);
   output Q;
   input CK, D, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_RD, delayed_SD;

   wire int_res__SD, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_D, D);
   buf (delayed_CK, CK);
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);
`endif


   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, delayed_D, int_res__SD, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_sr_0 #1 (Q, viol_0, delayed_CK, delayed_D, int_res__SD, int_res__RD, xcr_0);
   `else
        dff_sr_0 (Q, viol_0, delayed_CK, delayed_D, int_res__SD, int_res__RD, xcr_0); 

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, D__bar;


   // Additional timing gates
   and (cond0, RD, SD);
   and (cond1, D, SD);
   not (CK__bar, CK);
   and (cond2, CK__bar, D);
   not (D__bar, D);
   and (cond3, CK__bar, D__bar);
   and (cond4, CK, SD);
   and (cond5, CK__bar, D, SD);
   and (cond6, CK__bar, D__bar, SD);
   and (cond7, D__bar, RD);
   and (cond8, CK, RD);
   and (cond9, CK__bar, D, RD);
   and (cond10, CK__bar, D__bar, RD);
   and (cond11, D, RD, SD);
   and (cond12, D__bar, RD, SD);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond2, posedge RD &&& cond2, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond3, posedge RD &&& cond3, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond1, posedge CK &&& cond1, 0, viol_0);
      $hold (posedge CK &&& cond1, posedge RD &&& cond1, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge RD &&& cond4, 0, 0, viol_0);
      $width (negedge RD &&& cond5, 0, 0, viol_0);
      $width (negedge RD &&& cond6, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (negedge SD &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
      $width (posedge CK &&& cond12, 0, 0, viol_0);
      $width (negedge CK &&& cond12, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPRBSBQ_2

//%BEGIN SEH_FDPRBSBQ_4

`celldefine
module SEH_FDPRBSBQ_4 (Q, CK, D, RD, SD);
   output Q;
   input CK, D, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_RD, delayed_SD;

   wire int_res__SD, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_D, D);
   buf (delayed_CK, CK);
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);
`endif


   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, delayed_D, int_res__SD, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_sr_0 #1 (Q, viol_0, delayed_CK, delayed_D, int_res__SD, int_res__RD, xcr_0);
   `else
        dff_sr_0 (Q, viol_0, delayed_CK, delayed_D, int_res__SD, int_res__RD, xcr_0); 

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, D__bar;


   // Additional timing gates
   and (cond0, RD, SD);
   and (cond1, D, SD);
   not (CK__bar, CK);
   and (cond2, CK__bar, D);
   not (D__bar, D);
   and (cond3, CK__bar, D__bar);
   and (cond4, CK, SD);
   and (cond5, CK__bar, D, SD);
   and (cond6, CK__bar, D__bar, SD);
   and (cond7, D__bar, RD);
   and (cond8, CK, RD);
   and (cond9, CK__bar, D, RD);
   and (cond10, CK__bar, D__bar, RD);
   and (cond11, D, RD, SD);
   and (cond12, D__bar, RD, SD);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond2, posedge RD &&& cond2, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond3, posedge RD &&& cond3, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond1, posedge CK &&& cond1, 0, viol_0);
      $hold (posedge CK &&& cond1, posedge RD &&& cond1, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge RD &&& cond4, 0, 0, viol_0);
      $width (negedge RD &&& cond5, 0, 0, viol_0);
      $width (negedge RD &&& cond6, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (negedge SD &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
      $width (posedge CK &&& cond12, 0, 0, viol_0);
      $width (negedge CK &&& cond12, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPRBSBQ_4

//%BEGIN SEH_FDPSBQ_1

`celldefine
module SEH_FDPSBQ_1 (Q, CK, D, SD);
   output Q;
   input CK, D, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SD;

   wire int_res__SD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_SD, SD);


   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, delayed_D, int_res__SD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
      dff_s #1 (Q, viol_0, delayed_CK, delayed_D, int_res__SD, xcr_0);

  `else
      dff_s (Q, viol_0, delayed_CK, delayed_D, int_res__SD, xcr_0);

  `endif

  `ifdef VIRL_functiononly

  `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, D__bar;


   // Additional timing gates
   not (CK__bar, CK);
   and (cond0, CK__bar, D);
   not (D__bar, D);
   and (cond1, CK__bar, D__bar);
   and (cond2, D, SD);
   and (cond3, D__bar, SD);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK &&& SD, posedge D &&& SD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& SD, negedge D &&& SD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge SD &&& ~D, posedge CK &&& ~D, 0, viol_0);
      $hold (posedge CK &&& ~D, posedge SD &&& ~D, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond0, 0, 0, viol_0);
      $width (negedge SD &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (posedge CK &&& cond3, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPSBQ_1

//%BEGIN SEH_FDPSBQ_2

`celldefine
module SEH_FDPSBQ_2 (Q, CK, D, SD);
   output Q;
   input CK, D, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SD;

   wire int_res__SD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_SD, SD);


   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, delayed_D, int_res__SD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
      dff_s #1 (Q, viol_0, delayed_CK, delayed_D, int_res__SD, xcr_0);

  `else
      dff_s (Q, viol_0, delayed_CK, delayed_D, int_res__SD, xcr_0);

  `endif

  `ifdef VIRL_functiononly

  `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, D__bar;


   // Additional timing gates
   not (CK__bar, CK);
   and (cond0, CK__bar, D);
   not (D__bar, D);
   and (cond1, CK__bar, D__bar);
   and (cond2, D, SD);
   and (cond3, D__bar, SD);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK &&& SD, posedge D &&& SD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& SD, negedge D &&& SD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge SD &&& ~D, posedge CK &&& ~D, 0, viol_0);
      $hold (posedge CK &&& ~D, posedge SD &&& ~D, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond0, 0, 0, viol_0);
      $width (negedge SD &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (posedge CK &&& cond3, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPSBQ_2

//%BEGIN SEH_FDPSBQ_4

`celldefine
module SEH_FDPSBQ_4 (Q, CK, D, SD);
   output Q;
   input CK, D, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SD;

   wire int_res__SD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
`endif
   buf (delayed_SD, SD);


   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, delayed_D, int_res__SD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

  `ifdef VIRL_functiononly
      dff_s #1 (Q, viol_0, delayed_CK, delayed_D, int_res__SD, xcr_0);

  `else
      dff_s (Q, viol_0, delayed_CK, delayed_D, int_res__SD, xcr_0);

  `endif

  `ifdef VIRL_functiononly

  `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, D__bar;


   // Additional timing gates
   not (CK__bar, CK);
   and (cond0, CK__bar, D);
   not (D__bar, D);
   and (cond1, CK__bar, D__bar);
   and (cond2, D, SD);
   and (cond3, D__bar, SD);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:D)) = 1;
      $setuphold (posedge CK &&& SD, posedge D &&& SD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& SD, negedge D &&& SD, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $recovery (posedge SD &&& ~D, posedge CK &&& ~D, 0, viol_0);
      $hold (posedge CK &&& ~D, posedge SD &&& ~D, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond0, 0, 0, viol_0);
      $width (negedge SD &&& cond1, 0, 0, viol_0);
      $width (posedge CK &&& cond2, 0, 0, viol_0);
      $width (negedge CK &&& cond2, 0, 0, viol_0);
      $width (posedge CK &&& cond3, 0, 0, viol_0);
      $width (negedge CK &&& cond3, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FDPSBQ_4

//%BEGIN SEH_FDPTQ_1

`celldefine
module SEH_FDPTQ_1 (Q, CK, D, SS);
   output Q;
   input CK, D, SS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SS;

   wire int_res__D, int_res__SS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SS, SS);
`endif


   or (int_res__D, delayed_D, delayed_SS);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, D__bar;
   wire int_twire_0, SS__bar;


   // Additional timing gates
   not (D__bar, D);
   and (int_twire_0, D__bar, SS);
   or (cond0, D, int_twire_0);
   not (SS__bar, SS);
   and (cond1, D__bar, SS__bar);

   specify
      (posedge CK => (Q+:((D) || (!(D) && SS)))) = 1;
      $setuphold (posedge CK &&& ~SS, posedge D &&& ~SS, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SS, negedge D &&& ~SS, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~D, posedge SS &&& ~D, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $setuphold (posedge CK &&& ~D, negedge SS &&& ~D, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $width (posedge CK &&& cond0, 0, 0, viol_0);
      $width (negedge CK &&& cond0, 0, 0, viol_0);
      $width (posedge CK &&& cond1, 0, 0, viol_0);
      $width (negedge CK &&& cond1, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_FDPTQ_1

//%BEGIN SEH_FILL1

`celldefine
module SEH_FILL1 ();
endmodule
`endcelldefine

//%END SEH_FILL1

//%BEGIN SEH_FILL12

`celldefine
module SEH_FILL12 ();
endmodule
`endcelldefine

//%END SEH_FILL12

//%BEGIN SEH_FILL16

`celldefine
module SEH_FILL16 ();
endmodule
`endcelldefine

//%END SEH_FILL16

//%BEGIN SEH_FILL2

`celldefine
module SEH_FILL2 ();
endmodule
`endcelldefine

//%END SEH_FILL2

//%BEGIN SEH_FILL3

`celldefine
module SEH_FILL3 ();
endmodule
`endcelldefine

//%END SEH_FILL3

//%BEGIN SEH_FILL32

`celldefine
module SEH_FILL32 ();
endmodule
`endcelldefine

//%END SEH_FILL32

//%BEGIN SEH_FILL4

`celldefine
module SEH_FILL4 ();
endmodule
`endcelldefine

//%END SEH_FILL4

//%BEGIN SEH_FILL5

`celldefine
module SEH_FILL5 ();
endmodule
`endcelldefine

//%END SEH_FILL5

//%BEGIN SEH_FILL6

`celldefine
module SEH_FILL6 ();
endmodule
`endcelldefine

//%END SEH_FILL6

//%BEGIN SEH_FILL64

`celldefine
module SEH_FILL64 ();
endmodule
`endcelldefine

//%END SEH_FILL64

//%BEGIN SEH_FILL8

`celldefine
module SEH_FILL8 ();
endmodule
`endcelldefine

//%END SEH_FILL8

//%BEGIN SEH_FILLNOPG1

`celldefine
module SEH_FILLNOPG1 ();
endmodule
`endcelldefine

//%END SEH_FILLNOPG1

//%BEGIN SEH_FILLNOPG12

`celldefine
module SEH_FILLNOPG12 ();
endmodule
`endcelldefine

//%END SEH_FILLNOPG12

//%BEGIN SEH_FILLNOPG16

`celldefine
module SEH_FILLNOPG16 ();
endmodule
`endcelldefine

//%END SEH_FILLNOPG16

//%BEGIN SEH_FILLNOPG2

`celldefine
module SEH_FILLNOPG2 ();
endmodule
`endcelldefine

//%END SEH_FILLNOPG2

//%BEGIN SEH_FILLNOPG3

`celldefine
module SEH_FILLNOPG3 ();
endmodule
`endcelldefine

//%END SEH_FILLNOPG3

//%BEGIN SEH_FILLNOPG32

`celldefine
module SEH_FILLNOPG32 ();
endmodule
`endcelldefine

//%END SEH_FILLNOPG32

//%BEGIN SEH_FILLNOPG4

`celldefine
module SEH_FILLNOPG4 ();
endmodule
`endcelldefine

//%END SEH_FILLNOPG4

//%BEGIN SEH_FILLNOPG5

`celldefine
module SEH_FILLNOPG5 ();
endmodule
`endcelldefine

//%END SEH_FILLNOPG5

//%BEGIN SEH_FILLNOPG6

`celldefine
module SEH_FILLNOPG6 ();
endmodule
`endcelldefine

//%END SEH_FILLNOPG6

//%BEGIN SEH_FILLNOPG64

`celldefine
module SEH_FILLNOPG64 ();
endmodule
`endcelldefine

//%END SEH_FILLNOPG64

//%BEGIN SEH_FILLNOPG8

`celldefine
module SEH_FILLNOPG8 ();
endmodule
`endcelldefine

//%END SEH_FILLNOPG8

//%BEGIN SEH_FILLV2Y1

`celldefine
module SEH_FILLV2Y1 ();
endmodule
`endcelldefine

//%END SEH_FILLV2Y1

//%BEGIN SEH_FILLV2Y12

`celldefine
module SEH_FILLV2Y12 ();
endmodule
`endcelldefine

//%END SEH_FILLV2Y12

//%BEGIN SEH_FILLV2Y16

`celldefine
module SEH_FILLV2Y16 ();
endmodule
`endcelldefine

//%END SEH_FILLV2Y16

//%BEGIN SEH_FILLV2Y2

`celldefine
module SEH_FILLV2Y2 ();
endmodule
`endcelldefine

//%END SEH_FILLV2Y2

//%BEGIN SEH_FILLV2Y3

`celldefine
module SEH_FILLV2Y3 ();
endmodule
`endcelldefine

//%END SEH_FILLV2Y3

//%BEGIN SEH_FILLV2Y32

`celldefine
module SEH_FILLV2Y32 ();
endmodule
`endcelldefine

//%END SEH_FILLV2Y32

//%BEGIN SEH_FILLV2Y4

`celldefine
module SEH_FILLV2Y4 ();
endmodule
`endcelldefine

//%END SEH_FILLV2Y4

//%BEGIN SEH_FILLV2Y5

`celldefine
module SEH_FILLV2Y5 ();
endmodule
`endcelldefine

//%END SEH_FILLV2Y5

//%BEGIN SEH_FILLV2Y6

`celldefine
module SEH_FILLV2Y6 ();
endmodule
`endcelldefine

//%END SEH_FILLV2Y6

//%BEGIN SEH_FILLV2Y64

`celldefine
module SEH_FILLV2Y64 ();
endmodule
`endcelldefine

//%END SEH_FILLV2Y64

//%BEGIN SEH_FILLV2Y8

`celldefine
module SEH_FILLV2Y8 ();
endmodule
`endcelldefine

//%END SEH_FILLV2Y8

//%BEGIN SEH_FILL_ECO1

`celldefine
module SEH_FILL_ECO1 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO1

//%BEGIN SEH_FILL_ECO10

`celldefine
module SEH_FILL_ECO10 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO10

//%BEGIN SEH_FILL_ECO11

`celldefine
module SEH_FILL_ECO11 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO11

//%BEGIN SEH_FILL_ECO12

`celldefine
module SEH_FILL_ECO12 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO12

//%BEGIN SEH_FILL_ECO13

`celldefine
module SEH_FILL_ECO13 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO13

//%BEGIN SEH_FILL_ECO14

`celldefine
module SEH_FILL_ECO14 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO14

//%BEGIN SEH_FILL_ECO15

`celldefine
module SEH_FILL_ECO15 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO15

//%BEGIN SEH_FILL_ECO16

`celldefine
module SEH_FILL_ECO16 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO16

//%BEGIN SEH_FILL_ECO17

`celldefine
module SEH_FILL_ECO17 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO17

//%BEGIN SEH_FILL_ECO18

`celldefine
module SEH_FILL_ECO18 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO18

//%BEGIN SEH_FILL_ECO19

`celldefine
module SEH_FILL_ECO19 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO19

//%BEGIN SEH_FILL_ECO2

`celldefine
module SEH_FILL_ECO2 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO2

//%BEGIN SEH_FILL_ECO20

`celldefine
module SEH_FILL_ECO20 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO20

//%BEGIN SEH_FILL_ECO3

`celldefine
module SEH_FILL_ECO3 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO3

//%BEGIN SEH_FILL_ECO4

`celldefine
module SEH_FILL_ECO4 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO4

//%BEGIN SEH_FILL_ECO5

`celldefine
module SEH_FILL_ECO5 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO5

//%BEGIN SEH_FILL_ECO6

`celldefine
module SEH_FILL_ECO6 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO6

//%BEGIN SEH_FILL_ECO7

`celldefine
module SEH_FILL_ECO7 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO7

//%BEGIN SEH_FILL_ECO8

`celldefine
module SEH_FILL_ECO8 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO8

//%BEGIN SEH_FILL_ECO9

`celldefine
module SEH_FILL_ECO9 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECO9

//%BEGIN SEH_FILL_ECOV2Y1

`celldefine
module SEH_FILL_ECOV2Y1 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECOV2Y1

//%BEGIN SEH_FILL_ECOV2Y16

`celldefine
module SEH_FILL_ECOV2Y16 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECOV2Y16

//%BEGIN SEH_FILL_ECOV2Y2

`celldefine
module SEH_FILL_ECOV2Y2 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECOV2Y2

//%BEGIN SEH_FILL_ECOV2Y3

`celldefine
module SEH_FILL_ECOV2Y3 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECOV2Y3

//%BEGIN SEH_FILL_ECOV2Y4

`celldefine
module SEH_FILL_ECOV2Y4 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECOV2Y4

//%BEGIN SEH_FILL_ECOV2Y8

`celldefine
module SEH_FILL_ECOV2Y8 ();
endmodule
`endcelldefine

//%END SEH_FILL_ECOV2Y8

//%BEGIN SEH_FILL_PO1

`celldefine
module SEH_FILL_PO1 ();
endmodule
`endcelldefine

//%END SEH_FILL_PO1

//%BEGIN SEH_FILL_PONOPG1

`celldefine
module SEH_FILL_PONOPG1 ();
endmodule
`endcelldefine

//%END SEH_FILL_PONOPG1

//%BEGIN SEH_FILL_POV2Y1

`celldefine
module SEH_FILL_POV2Y1 ();
endmodule
`endcelldefine

//%END SEH_FILL_POV2Y1

//%BEGIN SEH_FSDAO22PQO_1

`celldefine
module SEH_FSDAO22PQO_1 (Q, SO, CK, A1, A2, B1, B2, SI, SE);
   output Q,  SO;
   input CK, A1, A2, B1, B2, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_A1, delayed_A2,
        delayed_B1, delayed_B2, delayed_SI,
	delayed_SE;

   wire int_res__DA, int_res__DB, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_A1, A1);
   buf (delayed_A2, A2);
   buf (delayed_B1, B1);
   buf (delayed_B2, B2);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   and (int_res__DA, delayed_A1, delayed_A2);
   and (int_res__DB, delayed_B1, delayed_B2);
   or (int_res__D, int_res__DA, int_res__DB);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire A1__bar, A2__bar, B1__bar;
   wire B2__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire int_twire_8, int_twire_9, int_twire_10;
   wire int_twire_11, int_twire_12, int_twire_13;
   wire int_twire_14, int_twire_15, int_twire_16;
   wire int_twire_17, int_twire_18, int_twire_19;
   wire int_twire_20, int_twire_21, int_twire_22;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (B2__bar, B2);
   not (SE__bar, SE);
   and (cond0, A2, B1, B2__bar, SE__bar);
   not (B1__bar, B1);
   and (cond1, A2, B1__bar, B2, SE__bar);
   and (cond2, A2, B1__bar, B2__bar, SE__bar);
   and (cond3, A1, B1, B2__bar, SE__bar);
   and (cond4, A1, B1__bar, B2, SE__bar);
   and (cond5, A1, B1__bar, B2__bar, SE__bar);
   not (A2__bar, A2);
   and (cond6, A1, A2__bar, B2, SE__bar);
   not (A1__bar, A1);
   and (cond7, A1__bar, A2, B2, SE__bar);
   and (cond8, A1__bar, A2__bar, B2, SE__bar);
   and (cond9, A1, A2__bar, B1, SE__bar);
   and (cond10, A1__bar, A2, B1, SE__bar);
   and (cond11, A1__bar, A2__bar, B1, SE__bar);
   and (int_twire_0, A1, A2__bar, B1, B2__bar, SI);
   and (int_twire_1, A1, A2__bar, B1__bar, SI);
   and (int_twire_2, A1__bar, B1, B2__bar, SI);
   and (int_twire_3, A1__bar, B1__bar, SI);
   or (cond12, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   not (SI__bar, SI);
   and (int_twire_4, A1, A2, SI__bar);
   and (int_twire_5, A1, A2__bar, B1, B2, SI__bar);
   and (int_twire_6, A1__bar, B1, B2, SI__bar);
   or (cond13, int_twire_4, int_twire_5, int_twire_6);
   and (int_twire_7, A1, A2, SE);
   and (int_twire_8, A1, A2__bar, B1, B2, SE);
   and (int_twire_9, A1__bar, B1, B2, SE);
   or (cond14, int_twire_7, int_twire_8, int_twire_9);
   and (int_twire_10, A1, A2__bar, B1, B2__bar, SE);
   and (int_twire_11, A1, A2__bar, B1__bar, SE);
   and (int_twire_12, A1__bar, B1, B2__bar, SE);
   and (int_twire_13, A1__bar, B1__bar, SE);
   or (cond15, int_twire_10, int_twire_11, int_twire_12, int_twire_13);
   and (int_twire_14, SE, SI);
   and (int_twire_15, A1, A2, SE__bar);
   and (int_twire_16, A1, A2__bar, B1, B2, SE__bar);
   and (int_twire_17, A1__bar, B1, B2, SE__bar);
   or (cond16, int_twire_14, int_twire_15, int_twire_16, int_twire_17);
   and (int_twire_18, SE, SI__bar);
   and (int_twire_19, A1, A2__bar, B1__bar, B2, SE__bar);
   and (int_twire_20, A1, A2__bar, B2__bar, SE__bar);
   and (int_twire_21, A1__bar, B1__bar, B2, SE__bar);
   and (int_twire_22, A1__bar, B2__bar, SE__bar);
   or (cond17, int_twire_18, int_twire_19, int_twire_20, int_twire_21, int_twire_22);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond0, negedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, posedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, negedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, posedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, negedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond3, posedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond3, negedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, posedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, negedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, posedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, negedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond6, posedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond6, negedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, posedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, negedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, posedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, negedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond9, posedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond9, negedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, posedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, negedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, posedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, negedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDAO22PQO_1

//%BEGIN SEH_FSDAO22PQO_2

`celldefine
module SEH_FSDAO22PQO_2 (Q, SO, CK, A1, A2, B1, B2, SI, SE);
   output Q,  SO;
   input CK, A1, A2, B1, B2, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_A1, delayed_A2,
        delayed_B1, delayed_B2, delayed_SI,
	delayed_SE;

   wire int_res__DA, int_res__DB, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_A1, A1);
   buf (delayed_A2, A2);
   buf (delayed_B1, B1);
   buf (delayed_B2, B2);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   and (int_res__DA, delayed_A1, delayed_A2);
   and (int_res__DB, delayed_B1, delayed_B2);
   or (int_res__D, int_res__DA, int_res__DB);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire A1__bar, A2__bar, B1__bar;
   wire B2__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire int_twire_8, int_twire_9, int_twire_10;
   wire int_twire_11, int_twire_12, int_twire_13;
   wire int_twire_14, int_twire_15, int_twire_16;
   wire int_twire_17, int_twire_18, int_twire_19;
   wire int_twire_20, int_twire_21, int_twire_22;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (B2__bar, B2);
   not (SE__bar, SE);
   and (cond0, A2, B1, B2__bar, SE__bar);
   not (B1__bar, B1);
   and (cond1, A2, B1__bar, B2, SE__bar);
   and (cond2, A2, B1__bar, B2__bar, SE__bar);
   and (cond3, A1, B1, B2__bar, SE__bar);
   and (cond4, A1, B1__bar, B2, SE__bar);
   and (cond5, A1, B1__bar, B2__bar, SE__bar);
   not (A2__bar, A2);
   and (cond6, A1, A2__bar, B2, SE__bar);
   not (A1__bar, A1);
   and (cond7, A1__bar, A2, B2, SE__bar);
   and (cond8, A1__bar, A2__bar, B2, SE__bar);
   and (cond9, A1, A2__bar, B1, SE__bar);
   and (cond10, A1__bar, A2, B1, SE__bar);
   and (cond11, A1__bar, A2__bar, B1, SE__bar);
   and (int_twire_0, A1, A2__bar, B1, B2__bar, SI);
   and (int_twire_1, A1, A2__bar, B1__bar, SI);
   and (int_twire_2, A1__bar, B1, B2__bar, SI);
   and (int_twire_3, A1__bar, B1__bar, SI);
   or (cond12, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   not (SI__bar, SI);
   and (int_twire_4, A1, A2, SI__bar);
   and (int_twire_5, A1, A2__bar, B1, B2, SI__bar);
   and (int_twire_6, A1__bar, B1, B2, SI__bar);
   or (cond13, int_twire_4, int_twire_5, int_twire_6);
   and (int_twire_7, A1, A2, SE);
   and (int_twire_8, A1, A2__bar, B1, B2, SE);
   and (int_twire_9, A1__bar, B1, B2, SE);
   or (cond14, int_twire_7, int_twire_8, int_twire_9);
   and (int_twire_10, A1, A2__bar, B1, B2__bar, SE);
   and (int_twire_11, A1, A2__bar, B1__bar, SE);
   and (int_twire_12, A1__bar, B1, B2__bar, SE);
   and (int_twire_13, A1__bar, B1__bar, SE);
   or (cond15, int_twire_10, int_twire_11, int_twire_12, int_twire_13);
   and (int_twire_14, SE, SI);
   and (int_twire_15, A1, A2, SE__bar);
   and (int_twire_16, A1, A2__bar, B1, B2, SE__bar);
   and (int_twire_17, A1__bar, B1, B2, SE__bar);
   or (cond16, int_twire_14, int_twire_15, int_twire_16, int_twire_17);
   and (int_twire_18, SE, SI__bar);
   and (int_twire_19, A1, A2__bar, B1__bar, B2, SE__bar);
   and (int_twire_20, A1, A2__bar, B2__bar, SE__bar);
   and (int_twire_21, A1__bar, B1__bar, B2, SE__bar);
   and (int_twire_22, A1__bar, B2__bar, SE__bar);
   or (cond17, int_twire_18, int_twire_19, int_twire_20, int_twire_21, int_twire_22);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond0, negedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, posedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, negedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, posedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, negedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond3, posedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond3, negedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, posedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, negedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, posedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, negedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond6, posedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond6, negedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, posedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, negedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, posedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, negedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond9, posedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond9, negedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, posedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, negedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, posedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, negedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDAO22PQO_2

//%BEGIN SEH_FSDAO22PQO_4

`celldefine
module SEH_FSDAO22PQO_4 (Q, SO, CK, A1, A2, B1, B2, SI, SE);
   output Q,  SO;
   input CK, A1, A2, B1, B2, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_A1, delayed_A2,
        delayed_B1, delayed_B2, delayed_SI,
	delayed_SE;

   wire int_res__DA, int_res__DB, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_A1, A1);
   buf (delayed_A2, A2);
   buf (delayed_B1, B1);
   buf (delayed_B2, B2);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   and (int_res__DA, delayed_A1, delayed_A2);
   and (int_res__DB, delayed_B1, delayed_B2);
   or (int_res__D, int_res__DA, int_res__DB);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire A1__bar, A2__bar, B1__bar;
   wire B2__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire int_twire_8, int_twire_9, int_twire_10;
   wire int_twire_11, int_twire_12, int_twire_13;
   wire int_twire_14, int_twire_15, int_twire_16;
   wire int_twire_17, int_twire_18, int_twire_19;
   wire int_twire_20, int_twire_21, int_twire_22;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (B2__bar, B2);
   not (SE__bar, SE);
   and (cond0, A2, B1, B2__bar, SE__bar);
   not (B1__bar, B1);
   and (cond1, A2, B1__bar, B2, SE__bar);
   and (cond2, A2, B1__bar, B2__bar, SE__bar);
   and (cond3, A1, B1, B2__bar, SE__bar);
   and (cond4, A1, B1__bar, B2, SE__bar);
   and (cond5, A1, B1__bar, B2__bar, SE__bar);
   not (A2__bar, A2);
   and (cond6, A1, A2__bar, B2, SE__bar);
   not (A1__bar, A1);
   and (cond7, A1__bar, A2, B2, SE__bar);
   and (cond8, A1__bar, A2__bar, B2, SE__bar);
   and (cond9, A1, A2__bar, B1, SE__bar);
   and (cond10, A1__bar, A2, B1, SE__bar);
   and (cond11, A1__bar, A2__bar, B1, SE__bar);
   and (int_twire_0, A1, A2__bar, B1, B2__bar, SI);
   and (int_twire_1, A1, A2__bar, B1__bar, SI);
   and (int_twire_2, A1__bar, B1, B2__bar, SI);
   and (int_twire_3, A1__bar, B1__bar, SI);
   or (cond12, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   not (SI__bar, SI);
   and (int_twire_4, A1, A2, SI__bar);
   and (int_twire_5, A1, A2__bar, B1, B2, SI__bar);
   and (int_twire_6, A1__bar, B1, B2, SI__bar);
   or (cond13, int_twire_4, int_twire_5, int_twire_6);
   and (int_twire_7, A1, A2, SE);
   and (int_twire_8, A1, A2__bar, B1, B2, SE);
   and (int_twire_9, A1__bar, B1, B2, SE);
   or (cond14, int_twire_7, int_twire_8, int_twire_9);
   and (int_twire_10, A1, A2__bar, B1, B2__bar, SE);
   and (int_twire_11, A1, A2__bar, B1__bar, SE);
   and (int_twire_12, A1__bar, B1, B2__bar, SE);
   and (int_twire_13, A1__bar, B1__bar, SE);
   or (cond15, int_twire_10, int_twire_11, int_twire_12, int_twire_13);
   and (int_twire_14, SE, SI);
   and (int_twire_15, A1, A2, SE__bar);
   and (int_twire_16, A1, A2__bar, B1, B2, SE__bar);
   and (int_twire_17, A1__bar, B1, B2, SE__bar);
   or (cond16, int_twire_14, int_twire_15, int_twire_16, int_twire_17);
   and (int_twire_18, SE, SI__bar);
   and (int_twire_19, A1, A2__bar, B1__bar, B2, SE__bar);
   and (int_twire_20, A1, A2__bar, B2__bar, SE__bar);
   and (int_twire_21, A1__bar, B1__bar, B2, SE__bar);
   and (int_twire_22, A1__bar, B2__bar, SE__bar);
   or (cond17, int_twire_18, int_twire_19, int_twire_20, int_twire_21, int_twire_22);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond0, negedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, posedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, negedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, posedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, negedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond3, posedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond3, negedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, posedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, negedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, posedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, negedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond6, posedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond6, negedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, posedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, negedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, posedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, negedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond9, posedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond9, negedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, posedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, negedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, posedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, negedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDAO22PQO_4

//%BEGIN SEH_FSDAO22PQO_D_1

`celldefine
module SEH_FSDAO22PQO_D_1 (Q, SO, CK, A1, A2, B1, B2, SI, SE);
   output Q,  SO;
   input CK, A1, A2, B1, B2, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_A1, delayed_A2,
        delayed_B1, delayed_B2, delayed_SI,
	delayed_SE;

   wire int_res__DA, int_res__DB, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_A1, A1);
   buf (delayed_A2, A2);
   buf (delayed_B1, B1);
   buf (delayed_B2, B2);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   and (int_res__DA, delayed_A1, delayed_A2);
   and (int_res__DB, delayed_B1, delayed_B2);
   or (int_res__D, int_res__DA, int_res__DB);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire A1__bar, A2__bar, B1__bar;
   wire B2__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire int_twire_8, int_twire_9, int_twire_10;
   wire int_twire_11, int_twire_12, int_twire_13;
   wire int_twire_14, int_twire_15, int_twire_16;
   wire int_twire_17, int_twire_18, int_twire_19;
   wire int_twire_20, int_twire_21, int_twire_22;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (B2__bar, B2);
   not (SE__bar, SE);
   and (cond0, A2, B1, B2__bar, SE__bar);
   not (B1__bar, B1);
   and (cond1, A2, B1__bar, B2, SE__bar);
   and (cond2, A2, B1__bar, B2__bar, SE__bar);
   and (cond3, A1, B1, B2__bar, SE__bar);
   and (cond4, A1, B1__bar, B2, SE__bar);
   and (cond5, A1, B1__bar, B2__bar, SE__bar);
   not (A2__bar, A2);
   and (cond6, A1, A2__bar, B2, SE__bar);
   not (A1__bar, A1);
   and (cond7, A1__bar, A2, B2, SE__bar);
   and (cond8, A1__bar, A2__bar, B2, SE__bar);
   and (cond9, A1, A2__bar, B1, SE__bar);
   and (cond10, A1__bar, A2, B1, SE__bar);
   and (cond11, A1__bar, A2__bar, B1, SE__bar);
   and (int_twire_0, A1, A2__bar, B1, B2__bar, SI);
   and (int_twire_1, A1, A2__bar, B1__bar, SI);
   and (int_twire_2, A1__bar, B1, B2__bar, SI);
   and (int_twire_3, A1__bar, B1__bar, SI);
   or (cond12, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   not (SI__bar, SI);
   and (int_twire_4, A1, A2, SI__bar);
   and (int_twire_5, A1, A2__bar, B1, B2, SI__bar);
   and (int_twire_6, A1__bar, B1, B2, SI__bar);
   or (cond13, int_twire_4, int_twire_5, int_twire_6);
   and (int_twire_7, A1, A2, SE);
   and (int_twire_8, A1, A2__bar, B1, B2, SE);
   and (int_twire_9, A1__bar, B1, B2, SE);
   or (cond14, int_twire_7, int_twire_8, int_twire_9);
   and (int_twire_10, A1, A2__bar, B1, B2__bar, SE);
   and (int_twire_11, A1, A2__bar, B1__bar, SE);
   and (int_twire_12, A1__bar, B1, B2__bar, SE);
   and (int_twire_13, A1__bar, B1__bar, SE);
   or (cond15, int_twire_10, int_twire_11, int_twire_12, int_twire_13);
   and (int_twire_14, SE, SI);
   and (int_twire_15, A1, A2, SE__bar);
   and (int_twire_16, A1, A2__bar, B1, B2, SE__bar);
   and (int_twire_17, A1__bar, B1, B2, SE__bar);
   or (cond16, int_twire_14, int_twire_15, int_twire_16, int_twire_17);
   and (int_twire_18, SE, SI__bar);
   and (int_twire_19, A1, A2__bar, B1__bar, B2, SE__bar);
   and (int_twire_20, A1, A2__bar, B2__bar, SE__bar);
   and (int_twire_21, A1__bar, B1__bar, B2, SE__bar);
   and (int_twire_22, A1__bar, B2__bar, SE__bar);
   or (cond17, int_twire_18, int_twire_19, int_twire_20, int_twire_21, int_twire_22);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond0, negedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, posedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, negedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, posedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, negedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond3, posedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond3, negedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, posedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, negedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, posedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, negedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond6, posedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond6, negedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, posedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, negedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, posedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, negedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond9, posedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond9, negedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, posedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, negedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, posedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, negedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDAO22PQO_D_1

//%BEGIN SEH_FSDAO22PQO_D_2

`celldefine
module SEH_FSDAO22PQO_D_2 (Q, SO, CK, A1, A2, B1, B2, SI, SE);
   output Q,  SO;
   input CK, A1, A2, B1, B2, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_A1, delayed_A2,
        delayed_B1, delayed_B2, delayed_SI,
	delayed_SE;

   wire int_res__DA, int_res__DB, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_A1, A1);
   buf (delayed_A2, A2);
   buf (delayed_B1, B1);
   buf (delayed_B2, B2);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   and (int_res__DA, delayed_A1, delayed_A2);
   and (int_res__DB, delayed_B1, delayed_B2);
   or (int_res__D, int_res__DA, int_res__DB);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire A1__bar, A2__bar, B1__bar;
   wire B2__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire int_twire_8, int_twire_9, int_twire_10;
   wire int_twire_11, int_twire_12, int_twire_13;
   wire int_twire_14, int_twire_15, int_twire_16;
   wire int_twire_17, int_twire_18, int_twire_19;
   wire int_twire_20, int_twire_21, int_twire_22;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (B2__bar, B2);
   not (SE__bar, SE);
   and (cond0, A2, B1, B2__bar, SE__bar);
   not (B1__bar, B1);
   and (cond1, A2, B1__bar, B2, SE__bar);
   and (cond2, A2, B1__bar, B2__bar, SE__bar);
   and (cond3, A1, B1, B2__bar, SE__bar);
   and (cond4, A1, B1__bar, B2, SE__bar);
   and (cond5, A1, B1__bar, B2__bar, SE__bar);
   not (A2__bar, A2);
   and (cond6, A1, A2__bar, B2, SE__bar);
   not (A1__bar, A1);
   and (cond7, A1__bar, A2, B2, SE__bar);
   and (cond8, A1__bar, A2__bar, B2, SE__bar);
   and (cond9, A1, A2__bar, B1, SE__bar);
   and (cond10, A1__bar, A2, B1, SE__bar);
   and (cond11, A1__bar, A2__bar, B1, SE__bar);
   and (int_twire_0, A1, A2__bar, B1, B2__bar, SI);
   and (int_twire_1, A1, A2__bar, B1__bar, SI);
   and (int_twire_2, A1__bar, B1, B2__bar, SI);
   and (int_twire_3, A1__bar, B1__bar, SI);
   or (cond12, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   not (SI__bar, SI);
   and (int_twire_4, A1, A2, SI__bar);
   and (int_twire_5, A1, A2__bar, B1, B2, SI__bar);
   and (int_twire_6, A1__bar, B1, B2, SI__bar);
   or (cond13, int_twire_4, int_twire_5, int_twire_6);
   and (int_twire_7, A1, A2, SE);
   and (int_twire_8, A1, A2__bar, B1, B2, SE);
   and (int_twire_9, A1__bar, B1, B2, SE);
   or (cond14, int_twire_7, int_twire_8, int_twire_9);
   and (int_twire_10, A1, A2__bar, B1, B2__bar, SE);
   and (int_twire_11, A1, A2__bar, B1__bar, SE);
   and (int_twire_12, A1__bar, B1, B2__bar, SE);
   and (int_twire_13, A1__bar, B1__bar, SE);
   or (cond15, int_twire_10, int_twire_11, int_twire_12, int_twire_13);
   and (int_twire_14, SE, SI);
   and (int_twire_15, A1, A2, SE__bar);
   and (int_twire_16, A1, A2__bar, B1, B2, SE__bar);
   and (int_twire_17, A1__bar, B1, B2, SE__bar);
   or (cond16, int_twire_14, int_twire_15, int_twire_16, int_twire_17);
   and (int_twire_18, SE, SI__bar);
   and (int_twire_19, A1, A2__bar, B1__bar, B2, SE__bar);
   and (int_twire_20, A1, A2__bar, B2__bar, SE__bar);
   and (int_twire_21, A1__bar, B1__bar, B2, SE__bar);
   and (int_twire_22, A1__bar, B2__bar, SE__bar);
   or (cond17, int_twire_18, int_twire_19, int_twire_20, int_twire_21, int_twire_22);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond0, negedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, posedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, negedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, posedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, negedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond3, posedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond3, negedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, posedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, negedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, posedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, negedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond6, posedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond6, negedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, posedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, negedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, posedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, negedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond9, posedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond9, negedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, posedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, negedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, posedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, negedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDAO22PQO_D_2

//%BEGIN SEH_FSDAO22PQO_D_4

`celldefine
module SEH_FSDAO22PQO_D_4 (Q, SO, CK, A1, A2, B1, B2, SI, SE);
   output Q,  SO;
   input CK, A1, A2, B1, B2, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_A1, delayed_A2,
        delayed_B1, delayed_B2, delayed_SI,
	delayed_SE;

   wire int_res__DA, int_res__DB, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_A1, A1);
   buf (delayed_A2, A2);
   buf (delayed_B1, B1);
   buf (delayed_B2, B2);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   and (int_res__DA, delayed_A1, delayed_A2);
   and (int_res__DB, delayed_B1, delayed_B2);
   or (int_res__D, int_res__DA, int_res__DB);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire A1__bar, A2__bar, B1__bar;
   wire B2__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire int_twire_8, int_twire_9, int_twire_10;
   wire int_twire_11, int_twire_12, int_twire_13;
   wire int_twire_14, int_twire_15, int_twire_16;
   wire int_twire_17, int_twire_18, int_twire_19;
   wire int_twire_20, int_twire_21, int_twire_22;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (B2__bar, B2);
   not (SE__bar, SE);
   and (cond0, A2, B1, B2__bar, SE__bar);
   not (B1__bar, B1);
   and (cond1, A2, B1__bar, B2, SE__bar);
   and (cond2, A2, B1__bar, B2__bar, SE__bar);
   and (cond3, A1, B1, B2__bar, SE__bar);
   and (cond4, A1, B1__bar, B2, SE__bar);
   and (cond5, A1, B1__bar, B2__bar, SE__bar);
   not (A2__bar, A2);
   and (cond6, A1, A2__bar, B2, SE__bar);
   not (A1__bar, A1);
   and (cond7, A1__bar, A2, B2, SE__bar);
   and (cond8, A1__bar, A2__bar, B2, SE__bar);
   and (cond9, A1, A2__bar, B1, SE__bar);
   and (cond10, A1__bar, A2, B1, SE__bar);
   and (cond11, A1__bar, A2__bar, B1, SE__bar);
   and (int_twire_0, A1, A2__bar, B1, B2__bar, SI);
   and (int_twire_1, A1, A2__bar, B1__bar, SI);
   and (int_twire_2, A1__bar, B1, B2__bar, SI);
   and (int_twire_3, A1__bar, B1__bar, SI);
   or (cond12, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   not (SI__bar, SI);
   and (int_twire_4, A1, A2, SI__bar);
   and (int_twire_5, A1, A2__bar, B1, B2, SI__bar);
   and (int_twire_6, A1__bar, B1, B2, SI__bar);
   or (cond13, int_twire_4, int_twire_5, int_twire_6);
   and (int_twire_7, A1, A2, SE);
   and (int_twire_8, A1, A2__bar, B1, B2, SE);
   and (int_twire_9, A1__bar, B1, B2, SE);
   or (cond14, int_twire_7, int_twire_8, int_twire_9);
   and (int_twire_10, A1, A2__bar, B1, B2__bar, SE);
   and (int_twire_11, A1, A2__bar, B1__bar, SE);
   and (int_twire_12, A1__bar, B1, B2__bar, SE);
   and (int_twire_13, A1__bar, B1__bar, SE);
   or (cond15, int_twire_10, int_twire_11, int_twire_12, int_twire_13);
   and (int_twire_14, SE, SI);
   and (int_twire_15, A1, A2, SE__bar);
   and (int_twire_16, A1, A2__bar, B1, B2, SE__bar);
   and (int_twire_17, A1__bar, B1, B2, SE__bar);
   or (cond16, int_twire_14, int_twire_15, int_twire_16, int_twire_17);
   and (int_twire_18, SE, SI__bar);
   and (int_twire_19, A1, A2__bar, B1__bar, B2, SE__bar);
   and (int_twire_20, A1, A2__bar, B2__bar, SE__bar);
   and (int_twire_21, A1__bar, B1__bar, B2, SE__bar);
   and (int_twire_22, A1__bar, B2__bar, SE__bar);
   or (cond17, int_twire_18, int_twire_19, int_twire_20, int_twire_21, int_twire_22);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond0, negedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, posedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, negedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, posedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, negedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond3, posedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond3, negedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, posedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, negedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, posedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, negedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond6, posedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond6, negedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, posedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, negedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, posedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, negedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond9, posedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond9, negedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, posedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, negedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, posedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, negedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDAO22PQO_D_4

//%BEGIN SEH_FSDAO22PQ_D_1

`celldefine
module SEH_FSDAO22PQ_D_1 (Q, CK, A1, A2, B1, B2, SI, SE);
   output Q;
   input CK, A1, A2, B1, B2, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_A1, delayed_A2,
        delayed_B1, delayed_B2, delayed_SI,
	delayed_SE;

   wire int_res__DA, int_res__DB, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_A1, A1);
   buf (delayed_A2, A2);
   buf (delayed_B1, B1);
   buf (delayed_B2, B2);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   and (int_res__DA, delayed_A1, delayed_A2);
   and (int_res__DB, delayed_B1, delayed_B2);
   or (int_res__D, int_res__DA, int_res__DB);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
   `else
        buf (Q, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire A1__bar, A2__bar, B1__bar;
   wire B2__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire int_twire_8, int_twire_9, int_twire_10;
   wire int_twire_11, int_twire_12, int_twire_13;
   wire int_twire_14, int_twire_15, int_twire_16;
   wire int_twire_17, int_twire_18, int_twire_19;
   wire int_twire_20, int_twire_21, int_twire_22;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (B2__bar, B2);
   not (SE__bar, SE);
   and (cond0, A2, B1, B2__bar, SE__bar);
   not (B1__bar, B1);
   and (cond1, A2, B1__bar, B2, SE__bar);
   and (cond2, A2, B1__bar, B2__bar, SE__bar);
   and (cond3, A1, B1, B2__bar, SE__bar);
   and (cond4, A1, B1__bar, B2, SE__bar);
   and (cond5, A1, B1__bar, B2__bar, SE__bar);
   not (A2__bar, A2);
   and (cond6, A1, A2__bar, B2, SE__bar);
   not (A1__bar, A1);
   and (cond7, A1__bar, A2, B2, SE__bar);
   and (cond8, A1__bar, A2__bar, B2, SE__bar);
   and (cond9, A1, A2__bar, B1, SE__bar);
   and (cond10, A1__bar, A2, B1, SE__bar);
   and (cond11, A1__bar, A2__bar, B1, SE__bar);
   and (int_twire_0, A1, A2__bar, B1, B2__bar, SI);
   and (int_twire_1, A1, A2__bar, B1__bar, SI);
   and (int_twire_2, A1__bar, B1, B2__bar, SI);
   and (int_twire_3, A1__bar, B1__bar, SI);
   or (cond12, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   not (SI__bar, SI);
   and (int_twire_4, A1, A2, SI__bar);
   and (int_twire_5, A1, A2__bar, B1, B2, SI__bar);
   and (int_twire_6, A1__bar, B1, B2, SI__bar);
   or (cond13, int_twire_4, int_twire_5, int_twire_6);
   and (int_twire_7, A1, A2, SE);
   and (int_twire_8, A1, A2__bar, B1, B2, SE);
   and (int_twire_9, A1__bar, B1, B2, SE);
   or (cond14, int_twire_7, int_twire_8, int_twire_9);
   and (int_twire_10, A1, A2__bar, B1, B2__bar, SE);
   and (int_twire_11, A1, A2__bar, B1__bar, SE);
   and (int_twire_12, A1__bar, B1, B2__bar, SE);
   and (int_twire_13, A1__bar, B1__bar, SE);
   or (cond15, int_twire_10, int_twire_11, int_twire_12, int_twire_13);
   and (int_twire_14, SE, SI);
   and (int_twire_15, A1, A2, SE__bar);
   and (int_twire_16, A1, A2__bar, B1, B2, SE__bar);
   and (int_twire_17, A1__bar, B1, B2, SE__bar);
   or (cond16, int_twire_14, int_twire_15, int_twire_16, int_twire_17);
   and (int_twire_18, SE, SI__bar);
   and (int_twire_19, A1, A2__bar, B1__bar, B2, SE__bar);
   and (int_twire_20, A1, A2__bar, B2__bar, SE__bar);
   and (int_twire_21, A1__bar, B1__bar, B2, SE__bar);
   and (int_twire_22, A1__bar, B2__bar, SE__bar);
   or (cond17, int_twire_18, int_twire_19, int_twire_20, int_twire_21, int_twire_22);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond0, negedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, posedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, negedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, posedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, negedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond3, posedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond3, negedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, posedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, negedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, posedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, negedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond6, posedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond6, negedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, posedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, negedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, posedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, negedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond9, posedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond9, negedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, posedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, negedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, posedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, negedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDAO22PQ_D_1

//%BEGIN SEH_FSDAO22PQ_D_2

`celldefine
module SEH_FSDAO22PQ_D_2 (Q, CK, A1, A2, B1, B2, SI, SE);
   output Q;
   input CK, A1, A2, B1, B2, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_A1, delayed_A2,
        delayed_B1, delayed_B2, delayed_SI,
	delayed_SE;

   wire int_res__DA, int_res__DB, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_A1, A1);
   buf (delayed_A2, A2);
   buf (delayed_B1, B1);
   buf (delayed_B2, B2);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   and (int_res__DA, delayed_A1, delayed_A2);
   and (int_res__DB, delayed_B1, delayed_B2);
   or (int_res__D, int_res__DA, int_res__DB);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
   `else
        buf (Q, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire A1__bar, A2__bar, B1__bar;
   wire B2__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire int_twire_8, int_twire_9, int_twire_10;
   wire int_twire_11, int_twire_12, int_twire_13;
   wire int_twire_14, int_twire_15, int_twire_16;
   wire int_twire_17, int_twire_18, int_twire_19;
   wire int_twire_20, int_twire_21, int_twire_22;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (B2__bar, B2);
   not (SE__bar, SE);
   and (cond0, A2, B1, B2__bar, SE__bar);
   not (B1__bar, B1);
   and (cond1, A2, B1__bar, B2, SE__bar);
   and (cond2, A2, B1__bar, B2__bar, SE__bar);
   and (cond3, A1, B1, B2__bar, SE__bar);
   and (cond4, A1, B1__bar, B2, SE__bar);
   and (cond5, A1, B1__bar, B2__bar, SE__bar);
   not (A2__bar, A2);
   and (cond6, A1, A2__bar, B2, SE__bar);
   not (A1__bar, A1);
   and (cond7, A1__bar, A2, B2, SE__bar);
   and (cond8, A1__bar, A2__bar, B2, SE__bar);
   and (cond9, A1, A2__bar, B1, SE__bar);
   and (cond10, A1__bar, A2, B1, SE__bar);
   and (cond11, A1__bar, A2__bar, B1, SE__bar);
   and (int_twire_0, A1, A2__bar, B1, B2__bar, SI);
   and (int_twire_1, A1, A2__bar, B1__bar, SI);
   and (int_twire_2, A1__bar, B1, B2__bar, SI);
   and (int_twire_3, A1__bar, B1__bar, SI);
   or (cond12, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   not (SI__bar, SI);
   and (int_twire_4, A1, A2, SI__bar);
   and (int_twire_5, A1, A2__bar, B1, B2, SI__bar);
   and (int_twire_6, A1__bar, B1, B2, SI__bar);
   or (cond13, int_twire_4, int_twire_5, int_twire_6);
   and (int_twire_7, A1, A2, SE);
   and (int_twire_8, A1, A2__bar, B1, B2, SE);
   and (int_twire_9, A1__bar, B1, B2, SE);
   or (cond14, int_twire_7, int_twire_8, int_twire_9);
   and (int_twire_10, A1, A2__bar, B1, B2__bar, SE);
   and (int_twire_11, A1, A2__bar, B1__bar, SE);
   and (int_twire_12, A1__bar, B1, B2__bar, SE);
   and (int_twire_13, A1__bar, B1__bar, SE);
   or (cond15, int_twire_10, int_twire_11, int_twire_12, int_twire_13);
   and (int_twire_14, SE, SI);
   and (int_twire_15, A1, A2, SE__bar);
   and (int_twire_16, A1, A2__bar, B1, B2, SE__bar);
   and (int_twire_17, A1__bar, B1, B2, SE__bar);
   or (cond16, int_twire_14, int_twire_15, int_twire_16, int_twire_17);
   and (int_twire_18, SE, SI__bar);
   and (int_twire_19, A1, A2__bar, B1__bar, B2, SE__bar);
   and (int_twire_20, A1, A2__bar, B2__bar, SE__bar);
   and (int_twire_21, A1__bar, B1__bar, B2, SE__bar);
   and (int_twire_22, A1__bar, B2__bar, SE__bar);
   or (cond17, int_twire_18, int_twire_19, int_twire_20, int_twire_21, int_twire_22);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond0, negedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, posedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, negedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, posedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, negedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond3, posedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond3, negedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, posedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, negedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, posedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, negedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond6, posedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond6, negedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, posedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, negedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, posedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, negedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond9, posedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond9, negedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, posedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, negedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, posedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, negedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDAO22PQ_D_2

//%BEGIN SEH_FSDAO22PQ_D_4

`celldefine
module SEH_FSDAO22PQ_D_4 (Q, CK, A1, A2, B1, B2, SI, SE);
   output Q;
   input CK, A1, A2, B1, B2, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_A1, delayed_A2,
        delayed_B1, delayed_B2, delayed_SI,
	delayed_SE;

   wire int_res__DA, int_res__DB, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_A1, A1);
   buf (delayed_A2, A2);
   buf (delayed_B1, B1);
   buf (delayed_B2, B2);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   and (int_res__DA, delayed_A1, delayed_A2);
   and (int_res__DB, delayed_B1, delayed_B2);
   or (int_res__D, int_res__DA, int_res__DB);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
   `else
        buf (Q, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire A1__bar, A2__bar, B1__bar;
   wire B2__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire int_twire_8, int_twire_9, int_twire_10;
   wire int_twire_11, int_twire_12, int_twire_13;
   wire int_twire_14, int_twire_15, int_twire_16;
   wire int_twire_17, int_twire_18, int_twire_19;
   wire int_twire_20, int_twire_21, int_twire_22;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (B2__bar, B2);
   not (SE__bar, SE);
   and (cond0, A2, B1, B2__bar, SE__bar);
   not (B1__bar, B1);
   and (cond1, A2, B1__bar, B2, SE__bar);
   and (cond2, A2, B1__bar, B2__bar, SE__bar);
   and (cond3, A1, B1, B2__bar, SE__bar);
   and (cond4, A1, B1__bar, B2, SE__bar);
   and (cond5, A1, B1__bar, B2__bar, SE__bar);
   not (A2__bar, A2);
   and (cond6, A1, A2__bar, B2, SE__bar);
   not (A1__bar, A1);
   and (cond7, A1__bar, A2, B2, SE__bar);
   and (cond8, A1__bar, A2__bar, B2, SE__bar);
   and (cond9, A1, A2__bar, B1, SE__bar);
   and (cond10, A1__bar, A2, B1, SE__bar);
   and (cond11, A1__bar, A2__bar, B1, SE__bar);
   and (int_twire_0, A1, A2__bar, B1, B2__bar, SI);
   and (int_twire_1, A1, A2__bar, B1__bar, SI);
   and (int_twire_2, A1__bar, B1, B2__bar, SI);
   and (int_twire_3, A1__bar, B1__bar, SI);
   or (cond12, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   not (SI__bar, SI);
   and (int_twire_4, A1, A2, SI__bar);
   and (int_twire_5, A1, A2__bar, B1, B2, SI__bar);
   and (int_twire_6, A1__bar, B1, B2, SI__bar);
   or (cond13, int_twire_4, int_twire_5, int_twire_6);
   and (int_twire_7, A1, A2, SE);
   and (int_twire_8, A1, A2__bar, B1, B2, SE);
   and (int_twire_9, A1__bar, B1, B2, SE);
   or (cond14, int_twire_7, int_twire_8, int_twire_9);
   and (int_twire_10, A1, A2__bar, B1, B2__bar, SE);
   and (int_twire_11, A1, A2__bar, B1__bar, SE);
   and (int_twire_12, A1__bar, B1, B2__bar, SE);
   and (int_twire_13, A1__bar, B1__bar, SE);
   or (cond15, int_twire_10, int_twire_11, int_twire_12, int_twire_13);
   and (int_twire_14, SE, SI);
   and (int_twire_15, A1, A2, SE__bar);
   and (int_twire_16, A1, A2__bar, B1, B2, SE__bar);
   and (int_twire_17, A1__bar, B1, B2, SE__bar);
   or (cond16, int_twire_14, int_twire_15, int_twire_16, int_twire_17);
   and (int_twire_18, SE, SI__bar);
   and (int_twire_19, A1, A2__bar, B1__bar, B2, SE__bar);
   and (int_twire_20, A1, A2__bar, B2__bar, SE__bar);
   and (int_twire_21, A1__bar, B1__bar, B2, SE__bar);
   and (int_twire_22, A1__bar, B2__bar, SE__bar);
   or (cond17, int_twire_18, int_twire_19, int_twire_20, int_twire_21, int_twire_22);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && A1 && A2) || (!(SE) && A1 && !(A2) && B1 && B2) || (!(SE) && !(A1) && B1 && B2)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond0, negedge A1 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, posedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond1, negedge A1 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, posedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond2, negedge A1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_A1);
      $setuphold (posedge CK &&& cond3, posedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond3, negedge A2 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, posedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond4, negedge A2 &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, posedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond5, negedge A2 &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_A2);
      $setuphold (posedge CK &&& cond6, posedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond6, negedge B1 &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, posedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond7, negedge B1 &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, posedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond8, negedge B1 &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_B1);
      $setuphold (posedge CK &&& cond9, posedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond9, negedge B2 &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, posedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond10, negedge B2 &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, posedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond11, negedge B2 &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_B2);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDAO22PQ_D_4

//%BEGIN SEH_FSDNQO_1

`celldefine
module SEH_FSDNQO_1 (Q, SO, CK, D, SI, SE);
   output Q, SO;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__CK, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   not (int_res__CK, delayed_CK);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, int_res__CK, int_res__D);
   dff (int_res_iq, viol_0, int_res__CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      (negedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNQO_1

//%BEGIN SEH_FSDNQO_2

`celldefine
module SEH_FSDNQO_2 (Q, SO, CK, D, SI, SE);
   output Q, SO;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__CK, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   not (int_res__CK, delayed_CK);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, int_res__CK, int_res__D);
   dff (int_res_iq, viol_0, int_res__CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      (negedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNQO_2

//%BEGIN SEH_FSDNQO_4

`celldefine
module SEH_FSDNQO_4 (Q, SO, CK, D, SI, SE);
   output Q, SO;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__CK, int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif


   not (int_res__CK, delayed_CK);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, int_res__CK, int_res__D);
   dff (int_res_iq, viol_0, int_res__CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      (negedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNQO_4

//%BEGIN SEH_FSDNQ_V2_1

`celldefine
module SEH_FSDNQ_V2_1 (Q, CK, D, SI, SE);
   output Q;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__CK, int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, int_res__CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff #1 (Q, viol_0, int_res__CK, int_res__D, xcr_0);
   `else
       dff (Q, viol_0, int_res__CK, int_res__D, xcr_0);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNQ_V2_1

//%BEGIN SEH_FSDNQ_V2_2

`celldefine
module SEH_FSDNQ_V2_2 (Q, CK, D, SI, SE);
   output Q;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__CK, int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, int_res__CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff #1 (Q, viol_0, int_res__CK, int_res__D, xcr_0);
   `else
       dff (Q, viol_0, int_res__CK, int_res__D, xcr_0);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNQ_V2_2

//%BEGIN SEH_FSDNQ_V2_4

`celldefine
module SEH_FSDNQ_V2_4 (Q, CK, D, SI, SE);
   output Q;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__CK, int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   not (int_res__CK, delayed_CK);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, int_res__CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff #1 (Q, viol_0, int_res__CK, int_res__D, xcr_0);
   `else
       dff (Q, viol_0, int_res__CK, int_res__D, xcr_0);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNQ_V2_4

//%BEGIN SEH_FSDNRBQ_1

`celldefine
module SEH_FSDNRBQ_1 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__CK, int_res__RD, int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_r_err (xcr_0, int_res__CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff_r #1 (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `else
       dff_r (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar, SI);
   not (SI__bar, SI);
   and (cond1, RD, SE__bar, SI__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SI);
   and (cond3, D, RD, SI__bar);
   and (cond4, D, RD, SE);
   and (cond5, D__bar, RD, SE);
   and (cond6, D, SE, SI);
   and (cond7, D, SE__bar, SI);
   and (cond8, D, SE__bar, SI__bar);
   and (cond9, D__bar, SE, SI);
   and (cond10, CK, D, SE, SI);
   and (cond11, CK, D, SE, SI__bar);
   and (cond12, CK, D, SE__bar, SI);
   and (cond13, CK, D, SE__bar, SI__bar);
   and (cond14, CK, D__bar, SE, SI);
   and (cond15, CK, D__bar, SE, SI__bar);
   and (cond16, CK, D__bar, SE__bar, SI);
   and (cond17, CK, D__bar, SE__bar, SI__bar);
   not (CK__bar, CK);
   and (cond18, CK__bar, D, SE, SI);
   and (cond19, CK__bar, SE, SI__bar);
   and (cond20, CK__bar, D, SE__bar, SI);
   and (cond21, CK__bar, D, SE__bar, SI__bar);
   and (cond22, CK__bar, D__bar, SE, SI);
   and (cond23, CK__bar, D__bar, SE__bar, SI);
   and (cond24, CK__bar, D__bar, SE__bar, SI__bar);
   and (int_twire_0, RD, SE, SI);
   and (int_twire_1, D, RD, SE__bar);
   or (cond25, int_twire_0, int_twire_1);
   and (int_twire_2, RD, SE, SI__bar);
   and (int_twire_3, D__bar, RD, SE__bar);
   or (cond26, int_twire_2, int_twire_3);

   specify
      if ((CK & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, posedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, negedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond6, negedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $recovery (posedge RD &&& cond8, negedge CK &&& cond8, 0, viol_0);
      $recovery (posedge RD &&& cond9, negedge CK &&& cond9, 0, viol_0);
      $hold (negedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond8, posedge RD &&& cond8, 0, viol_0);
      $hold (negedge CK &&& cond9, posedge RD &&& cond9, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge RD &&& cond13, 0, 0, viol_0);
      $width (negedge RD &&& cond14, 0, 0, viol_0);
      $width (negedge RD &&& cond15, 0, 0, viol_0);
      $width (negedge RD &&& cond16, 0, 0, viol_0);
      $width (negedge RD &&& cond17, 0, 0, viol_0);
      $width (negedge RD &&& cond18, 0, 0, viol_0);
      $width (negedge RD &&& cond19, 0, 0, viol_0);
      $width (negedge RD &&& cond20, 0, 0, viol_0);
      $width (negedge RD &&& cond21, 0, 0, viol_0);
      $width (negedge RD &&& cond22, 0, 0, viol_0);
      $width (negedge RD &&& cond23, 0, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (posedge CK &&& cond25, 0, 0, viol_0);
      $width (negedge CK &&& cond25, 0, 0, viol_0);
      $width (posedge CK &&& cond26, 0, 0, viol_0);
      $width (negedge CK &&& cond26, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNRBQ_1

//%BEGIN SEH_FSDNRBQ_2

`celldefine
module SEH_FSDNRBQ_2 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__CK, int_res__RD, int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_r_err (xcr_0, int_res__CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff_r #1 (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `else
       dff_r (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar, SI);
   not (SI__bar, SI);
   and (cond1, RD, SE__bar, SI__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SI);
   and (cond3, D, RD, SI__bar);
   and (cond4, D, RD, SE);
   and (cond5, D__bar, RD, SE);
   and (cond6, D, SE, SI);
   and (cond7, D, SE__bar, SI);
   and (cond8, D, SE__bar, SI__bar);
   and (cond9, D__bar, SE, SI);
   and (cond10, CK, D, SE, SI);
   and (cond11, CK, D, SE, SI__bar);
   and (cond12, CK, D, SE__bar, SI);
   and (cond13, CK, D, SE__bar, SI__bar);
   and (cond14, CK, D__bar, SE, SI);
   and (cond15, CK, D__bar, SE, SI__bar);
   and (cond16, CK, D__bar, SE__bar, SI);
   and (cond17, CK, D__bar, SE__bar, SI__bar);
   not (CK__bar, CK);
   and (cond18, CK__bar, D, SE, SI);
   and (cond19, CK__bar, SE, SI__bar);
   and (cond20, CK__bar, D, SE__bar, SI);
   and (cond21, CK__bar, D, SE__bar, SI__bar);
   and (cond22, CK__bar, D__bar, SE, SI);
   and (cond23, CK__bar, D__bar, SE__bar, SI);
   and (cond24, CK__bar, D__bar, SE__bar, SI__bar);
   and (int_twire_0, RD, SE, SI);
   and (int_twire_1, D, RD, SE__bar);
   or (cond25, int_twire_0, int_twire_1);
   and (int_twire_2, RD, SE, SI__bar);
   and (int_twire_3, D__bar, RD, SE__bar);
   or (cond26, int_twire_2, int_twire_3);

   specify
      if ((CK & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, posedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, negedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond6, negedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $recovery (posedge RD &&& cond8, negedge CK &&& cond8, 0, viol_0);
      $recovery (posedge RD &&& cond9, negedge CK &&& cond9, 0, viol_0);
      $hold (negedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond8, posedge RD &&& cond8, 0, viol_0);
      $hold (negedge CK &&& cond9, posedge RD &&& cond9, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge RD &&& cond13, 0, 0, viol_0);
      $width (negedge RD &&& cond14, 0, 0, viol_0);
      $width (negedge RD &&& cond15, 0, 0, viol_0);
      $width (negedge RD &&& cond16, 0, 0, viol_0);
      $width (negedge RD &&& cond17, 0, 0, viol_0);
      $width (negedge RD &&& cond18, 0, 0, viol_0);
      $width (negedge RD &&& cond19, 0, 0, viol_0);
      $width (negedge RD &&& cond20, 0, 0, viol_0);
      $width (negedge RD &&& cond21, 0, 0, viol_0);
      $width (negedge RD &&& cond22, 0, 0, viol_0);
      $width (negedge RD &&& cond23, 0, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (posedge CK &&& cond25, 0, 0, viol_0);
      $width (negedge CK &&& cond25, 0, 0, viol_0);
      $width (posedge CK &&& cond26, 0, 0, viol_0);
      $width (negedge CK &&& cond26, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNRBQ_2

//%BEGIN SEH_FSDNRBQ_4

`celldefine
module SEH_FSDNRBQ_4 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__CK, int_res__RD, int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_r_err (xcr_0, int_res__CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff_r #1 (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `else
       dff_r (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar, SI);
   not (SI__bar, SI);
   and (cond1, RD, SE__bar, SI__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SI);
   and (cond3, D, RD, SI__bar);
   and (cond4, D, RD, SE);
   and (cond5, D__bar, RD, SE);
   and (cond6, D, SE, SI);
   and (cond7, D, SE__bar, SI);
   and (cond8, D, SE__bar, SI__bar);
   and (cond9, D__bar, SE, SI);
   and (cond10, CK, D, SE, SI);
   and (cond11, CK, D, SE, SI__bar);
   and (cond12, CK, D, SE__bar, SI);
   and (cond13, CK, D, SE__bar, SI__bar);
   and (cond14, CK, D__bar, SE, SI);
   and (cond15, CK, D__bar, SE, SI__bar);
   and (cond16, CK, D__bar, SE__bar, SI);
   and (cond17, CK, D__bar, SE__bar, SI__bar);
   not (CK__bar, CK);
   and (cond18, CK__bar, D, SE, SI);
   and (cond19, CK__bar, SE, SI__bar);
   and (cond20, CK__bar, D, SE__bar, SI);
   and (cond21, CK__bar, D, SE__bar, SI__bar);
   and (cond22, CK__bar, D__bar, SE, SI);
   and (cond23, CK__bar, D__bar, SE__bar, SI);
   and (cond24, CK__bar, D__bar, SE__bar, SI__bar);
   and (int_twire_0, RD, SE, SI);
   and (int_twire_1, D, RD, SE__bar);
   or (cond25, int_twire_0, int_twire_1);
   and (int_twire_2, RD, SE, SI__bar);
   and (int_twire_3, D__bar, RD, SE__bar);
   or (cond26, int_twire_2, int_twire_3);

   specify
      if ((CK & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, posedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, negedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond6, negedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $recovery (posedge RD &&& cond8, negedge CK &&& cond8, 0, viol_0);
      $recovery (posedge RD &&& cond9, negedge CK &&& cond9, 0, viol_0);
      $hold (negedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond8, posedge RD &&& cond8, 0, viol_0);
      $hold (negedge CK &&& cond9, posedge RD &&& cond9, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge RD &&& cond13, 0, 0, viol_0);
      $width (negedge RD &&& cond14, 0, 0, viol_0);
      $width (negedge RD &&& cond15, 0, 0, viol_0);
      $width (negedge RD &&& cond16, 0, 0, viol_0);
      $width (negedge RD &&& cond17, 0, 0, viol_0);
      $width (negedge RD &&& cond18, 0, 0, viol_0);
      $width (negedge RD &&& cond19, 0, 0, viol_0);
      $width (negedge RD &&& cond20, 0, 0, viol_0);
      $width (negedge RD &&& cond21, 0, 0, viol_0);
      $width (negedge RD &&& cond22, 0, 0, viol_0);
      $width (negedge RD &&& cond23, 0, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (posedge CK &&& cond25, 0, 0, viol_0);
      $width (negedge CK &&& cond25, 0, 0, viol_0);
      $width (posedge CK &&& cond26, 0, 0, viol_0);
      $width (negedge CK &&& cond26, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNRBQ_4

//%BEGIN SEH_FSDNRBQ_V2_1

`celldefine
module SEH_FSDNRBQ_V2_1 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__CK, int_res__RD, int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_r_err (xcr_0, int_res__CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff_r #1 (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `else
       dff_r (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   and (int_twire_0, CK, SE, SI);
   and (int_twire_1, CK, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK, SE, SI__bar);
   and (int_twire_3, CK, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if ((CK & D & SE & SI) | (CK & D & ~(SE)) | (CK & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & SE & ~(SI)) | (CK & ~(D) & SE & ~(SI)) | (CK & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if (~(CK))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, negedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, negedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (negedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (negedge RD &&& ~CK, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNRBQ_V2_1

//%BEGIN SEH_FSDNRBQ_V2_2

`celldefine
module SEH_FSDNRBQ_V2_2 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__CK, int_res__RD, int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_r_err (xcr_0, int_res__CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff_r #1 (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `else
       dff_r (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   and (int_twire_0, CK, SE, SI);
   and (int_twire_1, CK, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK, SE, SI__bar);
   and (int_twire_3, CK, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if ((CK & D & SE & SI) | (CK & D & ~(SE)) | (CK & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & SE & ~(SI)) | (CK & ~(D) & SE & ~(SI)) | (CK & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if (~(CK))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, negedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, negedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (negedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (negedge RD &&& ~CK, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNRBQ_V2_2

//%BEGIN SEH_FSDNRBQ_V2_4

`celldefine
module SEH_FSDNRBQ_V2_4 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__CK, int_res__RD, int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   not (int_res__CK, delayed_CK);
   not (int_res__RD, delayed_RD);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_r_err (xcr_0, int_res__CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       dff_r #1 (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `else
       dff_r (Q, viol_0, int_res__CK, int_res__D, int_res__RD, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, int_twire_7;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   and (int_twire_0, CK, SE, SI);
   and (int_twire_1, CK, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK, SE, SI__bar);
   and (int_twire_3, CK, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if ((CK & D & SE & SI) | (CK & D & ~(SE)) | (CK & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & SE & ~(SI)) | (CK & ~(D) & SE & ~(SI)) | (CK & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if (~(CK))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, negedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, negedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (negedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (negedge RD &&& ~CK, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNRBQ_V2_4

//%BEGIN SEH_FSDNRBSBQO_1

`celldefine
module SEH_FSDNRBSBQO_1 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__CK, int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);


   not (int_res__CK, delayed_CK);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, int_res__CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, int_res__CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   and (int_twire_0, CK, SE, SI);
   and (int_twire_1, CK, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK, SE, SI__bar);
   and (int_twire_3, CK, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, CK, SD, SE, SI);
   and (int_twire_5, CK, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, CK, SD, SE, SI__bar);
   and (int_twire_7, CK, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);
   not (CK__bar, CK);
   and (cond12, CK__bar, SD);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (int_twire_8, CK, RD, SE, SI);
   and (int_twire_9, CK, D, RD, SE__bar);
   or (cond16, int_twire_8, int_twire_9);
   and (int_twire_10, CK, RD, SE, SI__bar);
   and (int_twire_11, CK, D__bar, RD, SE__bar);
   or (cond17, int_twire_10, int_twire_11);
   and (cond18, CK__bar, RD);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & SD & SE & SI) | (CK & D & SD & ~(SE)) | (CK & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & SD & SE & ~(SI)) | (CK & ~(D) & SD & SE & ~(SI)) | (CK & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & RD & SE & SI) | (CK & D & RD & ~(SE)) | (CK & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & D & RD & SE & ~(SI)) | (CK & ~(D) & RD & SE & ~(SI)) | (CK & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & D & SD & SE & SI) | (CK & D & SD & ~(SE)) | (CK & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & SD & SE & ~(SI)) | (CK & ~(D) & SD & SE & ~(SI)) | (CK & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & RD & SE & SI) | (CK & D & RD & ~(SE)) | (CK & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & D & RD & SE & ~(SI)) | (CK & ~(D) & RD & SE & ~(SI)) | (CK & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      (negedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& ~CK, posedge RD &&& ~CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& ~CK, posedge SD &&& ~CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, negedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, negedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (negedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, negedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, negedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, negedge CK &&& cond15, 0, viol_0);
      $hold (negedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (negedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (negedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNRBSBQO_1

//%BEGIN SEH_FSDNRBSBQO_2

`celldefine
module SEH_FSDNRBSBQO_2 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__CK, int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);


   not (int_res__CK, delayed_CK);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, int_res__CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, int_res__CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   and (int_twire_0, CK, SE, SI);
   and (int_twire_1, CK, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK, SE, SI__bar);
   and (int_twire_3, CK, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, CK, SD, SE, SI);
   and (int_twire_5, CK, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, CK, SD, SE, SI__bar);
   and (int_twire_7, CK, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);
   not (CK__bar, CK);
   and (cond12, CK__bar, SD);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (int_twire_8, CK, RD, SE, SI);
   and (int_twire_9, CK, D, RD, SE__bar);
   or (cond16, int_twire_8, int_twire_9);
   and (int_twire_10, CK, RD, SE, SI__bar);
   and (int_twire_11, CK, D__bar, RD, SE__bar);
   or (cond17, int_twire_10, int_twire_11);
   and (cond18, CK__bar, RD);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & SD & SE & SI) | (CK & D & SD & ~(SE)) | (CK & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & SD & SE & ~(SI)) | (CK & ~(D) & SD & SE & ~(SI)) | (CK & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & RD & SE & SI) | (CK & D & RD & ~(SE)) | (CK & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & D & RD & SE & ~(SI)) | (CK & ~(D) & RD & SE & ~(SI)) | (CK & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & D & SD & SE & SI) | (CK & D & SD & ~(SE)) | (CK & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & SD & SE & ~(SI)) | (CK & ~(D) & SD & SE & ~(SI)) | (CK & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & RD & SE & SI) | (CK & D & RD & ~(SE)) | (CK & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & D & RD & SE & ~(SI)) | (CK & ~(D) & RD & SE & ~(SI)) | (CK & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      (negedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& ~CK, posedge RD &&& ~CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& ~CK, posedge SD &&& ~CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, negedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, negedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (negedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, negedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, negedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, negedge CK &&& cond15, 0, viol_0);
      $hold (negedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (negedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (negedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNRBSBQO_2

//%BEGIN SEH_FSDNRBSBQO_4

`celldefine
module SEH_FSDNRBSBQO_4 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__CK, int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);


   not (int_res__CK, delayed_CK);
   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, int_res__CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, int_res__CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   and (int_twire_0, CK, SE, SI);
   and (int_twire_1, CK, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK, SE, SI__bar);
   and (int_twire_3, CK, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, CK, SD, SE, SI);
   and (int_twire_5, CK, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, CK, SD, SE, SI__bar);
   and (int_twire_7, CK, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);
   not (CK__bar, CK);
   and (cond12, CK__bar, SD);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (int_twire_8, CK, RD, SE, SI);
   and (int_twire_9, CK, D, RD, SE__bar);
   or (cond16, int_twire_8, int_twire_9);
   and (int_twire_10, CK, RD, SE, SI__bar);
   and (int_twire_11, CK, D__bar, RD, SE__bar);
   or (cond17, int_twire_10, int_twire_11);
   and (cond18, CK__bar, RD);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & SD & SE & SI) | (CK & D & SD & ~(SE)) | (CK & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & SD & SE & ~(SI)) | (CK & ~(D) & SD & SE & ~(SI)) | (CK & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & RD & SE & SI) | (CK & D & RD & ~(SE)) | (CK & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & D & RD & SE & ~(SI)) | (CK & ~(D) & RD & SE & ~(SI)) | (CK & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      (negedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & D & SD & SE & SI) | (CK & D & SD & ~(SE)) | (CK & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & SD & SE & ~(SI)) | (CK & ~(D) & SD & SE & ~(SI)) | (CK & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & RD & SE & SI) | (CK & D & RD & ~(SE)) | (CK & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & D & RD & SE & ~(SI)) | (CK & ~(D) & RD & SE & ~(SI)) | (CK & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      (negedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (negedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (negedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (negedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (negedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& ~CK, posedge RD &&& ~CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& ~CK, posedge SD &&& ~CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, negedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, negedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, negedge CK &&& cond7, 0, viol_0);
      $hold (negedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (negedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (negedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, negedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, negedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, negedge CK &&& cond15, 0, viol_0);
      $hold (negedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (negedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (negedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDNRBSBQO_4

//%BEGIN SEH_FSDPC1BQO_1

`celldefine
module SEH_FSDPC1BQO_1 (Q, SO, CK, D, SI, SE, RS);
   output Q,  SO;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire RS__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, RS, SE);
   and (cond9, D__bar, RS__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond10, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond11, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D && RS)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D && RS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPC1BQO_1

//%BEGIN SEH_FSDPC1BQO_2

`celldefine
module SEH_FSDPC1BQO_2 (Q, SO, CK, D, SI, SE, RS);
   output Q,  SO;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire RS__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, RS, SE);
   and (cond9, D__bar, RS__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond10, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond11, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D && RS)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D && RS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPC1BQO_2

//%BEGIN SEH_FSDPC1BQO_4

`celldefine
module SEH_FSDPC1BQO_4 (Q, SO, CK, D, SI, SE, RS);
   output Q,  SO;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire RS__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, RS, SE);
   and (cond9, D__bar, RS__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond10, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond11, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D && RS)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D && RS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPC1BQO_4

//%BEGIN SEH_FSDPC1BQO_D_1

`celldefine
module SEH_FSDPC1BQO_D_1 (Q, SO, CK, D, SI, SE, RS);
   output Q,  SO;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, RS__bar;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond9, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond10, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((D && SE && SI) || (D && !(SE) && RS) || (!(D) && SE && SI)))) = 1;
      (posedge CK => (SO-:((D && SE && SI) || (D && !(SE) && RS) || (!(D) && SE && SI)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPC1BQO_D_1

//%BEGIN SEH_FSDPC1BQO_D_2

`celldefine
module SEH_FSDPC1BQO_D_2 (Q, SO, CK, D, SI, SE, RS);
   output Q,  SO;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, RS__bar;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond9, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond10, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((D && SE && SI) || (D && !(SE) && RS) || (!(D) && SE && SI)))) = 1;
      (posedge CK => (SO-:((D && SE && SI) || (D && !(SE) && RS) || (!(D) && SE && SI)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPC1BQO_D_2

//%BEGIN SEH_FSDPC1BQO_D_4

`celldefine
module SEH_FSDPC1BQO_D_4 (Q, SO, CK, D, SI, SE, RS);
   output Q,  SO;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, RS__bar;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond9, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond10, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((D && SE && SI) || (D && !(SE) && RS) || (!(D) && SE && SI)))) = 1;
      (posedge CK => (SO-:((D && SE && SI) || (D && !(SE) && RS) || (!(D) && SE && SI)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPC1BQO_D_4

//%BEGIN SEH_FSDPC1BQ_D_1

`celldefine
module SEH_FSDPC1BQ_D_1 (Q, CK, D, SI, SE, RS);
   output Q;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   
   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, RS__bar;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond9, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond10, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((D && SE && SI) || (D && !(SE) && RS) || (!(D) && SE && SI)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif   
endmodule
`endcelldefine

//%END SEH_FSDPC1BQ_D_1

//%BEGIN SEH_FSDPC1BQ_D_2

`celldefine
module SEH_FSDPC1BQ_D_2 (Q, CK, D, SI, SE, RS);
   output Q;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   
   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, RS__bar;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond9, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond10, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((D && SE && SI) || (D && !(SE) && RS) || (!(D) && SE && SI)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif   
endmodule
`endcelldefine

//%END SEH_FSDPC1BQ_D_2

//%BEGIN SEH_FSDPC1BQ_D_4

`celldefine
module SEH_FSDPC1BQ_D_4 (Q, CK, D, SI, SE, RS);
   output Q;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   
   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, RS__bar;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond9, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond10, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((D && SE && SI) || (D && !(SE) && RS) || (!(D) && SE && SI)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif   
endmodule
`endcelldefine

//%END SEH_FSDPC1BQ_D_4

//%BEGIN SEH_FSDPC1BQ_V2_1

`celldefine
module SEH_FSDPC1BQ_V2_1 (Q, CK, D, SI, SE, RS);
   output Q;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   
   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, RS__bar;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond9, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond10, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D && RS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif   
endmodule
`endcelldefine

//%END SEH_FSDPC1BQ_V2_1

//%BEGIN SEH_FSDPC1BQ_V2_1P5

`celldefine
module SEH_FSDPC1BQ_V2_1P5 (Q, CK, D, SI, SE, RS);
   output Q;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   
   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, RS__bar;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond9, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond10, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D && RS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif   
endmodule
`endcelldefine

//%END SEH_FSDPC1BQ_V2_1P5

//%BEGIN SEH_FSDPC1BQ_V2_2

`celldefine
module SEH_FSDPC1BQ_V2_2 (Q, CK, D, SI, SE, RS);
   output Q;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   
   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, RS__bar;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond9, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond10, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D && RS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif   
endmodule
`endcelldefine

//%END SEH_FSDPC1BQ_V2_2

//%BEGIN SEH_FSDPC1BQ_V2_3

`celldefine
module SEH_FSDPC1BQ_V2_3 (Q, CK, D, SI, SE, RS);
   output Q;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   
   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, RS__bar;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond9, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond10, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D && RS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif   
endmodule
`endcelldefine

//%END SEH_FSDPC1BQ_V2_3

//%BEGIN SEH_FSDPC1BQ_V2_4

`celldefine
module SEH_FSDPC1BQ_V2_4 (Q, CK, D, SI, SE, RS);
   output Q;
   input CK, D, SI, SE, RS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RS;

   wire int_res__D, int_res__RS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RS, RS);
`endif

   and (int_res__D, delayed_D, delayed_RS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   
   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, RS__bar;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RS, SE__bar);
   and (cond1, D, SE__bar);
   not (RS__bar, RS);
   and (cond2, D, RS__bar, SI);
   not (D__bar, D);
   and (cond3, D__bar, RS, SI);
   and (cond4, D__bar, RS__bar, SI);
   not (SI__bar, SI);
   and (cond5, D, RS, SI__bar);
   and (cond6, D, RS, SE);
   and (cond7, D, RS__bar, SE);
   and (cond8, D__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D, RS, SE__bar);
   or (cond9, int_twire_0, int_twire_1);
   and (int_twire_2, SE, SI__bar);
   and (int_twire_3, D__bar, RS, SE__bar);
   and (int_twire_4, RS__bar, SE__bar);
   or (cond10, int_twire_2, int_twire_3, int_twire_4);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D && RS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond1, negedge RS &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_RS);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif   
endmodule
`endcelldefine

//%END SEH_FSDPC1BQ_V2_4

//%BEGIN SEH_FSDPHQO_1

`celldefine
module SEH_FSDPHQO_1 (Q, SO, CK, D, SI, SE, EN);
   output Q, SO;
   input CK, D, SI, SE, EN;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_EN;

   wire int_res__D, int_res__S, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_EN, EN);
`endif

   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);
   dff (int_res_iq, viol_0, delayed_CK, int_res__S, xcr_0);


   `ifdef VIRL_functiononly
      buf #1 (Q, int_res_iq);
      buf #1 (SO, int_res_iq);
   `else
      buf (Q, int_res_iq);
      buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire D__bar, EN__bar, SE__bar;
   wire SI__bar;


   // Additional timing gates
   not (EN__bar, EN);
   not (SE__bar, SE);
   and (cond0, EN__bar, SE__bar);
   and (cond1, D, SE__bar);
   not (D__bar, D);
   and (cond2, D__bar, SE__bar);
   and (cond3, D, EN, SI);
   and (cond4, D__bar, EN, SI);
   and (cond5, D__bar, EN__bar, SI);
   not (SI__bar, SI);
   and (cond6, D, EN, SI__bar);
   and (cond7, D, EN__bar, SI__bar);
   and (cond8, D__bar, EN, SI__bar);
   and (cond9, D, SE);
   and (cond10, D__bar, SE);
   and (cond11, SE, SI);
   and (cond12, D, EN__bar, SE__bar);
   and (cond13, SE, SI__bar);
   and (cond14, D__bar, EN__bar, SE__bar);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && EN && Q) || (!(SE) && !(EN) && D)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && EN && Q) || (!(SE) && !(EN) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, posedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, negedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
      $width (posedge CK &&& cond12, 0, 0, viol_0);
      $width (negedge CK &&& cond12, 0, 0, viol_0);
      $width (posedge CK &&& cond13, 0, 0, viol_0);
      $width (negedge CK &&& cond13, 0, 0, viol_0);
      $width (posedge CK &&& cond14, 0, 0, viol_0);
      $width (negedge CK &&& cond14, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPHQO_1

//%BEGIN SEH_FSDPHQO_2

`celldefine
module SEH_FSDPHQO_2 (Q, SO, CK, D, SI, SE, EN);
   output Q, SO;
   input CK, D, SI, SE, EN;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_EN;

   wire int_res__D, int_res__S, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_EN, EN);
`endif

   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);
   dff (int_res_iq, viol_0, delayed_CK, int_res__S, xcr_0);


   `ifdef VIRL_functiononly
      buf #1 (Q, int_res_iq);
      buf #1 (SO, int_res_iq);
   `else
      buf (Q, int_res_iq);
      buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire D__bar, EN__bar, SE__bar;
   wire SI__bar;


   // Additional timing gates
   not (EN__bar, EN);
   not (SE__bar, SE);
   and (cond0, EN__bar, SE__bar);
   and (cond1, D, SE__bar);
   not (D__bar, D);
   and (cond2, D__bar, SE__bar);
   and (cond3, D, EN, SI);
   and (cond4, D__bar, EN, SI);
   and (cond5, D__bar, EN__bar, SI);
   not (SI__bar, SI);
   and (cond6, D, EN, SI__bar);
   and (cond7, D, EN__bar, SI__bar);
   and (cond8, D__bar, EN, SI__bar);
   and (cond9, D, SE);
   and (cond10, D__bar, SE);
   and (cond11, SE, SI);
   and (cond12, D, EN__bar, SE__bar);
   and (cond13, SE, SI__bar);
   and (cond14, D__bar, EN__bar, SE__bar);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && EN && Q) || (!(SE) && !(EN) && D)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && EN && Q) || (!(SE) && !(EN) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, posedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, negedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
      $width (posedge CK &&& cond12, 0, 0, viol_0);
      $width (negedge CK &&& cond12, 0, 0, viol_0);
      $width (posedge CK &&& cond13, 0, 0, viol_0);
      $width (negedge CK &&& cond13, 0, 0, viol_0);
      $width (posedge CK &&& cond14, 0, 0, viol_0);
      $width (negedge CK &&& cond14, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPHQO_2

//%BEGIN SEH_FSDPHQO_D_2

`celldefine
module SEH_FSDPHQO_D_2 (Q, SO, CK, D, SI, SE, EN);
   output Q, SO;
   input CK, D, SI, SE, EN;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_EN;

   wire int_res__D, int_res__S, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_EN, EN);
`endif

   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);
   dff (int_res_iq, viol_0, delayed_CK, int_res__S, xcr_0);


   `ifdef VIRL_functiononly
      buf #1 (Q, int_res_iq);
      buf #1 (SO, int_res_iq);
   `else
      buf (Q, int_res_iq);
      buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire D__bar, EN__bar, SE__bar;
   wire SI__bar;


   // Additional timing gates
   not (EN__bar, EN);
   not (SE__bar, SE);
   and (cond0, EN__bar, SE__bar);
   and (cond1, D, SE__bar);
   not (D__bar, D);
   and (cond2, D__bar, SE__bar);
   and (cond3, D, EN, SI);
   and (cond4, D__bar, EN, SI);
   and (cond5, D__bar, EN__bar, SI);
   not (SI__bar, SI);
   and (cond6, D, EN, SI__bar);
   and (cond7, D, EN__bar, SI__bar);
   and (cond8, D__bar, EN, SI__bar);
   and (cond9, D, EN, SE);
   and (cond10, D, EN__bar, SE);
   and (cond11, D__bar, EN, SE);
   and (cond12, D__bar, EN__bar, SE);
   and (cond13, D, EN, SE, SI);
   and (cond14, EN__bar, SE, SI);
   and (cond15, D, EN__bar, SE__bar);
   and (cond16, D__bar, EN, SE, SI);
   and (cond17, D, EN, SE, SI__bar);
   and (cond18, EN__bar, SE, SI__bar);
   and (cond19, D__bar, EN, SE, SI__bar);
   and (cond20, D__bar, EN__bar, SE__bar);

   specify
      (posedge CK => (Q+:((Q && D && SE && SI) || (Q && D && !(SE)) || (Q && !(D) && EN && SE && SI) || (Q && !(D) && EN && !(SE)) || (Q && !(D) && !(EN) && SE && SI) || (!(Q) && D && EN && SE && SI) || (!(Q) && D && !(EN) && SE && SI) || (!(Q) && D && !(EN) && !(SE)) || (!(Q) && !(D) && SE && SI)))) = 1;
      (posedge CK => (SO-:((Q && D && SE && SI) || (Q && D && !(SE)) || (Q && !(D) && EN && SE && SI) || (Q && !(D) && EN && !(SE)) || (Q && !(D) && !(EN) && SE && SI) || (!(Q) && D && EN && SE && SI) || (!(Q) && D && !(EN) && SE && SI) || (!(Q) && D && !(EN) && !(SE)) || (!(Q) && !(D) && SE && SI)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, posedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, negedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, posedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, negedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, posedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, negedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond13, 0, 0, viol_0);
      $width (negedge CK &&& cond13, 0, 0, viol_0);
      $width (posedge CK &&& cond14, 0, 0, viol_0);
      $width (negedge CK &&& cond14, 0, 0, viol_0);
      $width (posedge CK &&& cond15, 0, 0, viol_0);
      $width (negedge CK &&& cond15, 0, 0, viol_0);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
      $width (posedge CK &&& cond18, 0, 0, viol_0);
      $width (negedge CK &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPHQO_D_2

//%BEGIN SEH_FSDPHQ_D_1

`celldefine
module SEH_FSDPHQ_D_1 (Q, CK, D, SI, SE, EN);
   output Q;
   input CK, D, SI, SE, EN;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_EN;

   wire int_res__D, int_res__S, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_EN, EN);
`endif

   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);
   dff (int_res_iq, viol_0, delayed_CK, int_res__S, xcr_0);
   

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
   `else
       buf (Q, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire D__bar, EN__bar, SE__bar;
   wire SI__bar;


   // Additional timing gates
   not (EN__bar, EN);
   not (SE__bar, SE);
   and (cond0, EN__bar, SE__bar);
   and (cond1, D, SE__bar);
   not (D__bar, D);
   and (cond2, D__bar, SE__bar);
   and (cond3, D, EN, SI);
   and (cond4, D__bar, EN, SI);
   and (cond5, D__bar, EN__bar, SI);
   not (SI__bar, SI);
   and (cond6, D, EN, SI__bar);
   and (cond7, D, EN__bar, SI__bar);
   and (cond8, D__bar, EN, SI__bar);
   and (cond9, D, EN, SE);
   and (cond10, D, EN__bar, SE);
   and (cond11, D__bar, EN, SE);
   and (cond12, D__bar, EN__bar, SE);
   and (cond13, D, EN, SE, SI);
   and (cond14, EN__bar, SE, SI);
   and (cond15, D, EN__bar, SE__bar);
   and (cond16, D__bar, EN, SE, SI);
   and (cond17, D, EN, SE, SI__bar);
   and (cond18, EN__bar, SE, SI__bar);
   and (cond19, D__bar, EN, SE, SI__bar);
   and (cond20, D__bar, EN__bar, SE__bar);

   specify
      (posedge CK => (Q+:((Q && SE && SI) || (Q && !(SE) && D) || (Q && !(SE) && !(D) && EN) || (!(Q) && SE && SI) || (!(Q) && !(SE) && D && !(EN))))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, posedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, negedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, posedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, negedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, posedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, negedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond13, 0, 0, viol_0);
      $width (negedge CK &&& cond13, 0, 0, viol_0);
      $width (posedge CK &&& cond14, 0, 0, viol_0);
      $width (negedge CK &&& cond14, 0, 0, viol_0);
      $width (posedge CK &&& cond15, 0, 0, viol_0);
      $width (negedge CK &&& cond15, 0, 0, viol_0);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
      $width (posedge CK &&& cond18, 0, 0, viol_0);
      $width (negedge CK &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPHQ_D_1

//%BEGIN SEH_FSDPHQ_D_2

`celldefine
module SEH_FSDPHQ_D_2 (Q, CK, D, SI, SE, EN);
   output Q;
   input CK, D, SI, SE, EN;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_EN;

   wire int_res__D, int_res__S, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_EN, EN);
`endif

   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);
   dff (int_res_iq, viol_0, delayed_CK, int_res__S, xcr_0);
   

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
   `else
       buf (Q, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire D__bar, EN__bar, SE__bar;
   wire SI__bar;


   // Additional timing gates
   not (EN__bar, EN);
   not (SE__bar, SE);
   and (cond0, EN__bar, SE__bar);
   and (cond1, D, SE__bar);
   not (D__bar, D);
   and (cond2, D__bar, SE__bar);
   and (cond3, D, EN, SI);
   and (cond4, D__bar, EN, SI);
   and (cond5, D__bar, EN__bar, SI);
   not (SI__bar, SI);
   and (cond6, D, EN, SI__bar);
   and (cond7, D, EN__bar, SI__bar);
   and (cond8, D__bar, EN, SI__bar);
   and (cond9, D, EN, SE);
   and (cond10, D, EN__bar, SE);
   and (cond11, D__bar, EN, SE);
   and (cond12, D__bar, EN__bar, SE);
   and (cond13, D, EN, SE, SI);
   and (cond14, EN__bar, SE, SI);
   and (cond15, D, EN__bar, SE__bar);
   and (cond16, D__bar, EN, SE, SI);
   and (cond17, D, EN, SE, SI__bar);
   and (cond18, EN__bar, SE, SI__bar);
   and (cond19, D__bar, EN, SE, SI__bar);
   and (cond20, D__bar, EN__bar, SE__bar);

   specify
      (posedge CK => (Q+:((Q && SE && SI) || (Q && !(SE) && D) || (Q && !(SE) && !(D) && EN) || (!(Q) && SE && SI) || (!(Q) && !(SE) && D && !(EN))))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, posedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, negedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, posedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, negedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, posedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, negedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond13, 0, 0, viol_0);
      $width (negedge CK &&& cond13, 0, 0, viol_0);
      $width (posedge CK &&& cond14, 0, 0, viol_0);
      $width (negedge CK &&& cond14, 0, 0, viol_0);
      $width (posedge CK &&& cond15, 0, 0, viol_0);
      $width (negedge CK &&& cond15, 0, 0, viol_0);
      $width (posedge CK &&& cond16, 0, 0, viol_0);
      $width (negedge CK &&& cond16, 0, 0, viol_0);
      $width (posedge CK &&& cond17, 0, 0, viol_0);
      $width (negedge CK &&& cond17, 0, 0, viol_0);
      $width (posedge CK &&& cond18, 0, 0, viol_0);
      $width (negedge CK &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPHQ_D_2

//%BEGIN SEH_FSDPHRBSBQO_1

`celldefine
module SEH_FSDPHRBSBQO_1 (Q, SO, CK, D, SI, SE, EN, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, EN, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_EN, delayed_RD,
        delayed_SD;
   wire int_res__D, int_res__S, int_res__RD, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_EN, EN);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);


   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   not (int_res__RD, delayed_RD);
   not (int_res__SD, delayed_SD);
   dff_sr_err (xcr_0, delayed_CK, int_res__S, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__S, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, cond27, cond28;
   wire cond29, cond30, cond31;
   wire cond32, cond33, cond34;
   wire cond35, cond36, cond37;
   wire cond38, cond39, cond40;
   wire cond41, cond42, cond43;
   wire cond44, cond45, cond46;
   wire cond47, cond48, cond49;
   wire cond50, cond51, cond52;
   wire D__bar, EN__bar, int_twire_0;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (EN__bar, EN);
   not (SE__bar, SE);
   and (cond0, EN__bar, RD, SD, SE__bar);
   and (cond1, D, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SD, SE__bar);
   and (cond3, D, EN, RD, SD, SI);
   and (cond4, D__bar, EN, RD, SD, SI);
   and (cond5, D__bar, EN__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond6, D, EN, RD, SD, SI__bar);
   and (cond7, D, EN__bar, RD, SD, SI__bar);
   and (cond8, D__bar, EN, RD, SD, SI__bar);
   and (cond9, D, RD, SD, SE);
   and (cond10, D__bar, RD, SD, SE);
   and (cond11, D, SD, SE, SI);
   and (cond12, D, EN__bar, SD, SE__bar);
   and (cond13, D__bar, SD, SE, SI);
   and (cond14, CK, SE);
   and (cond15, CK, D, EN, SE__bar);
   and (cond16, CK, EN__bar, SE__bar);
   and (cond17, CK, D__bar, EN, SE__bar);
   not (CK__bar, CK);
   and (cond18, CK__bar, SE, SI);
   and (cond19, CK__bar, SE, SI__bar);
   and (cond20, CK__bar, D, EN, SE__bar);
   and (cond21, CK__bar, D, EN__bar, SE__bar);
   and (cond22, CK__bar, D__bar, EN, SE__bar);
   and (cond23, CK__bar, D__bar, EN__bar, SE__bar);
   and (cond24, CK, SD, SE);
   and (cond25, CK, D, EN, SD, SE__bar);
   and (cond26, CK, EN__bar, SD, SE__bar);
   and (cond27, CK, D__bar, EN, SD, SE__bar);
   and (cond28, CK__bar, SD, SE, SI);
   and (cond29, CK__bar, SD, SE, SI__bar);
   and (cond30, CK__bar, D, EN, SD, SE__bar);
   and (cond31, CK__bar, D, EN__bar, SD, SE__bar);
   and (cond32, CK__bar, D__bar, EN, SD, SE__bar);
   and (cond33, CK__bar, D__bar, EN__bar, SD, SE__bar);
   and (cond34, D, RD, SE, SI__bar);
   and (cond35, D__bar, RD, SE, SI__bar);
   and (cond36, D__bar, EN__bar, RD, SE__bar);
   and (int_twire_0, CK__bar, EN, SE__bar);
   or (cond37, cond19, int_twire_0, cond23);
   or (cond38, cond18, cond21);
   and (cond39, CK, RD, SE);
   and (cond40, CK, D, EN, RD, SE__bar);
   and (cond41, CK, EN__bar, RD, SE__bar);
   and (cond42, CK, D__bar, EN, RD, SE__bar);
   and (cond43, CK__bar, RD, SE, SI);
   and (cond44, CK__bar, RD, SE, SI__bar);
   and (cond45, CK__bar, D, EN, RD, SE__bar);
   and (cond46, CK__bar, D, EN__bar, RD, SE__bar);
   and (cond47, CK__bar, D__bar, EN, RD, SE__bar);
   and (cond48, CK__bar, D__bar, EN__bar, RD, SE__bar);
   and (cond49, RD, SD, SE, SI);
   and (cond50, D, EN__bar, RD, SD, SE__bar);
   and (cond51, RD, SD, SE, SI__bar);
   and (cond52, D__bar, EN__bar, RD, SD, SE__bar);

   specify
      if ((CK & ~(SD) & SE))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD) & SE))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(EN) & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD) & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SD & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD) & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(EN) & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD & SE))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & RD & SE & ~(SI)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((Q && SE && SI) || (Q && !(SE) && D) || (Q && !(SE) && !(D) && EN) || (!(Q) && SE && SI) || (!(Q) && !(SE) && D && !(EN))))) = 1;
      if ((CK & ~(SD) & SE))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & D & EN & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & ~(EN) & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & ~(D) & EN & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD) & SE))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & EN & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(EN) & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & SD & SE))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD) & SE))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & EN & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(EN) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(EN) & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & EN & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & SD & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD) & SE))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & EN & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(EN) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(EN) & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & RD & SE))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & D & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & ~(EN) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & RD & SE & ~(SI)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & ~(EN) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((Q && SE && SI) || (Q && !(SE) && D) || (Q && !(SE) && !(D) && EN) || (!(Q) && SE && SI) || (!(Q) && !(SE) && D && !(EN))))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, posedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, negedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& cond14, posedge RD &&& cond14, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond15, posedge RD &&& cond15, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond16, posedge RD &&& cond16, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond17, posedge RD &&& cond17, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond18, posedge RD &&& cond18, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond19, posedge RD &&& cond19, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond20, posedge RD &&& cond20, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond21, posedge RD &&& cond21, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond22, posedge RD &&& cond22, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond23, posedge RD &&& cond23, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond37, posedge SD &&& cond37, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond38, posedge SD &&& cond38, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond11, posedge CK &&& cond11, 0, viol_0);
      $recovery (posedge RD &&& cond12, posedge CK &&& cond12, 0, viol_0);
      $recovery (posedge RD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond11, posedge RD &&& cond11, 0, viol_0);
      $hold (posedge CK &&& cond12, posedge RD &&& cond12, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge RD &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond34, posedge CK &&& cond34, 0, viol_0);
      $recovery (posedge SD &&& cond35, posedge CK &&& cond35, 0, viol_0);
      $recovery (posedge SD &&& cond36, posedge CK &&& cond36, 0, viol_0);
      $hold (posedge CK &&& cond34, posedge SD &&& cond34, 0, viol_0);
      $hold (posedge CK &&& cond35, posedge SD &&& cond35, 0, viol_0);
      $hold (posedge CK &&& cond36, posedge SD &&& cond36, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (negedge RD &&& cond25, 0, 0, viol_0);
      $width (negedge RD &&& cond26, 0, 0, viol_0);
      $width (negedge RD &&& cond27, 0, 0, viol_0);
      $width (negedge RD &&& cond28, 0, 0, viol_0);
      $width (negedge RD &&& cond29, 0, 0, viol_0);
      $width (negedge RD &&& cond30, 0, 0, viol_0);
      $width (negedge RD &&& cond31, 0, 0, viol_0);
      $width (negedge RD &&& cond32, 0, 0, viol_0);
      $width (negedge RD &&& cond33, 0, 0, viol_0);
      $width (negedge SD &&& cond39, 0, 0, viol_0);
      $width (negedge SD &&& cond40, 0, 0, viol_0);
      $width (negedge SD &&& cond41, 0, 0, viol_0);
      $width (negedge SD &&& cond42, 0, 0, viol_0);
      $width (negedge SD &&& cond43, 0, 0, viol_0);
      $width (negedge SD &&& cond44, 0, 0, viol_0);
      $width (negedge SD &&& cond45, 0, 0, viol_0);
      $width (negedge SD &&& cond46, 0, 0, viol_0);
      $width (negedge SD &&& cond47, 0, 0, viol_0);
      $width (negedge SD &&& cond48, 0, 0, viol_0);
      $width (posedge CK &&& cond49, 0, 0, viol_0);
      $width (negedge CK &&& cond49, 0, 0, viol_0);
      $width (posedge CK &&& cond50, 0, 0, viol_0);
      $width (negedge CK &&& cond50, 0, 0, viol_0);
      $width (posedge CK &&& cond51, 0, 0, viol_0);
      $width (negedge CK &&& cond51, 0, 0, viol_0);
      $width (posedge CK &&& cond52, 0, 0, viol_0);
      $width (negedge CK &&& cond52, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPHRBSBQO_1

//%BEGIN SEH_FSDPHRBSBQO_2

`celldefine
module SEH_FSDPHRBSBQO_2 (Q, SO, CK, D, SI, SE, EN, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, EN, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_EN, delayed_RD,
        delayed_SD;
   wire int_res__D, int_res__S, int_res__RD, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_EN, EN);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);


   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   not (int_res__RD, delayed_RD);
   not (int_res__SD, delayed_SD);
   dff_sr_err (xcr_0, delayed_CK, int_res__S, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__S, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, cond27, cond28;
   wire cond29, cond30, cond31;
   wire cond32, cond33, cond34;
   wire cond35, cond36, cond37;
   wire cond38, cond39, cond40;
   wire cond41, cond42, cond43;
   wire cond44, cond45, cond46;
   wire cond47, cond48, cond49;
   wire cond50, cond51, cond52;
   wire D__bar, EN__bar, int_twire_0;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (EN__bar, EN);
   not (SE__bar, SE);
   and (cond0, EN__bar, RD, SD, SE__bar);
   and (cond1, D, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SD, SE__bar);
   and (cond3, D, EN, RD, SD, SI);
   and (cond4, D__bar, EN, RD, SD, SI);
   and (cond5, D__bar, EN__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond6, D, EN, RD, SD, SI__bar);
   and (cond7, D, EN__bar, RD, SD, SI__bar);
   and (cond8, D__bar, EN, RD, SD, SI__bar);
   and (cond9, D, RD, SD, SE);
   and (cond10, D__bar, RD, SD, SE);
   and (cond11, D, SD, SE, SI);
   and (cond12, D, EN__bar, SD, SE__bar);
   and (cond13, D__bar, SD, SE, SI);
   and (cond14, CK, SE);
   and (cond15, CK, D, EN, SE__bar);
   and (cond16, CK, EN__bar, SE__bar);
   and (cond17, CK, D__bar, EN, SE__bar);
   not (CK__bar, CK);
   and (cond18, CK__bar, SE, SI);
   and (cond19, CK__bar, SE, SI__bar);
   and (cond20, CK__bar, D, EN, SE__bar);
   and (cond21, CK__bar, D, EN__bar, SE__bar);
   and (cond22, CK__bar, D__bar, EN, SE__bar);
   and (cond23, CK__bar, D__bar, EN__bar, SE__bar);
   and (cond24, CK, SD, SE);
   and (cond25, CK, D, EN, SD, SE__bar);
   and (cond26, CK, EN__bar, SD, SE__bar);
   and (cond27, CK, D__bar, EN, SD, SE__bar);
   and (cond28, CK__bar, SD, SE, SI);
   and (cond29, CK__bar, SD, SE, SI__bar);
   and (cond30, CK__bar, D, EN, SD, SE__bar);
   and (cond31, CK__bar, D, EN__bar, SD, SE__bar);
   and (cond32, CK__bar, D__bar, EN, SD, SE__bar);
   and (cond33, CK__bar, D__bar, EN__bar, SD, SE__bar);
   and (cond34, D, RD, SE, SI__bar);
   and (cond35, D__bar, RD, SE, SI__bar);
   and (cond36, D__bar, EN__bar, RD, SE__bar);
   and (int_twire_0, CK__bar, EN, SE__bar);
   or (cond37, cond19, int_twire_0, cond23);
   or (cond38, cond18, cond21);
   and (cond39, CK, RD, SE);
   and (cond40, CK, D, EN, RD, SE__bar);
   and (cond41, CK, EN__bar, RD, SE__bar);
   and (cond42, CK, D__bar, EN, RD, SE__bar);
   and (cond43, CK__bar, RD, SE, SI);
   and (cond44, CK__bar, RD, SE, SI__bar);
   and (cond45, CK__bar, D, EN, RD, SE__bar);
   and (cond46, CK__bar, D, EN__bar, RD, SE__bar);
   and (cond47, CK__bar, D__bar, EN, RD, SE__bar);
   and (cond48, CK__bar, D__bar, EN__bar, RD, SE__bar);
   and (cond49, RD, SD, SE, SI);
   and (cond50, D, EN__bar, RD, SD, SE__bar);
   and (cond51, RD, SD, SE, SI__bar);
   and (cond52, D__bar, EN__bar, RD, SD, SE__bar);

   specify
      if ((CK & ~(SD) & SE))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD) & SE))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(EN) & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & ~(SD) & ~(SE)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD) & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & SD & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD) & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(EN) & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & ~(SD) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD & SE))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & RD & SE & ~(SI)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((Q && SE && SI) || (Q && !(SE) && D) || (Q && !(SE) && !(D) && EN) || (!(Q) && SE && SI) || (!(Q) && !(SE) && D && !(EN))))) = 1;
      if ((CK & ~(SD) & SE))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & D & EN & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & ~(EN) & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & ~(D) & EN & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD) & SE))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & EN & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(EN) & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & ~(SD) & ~(SE)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & SD & SE))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD) & SE))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & EN & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(EN) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(EN) & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & EN & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & SD & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD) & SE))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & EN & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(EN) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(EN) & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & ~(SD) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & RD & SE))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & D & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & ~(EN) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & RD & SE & ~(SI)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & ~(EN) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((Q && SE && SI) || (Q && !(SE) && D) || (Q && !(SE) && !(D) && EN) || (!(Q) && SE && SI) || (!(Q) && !(SE) && D && !(EN))))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, posedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, negedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& cond14, posedge RD &&& cond14, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond15, posedge RD &&& cond15, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond16, posedge RD &&& cond16, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond17, posedge RD &&& cond17, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond18, posedge RD &&& cond18, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond19, posedge RD &&& cond19, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond20, posedge RD &&& cond20, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond21, posedge RD &&& cond21, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond22, posedge RD &&& cond22, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond23, posedge RD &&& cond23, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond37, posedge SD &&& cond37, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond38, posedge SD &&& cond38, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond11, posedge CK &&& cond11, 0, viol_0);
      $recovery (posedge RD &&& cond12, posedge CK &&& cond12, 0, viol_0);
      $recovery (posedge RD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond11, posedge RD &&& cond11, 0, viol_0);
      $hold (posedge CK &&& cond12, posedge RD &&& cond12, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge RD &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond34, posedge CK &&& cond34, 0, viol_0);
      $recovery (posedge SD &&& cond35, posedge CK &&& cond35, 0, viol_0);
      $recovery (posedge SD &&& cond36, posedge CK &&& cond36, 0, viol_0);
      $hold (posedge CK &&& cond34, posedge SD &&& cond34, 0, viol_0);
      $hold (posedge CK &&& cond35, posedge SD &&& cond35, 0, viol_0);
      $hold (posedge CK &&& cond36, posedge SD &&& cond36, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (negedge RD &&& cond25, 0, 0, viol_0);
      $width (negedge RD &&& cond26, 0, 0, viol_0);
      $width (negedge RD &&& cond27, 0, 0, viol_0);
      $width (negedge RD &&& cond28, 0, 0, viol_0);
      $width (negedge RD &&& cond29, 0, 0, viol_0);
      $width (negedge RD &&& cond30, 0, 0, viol_0);
      $width (negedge RD &&& cond31, 0, 0, viol_0);
      $width (negedge RD &&& cond32, 0, 0, viol_0);
      $width (negedge RD &&& cond33, 0, 0, viol_0);
      $width (negedge SD &&& cond39, 0, 0, viol_0);
      $width (negedge SD &&& cond40, 0, 0, viol_0);
      $width (negedge SD &&& cond41, 0, 0, viol_0);
      $width (negedge SD &&& cond42, 0, 0, viol_0);
      $width (negedge SD &&& cond43, 0, 0, viol_0);
      $width (negedge SD &&& cond44, 0, 0, viol_0);
      $width (negedge SD &&& cond45, 0, 0, viol_0);
      $width (negedge SD &&& cond46, 0, 0, viol_0);
      $width (negedge SD &&& cond47, 0, 0, viol_0);
      $width (negedge SD &&& cond48, 0, 0, viol_0);
      $width (posedge CK &&& cond49, 0, 0, viol_0);
      $width (negedge CK &&& cond49, 0, 0, viol_0);
      $width (posedge CK &&& cond50, 0, 0, viol_0);
      $width (negedge CK &&& cond50, 0, 0, viol_0);
      $width (posedge CK &&& cond51, 0, 0, viol_0);
      $width (negedge CK &&& cond51, 0, 0, viol_0);
      $width (posedge CK &&& cond52, 0, 0, viol_0);
      $width (negedge CK &&& cond52, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPHRBSBQO_2

//%BEGIN SEH_FSDPHRBSBQO_D_2

`celldefine
module SEH_FSDPHRBSBQO_D_2 (Q, SO, CK, D, SI, SE, EN, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, EN, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_EN, delayed_RD,
        delayed_SD;
   wire int_res__D, int_res__S, int_res__RD, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_EN, EN);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);


   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   not (int_res__RD, delayed_RD);
   not (int_res__SD, delayed_SD);
   dff_sr_err (xcr_0, delayed_CK, int_res__S, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__S, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, cond27, cond28;
   wire cond29, cond30, cond31;
   wire cond32, cond33, cond34;
   wire cond35, cond36, cond37;
   wire cond38, cond39, cond40;
   wire cond41, cond42, cond43;
   wire cond44, cond45, cond46;
   wire cond47, cond48, cond49;
   wire cond50, cond51, cond52;
   wire cond53, cond54, cond55;
   wire cond56, cond57, cond58;
   wire cond59, cond60, cond61;
   wire cond62, cond63, cond64;
   wire cond65, cond66, cond67;
   wire cond68, cond69, cond70;
   wire cond71, cond72, cond73;
   wire cond74, cond75, cond76;
   wire cond77, cond78, D__bar;
   wire EN__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (EN__bar, EN);
   not (SE__bar, SE);
   and (cond0, EN__bar, RD, SD, SE__bar);
   and (cond1, D, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SD, SE__bar);
   and (cond3, D, EN, RD, SD, SI);
   and (cond4, D__bar, EN, RD, SD, SI);
   and (cond5, D__bar, EN__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond6, D, EN, RD, SD, SI__bar);
   and (cond7, D, EN__bar, RD, SD, SI__bar);
   and (cond8, D__bar, EN, RD, SD, SI__bar);
   and (cond9, D, EN, RD, SD, SE);
   and (cond10, D, EN__bar, RD, SD, SE);
   and (cond11, D__bar, EN, RD, SD, SE);
   and (cond12, D__bar, EN__bar, RD, SD, SE);
   and (cond13, D, EN, SD, SE, SI);
   and (cond14, EN__bar, SD, SE, SI);
   and (cond15, D, EN__bar, SD, SE__bar);
   and (cond16, D__bar, EN, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, EN, SE__bar);
   and (int_twire_2, CK__bar, D, EN__bar, SE__bar);
   or (cond17, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, CK__bar, SE, SI__bar);
   and (int_twire_4, CK__bar, D__bar, EN__bar, SE__bar);
   or (cond18, int_twire_3, int_twire_4);
   and (cond19, CK, D, EN, SD, SE);
   and (cond20, CK, D, EN, SD, SE__bar);
   and (cond21, CK, EN__bar, SD, SE);
   and (cond22, CK, EN__bar, SD, SE__bar);
   and (cond23, CK, D__bar, EN, SD, SE);
   and (cond24, CK, D__bar, EN, SD, SE__bar);
   and (cond25, CK__bar, D, EN, SD, SE, SI);
   and (cond26, CK__bar, D, EN, SD, SE, SI__bar);
   and (cond27, CK__bar, D, EN, SD, SE__bar);
   and (cond28, CK__bar, EN__bar, SD, SE, SI);
   and (cond29, CK__bar, EN__bar, SD, SE, SI__bar);
   and (cond30, CK__bar, D, EN__bar, SD, SE__bar);
   and (cond31, CK__bar, D__bar, EN, SD, SE, SI);
   and (cond32, CK__bar, D__bar, EN, SD, SE, SI__bar);
   and (cond33, CK__bar, D__bar, EN, SD, SE__bar);
   and (cond34, CK__bar, D__bar, EN__bar, SD, SE__bar);
   and (cond35, D, EN, RD, SE, SI__bar);
   and (cond36, EN__bar, RD, SE, SI__bar);
   and (cond37, D__bar, EN, RD, SE, SI__bar);
   and (cond38, D__bar, EN__bar, RD, SE__bar);
   and (cond39, CK, D, EN, SE);
   and (cond40, CK, D, EN, SE__bar);
   and (cond41, CK, EN__bar, SE);
   and (cond42, CK, EN__bar, SE__bar);
   and (cond43, CK, D__bar, EN, SE);
   and (cond44, CK, D__bar, EN, SE__bar);
   and (cond45, CK__bar, D, EN, SE, SI);
   and (cond46, CK__bar, D, EN, SE, SI__bar);
   and (cond47, CK__bar, D, EN, SE__bar);
   and (cond48, CK__bar, EN__bar, SE, SI);
   and (cond49, CK__bar, EN__bar, SE, SI__bar);
   and (cond50, CK__bar, D, EN__bar, SE__bar);
   and (cond51, CK__bar, D__bar, EN, SE, SI);
   and (cond52, CK__bar, D__bar, EN, SE, SI__bar);
   and (cond53, CK__bar, D__bar, EN, SE__bar);
   and (cond54, CK__bar, D__bar, EN__bar, SE__bar);
   and (cond55, CK, D, EN, RD, SE);
   and (cond56, CK, D, EN, RD, SE__bar);
   and (cond57, CK, EN__bar, RD, SE);
   and (cond58, CK, EN__bar, RD, SE__bar);
   and (cond59, CK, D__bar, EN, RD, SE);
   and (cond60, CK, D__bar, EN, RD, SE__bar);
   and (cond61, CK__bar, D, EN, RD, SE, SI);
   and (cond62, CK__bar, D, EN, RD, SE, SI__bar);
   and (cond63, CK__bar, D, EN, RD, SE__bar);
   and (cond64, CK__bar, EN__bar, RD, SE, SI);
   and (cond65, CK__bar, EN__bar, RD, SE, SI__bar);
   and (cond66, CK__bar, D, EN__bar, RD, SE__bar);
   and (cond67, CK__bar, D__bar, EN, RD, SE, SI);
   and (cond68, CK__bar, D__bar, EN, RD, SE, SI__bar);
   and (cond69, CK__bar, D__bar, EN, RD, SE__bar);
   and (cond70, CK__bar, D__bar, EN__bar, RD, SE__bar);
   and (cond71, D, EN, RD, SD, SE, SI);
   and (cond72, EN__bar, RD, SD, SE, SI);
   and (cond73, D, EN__bar, RD, SD, SE__bar);
   and (cond74, D__bar, EN, RD, SD, SE, SI);
   and (cond75, D, EN, RD, SD, SE, SI__bar);
   and (cond76, EN__bar, RD, SD, SE, SI__bar);
   and (cond77, D__bar, EN, RD, SD, SE, SI__bar);
   and (cond78, D__bar, EN__bar, RD, SD, SE__bar);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & SD & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & SD & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & SD & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(EN) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(EN) & SD & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & RD & SE))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & RD & SE))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & RD & SE))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD & SE & ~(SI)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(EN) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(EN) & RD & SE & ~(SI)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD & SE & ~(SI)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((Q && SE && SI) || (Q && !(SE) && D) || (Q && !(SE) && !(D) && EN) || (!(Q) && SE && SI) || (!(Q) && !(SE) && D && !(EN))))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & D & EN & SD & SE))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(EN) & SD & SE))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(EN) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & EN & SD & SE))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & EN & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & EN & SD & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(EN) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(EN) & SD & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(EN) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & SD & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & EN & RD & SE))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & D & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & ~(EN) & RD & SE))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & ~(EN) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & ~(D) & EN & RD & SE))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((CK & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & EN & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & EN & RD & SE & ~(SI)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(EN) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(EN) & RD & SE & ~(SI)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & ~(EN) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & RD & SE & ~(SI)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((Q && SE && SI) || (Q && !(SE) && D) || (Q && !(SE) && !(D) && EN) || (!(Q) && SE && SI) || (!(Q) && !(SE) && D && !(EN))))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, posedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, negedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, posedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, negedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, posedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, negedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond17, posedge RD &&& cond17, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond18, posedge RD &&& cond18, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& cond39, posedge SD &&& cond39, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond40, posedge SD &&& cond40, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond41, posedge SD &&& cond41, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond42, posedge SD &&& cond42, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond43, posedge SD &&& cond43, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond44, posedge SD &&& cond44, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond45, posedge SD &&& cond45, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond46, posedge SD &&& cond46, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond47, posedge SD &&& cond47, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond48, posedge SD &&& cond48, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond49, posedge SD &&& cond49, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond50, posedge SD &&& cond50, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond51, posedge SD &&& cond51, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond52, posedge SD &&& cond52, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond53, posedge SD &&& cond53, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond54, posedge SD &&& cond54, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge RD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge RD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $recovery (posedge RD &&& cond16, posedge CK &&& cond16, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge RD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge RD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge RD &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond16, posedge RD &&& cond16, 0, viol_0);
      $recovery (posedge SD &&& cond35, posedge CK &&& cond35, 0, viol_0);
      $recovery (posedge SD &&& cond36, posedge CK &&& cond36, 0, viol_0);
      $recovery (posedge SD &&& cond37, posedge CK &&& cond37, 0, viol_0);
      $recovery (posedge SD &&& cond38, posedge CK &&& cond38, 0, viol_0);
      $hold (posedge CK &&& cond35, posedge SD &&& cond35, 0, viol_0);
      $hold (posedge CK &&& cond36, posedge SD &&& cond36, 0, viol_0);
      $hold (posedge CK &&& cond37, posedge SD &&& cond37, 0, viol_0);
      $hold (posedge CK &&& cond38, posedge SD &&& cond38, 0, viol_0);
      $width (negedge RD &&& cond19, 0, 0, viol_0);
      $width (negedge RD &&& cond20, 0, 0, viol_0);
      $width (negedge RD &&& cond21, 0, 0, viol_0);
      $width (negedge RD &&& cond22, 0, 0, viol_0);
      $width (negedge RD &&& cond23, 0, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (negedge RD &&& cond25, 0, 0, viol_0);
      $width (negedge RD &&& cond26, 0, 0, viol_0);
      $width (negedge RD &&& cond27, 0, 0, viol_0);
      $width (negedge RD &&& cond28, 0, 0, viol_0);
      $width (negedge RD &&& cond29, 0, 0, viol_0);
      $width (negedge RD &&& cond30, 0, 0, viol_0);
      $width (negedge RD &&& cond31, 0, 0, viol_0);
      $width (negedge RD &&& cond32, 0, 0, viol_0);
      $width (negedge RD &&& cond33, 0, 0, viol_0);
      $width (negedge RD &&& cond34, 0, 0, viol_0);
      $width (negedge SD &&& cond55, 0, 0, viol_0);
      $width (negedge SD &&& cond56, 0, 0, viol_0);
      $width (negedge SD &&& cond57, 0, 0, viol_0);
      $width (negedge SD &&& cond58, 0, 0, viol_0);
      $width (negedge SD &&& cond59, 0, 0, viol_0);
      $width (negedge SD &&& cond60, 0, 0, viol_0);
      $width (negedge SD &&& cond61, 0, 0, viol_0);
      $width (negedge SD &&& cond62, 0, 0, viol_0);
      $width (negedge SD &&& cond63, 0, 0, viol_0);
      $width (negedge SD &&& cond64, 0, 0, viol_0);
      $width (negedge SD &&& cond65, 0, 0, viol_0);
      $width (negedge SD &&& cond66, 0, 0, viol_0);
      $width (negedge SD &&& cond67, 0, 0, viol_0);
      $width (negedge SD &&& cond68, 0, 0, viol_0);
      $width (negedge SD &&& cond69, 0, 0, viol_0);
      $width (negedge SD &&& cond70, 0, 0, viol_0);
      $width (posedge CK &&& cond71, 0, 0, viol_0);
      $width (negedge CK &&& cond71, 0, 0, viol_0);
      $width (posedge CK &&& cond72, 0, 0, viol_0);
      $width (negedge CK &&& cond72, 0, 0, viol_0);
      $width (posedge CK &&& cond73, 0, 0, viol_0);
      $width (negedge CK &&& cond73, 0, 0, viol_0);
      $width (posedge CK &&& cond74, 0, 0, viol_0);
      $width (negedge CK &&& cond74, 0, 0, viol_0);
      $width (posedge CK &&& cond75, 0, 0, viol_0);
      $width (negedge CK &&& cond75, 0, 0, viol_0);
      $width (posedge CK &&& cond76, 0, 0, viol_0);
      $width (negedge CK &&& cond76, 0, 0, viol_0);
      $width (posedge CK &&& cond77, 0, 0, viol_0);
      $width (negedge CK &&& cond77, 0, 0, viol_0);
      $width (posedge CK &&& cond78, 0, 0, viol_0);
      $width (negedge CK &&& cond78, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPHRBSBQO_D_2

//%BEGIN SEH_FSDPHRBSBQ_D_1

`celldefine
module SEH_FSDPHRBSBQ_D_1 (Q, CK, D, SI, SE, EN, RD, SD);
   output Q;
   input CK, D, SI, SE, EN, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_EN, delayed_RD,
        delayed_SD;
   wire int_res__D, int_res__S, int_res__RD, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_EN, EN);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);

   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   not (int_res__RD, delayed_RD);
   not (int_res__SD, delayed_SD);
   dff_sr_err (xcr_0, delayed_CK, int_res__S, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__S, int_res__SD, int_res__RD, xcr_0);

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
   `else
       buf (Q, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, cond27, cond28;
   wire cond29, cond30, cond31;
   wire cond32, cond33, cond34;
   wire cond35, cond36, cond37;
   wire cond38, cond39, cond40;
   wire cond41, cond42, cond43;
   wire cond44, cond45, cond46;
   wire cond47, cond48, cond49;
   wire cond50, cond51, cond52;
   wire cond53, cond54, cond55;
   wire cond56, cond57, cond58;
   wire cond59, cond60, cond61;
   wire cond62, cond63, cond64;
   wire cond65, cond66, cond67;
   wire cond68, cond69, cond70;
   wire cond71, cond72, cond73;
   wire cond74, cond75, cond76;
   wire cond77, cond78, D__bar;
   wire EN__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (EN__bar, EN);
   not (SE__bar, SE);
   and (cond0, EN__bar, RD, SD, SE__bar);
   and (cond1, D, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SD, SE__bar);
   and (cond3, D, EN, RD, SD, SI);
   and (cond4, D__bar, EN, RD, SD, SI);
   and (cond5, D__bar, EN__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond6, D, EN, RD, SD, SI__bar);
   and (cond7, D, EN__bar, RD, SD, SI__bar);
   and (cond8, D__bar, EN, RD, SD, SI__bar);
   and (cond9, D, EN, RD, SD, SE);
   and (cond10, D, EN__bar, RD, SD, SE);
   and (cond11, D__bar, EN, RD, SD, SE);
   and (cond12, D__bar, EN__bar, RD, SD, SE);
   and (cond13, D, EN, SD, SE, SI);
   and (cond14, EN__bar, SD, SE, SI);
   and (cond15, D, EN__bar, SD, SE__bar);
   and (cond16, D__bar, EN, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, EN, SE__bar);
   and (int_twire_2, CK__bar, D, EN__bar, SE__bar);
   or (cond17, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, CK__bar, SE, SI__bar);
   and (int_twire_4, CK__bar, D__bar, EN__bar, SE__bar);
   or (cond18, int_twire_3, int_twire_4);
   and (cond19, CK, D, EN, SD, SE);
   and (cond20, CK, D, EN, SD, SE__bar);
   and (cond21, CK, EN__bar, SD, SE);
   and (cond22, CK, EN__bar, SD, SE__bar);
   and (cond23, CK, D__bar, EN, SD, SE);
   and (cond24, CK, D__bar, EN, SD, SE__bar);
   and (cond25, CK__bar, D, EN, SD, SE, SI);
   and (cond26, CK__bar, D, EN, SD, SE, SI__bar);
   and (cond27, CK__bar, D, EN, SD, SE__bar);
   and (cond28, CK__bar, EN__bar, SD, SE, SI);
   and (cond29, CK__bar, EN__bar, SD, SE, SI__bar);
   and (cond30, CK__bar, D, EN__bar, SD, SE__bar);
   and (cond31, CK__bar, D__bar, EN, SD, SE, SI);
   and (cond32, CK__bar, D__bar, EN, SD, SE, SI__bar);
   and (cond33, CK__bar, D__bar, EN, SD, SE__bar);
   and (cond34, CK__bar, D__bar, EN__bar, SD, SE__bar);
   and (cond35, D, EN, RD, SE, SI__bar);
   and (cond36, EN__bar, RD, SE, SI__bar);
   and (cond37, D__bar, EN, RD, SE, SI__bar);
   and (cond38, D__bar, EN__bar, RD, SE__bar);
   and (cond39, CK, D, EN, SE);
   and (cond40, CK, D, EN, SE__bar);
   and (cond41, CK, EN__bar, SE);
   and (cond42, CK, EN__bar, SE__bar);
   and (cond43, CK, D__bar, EN, SE);
   and (cond44, CK, D__bar, EN, SE__bar);
   and (cond45, CK__bar, D, EN, SE, SI);
   and (cond46, CK__bar, D, EN, SE, SI__bar);
   and (cond47, CK__bar, D, EN, SE__bar);
   and (cond48, CK__bar, EN__bar, SE, SI);
   and (cond49, CK__bar, EN__bar, SE, SI__bar);
   and (cond50, CK__bar, D, EN__bar, SE__bar);
   and (cond51, CK__bar, D__bar, EN, SE, SI);
   and (cond52, CK__bar, D__bar, EN, SE, SI__bar);
   and (cond53, CK__bar, D__bar, EN, SE__bar);
   and (cond54, CK__bar, D__bar, EN__bar, SE__bar);
   and (cond55, CK, D, EN, RD, SE);
   and (cond56, CK, D, EN, RD, SE__bar);
   and (cond57, CK, EN__bar, RD, SE);
   and (cond58, CK, EN__bar, RD, SE__bar);
   and (cond59, CK, D__bar, EN, RD, SE);
   and (cond60, CK, D__bar, EN, RD, SE__bar);
   and (cond61, CK__bar, D, EN, RD, SE, SI);
   and (cond62, CK__bar, D, EN, RD, SE, SI__bar);
   and (cond63, CK__bar, D, EN, RD, SE__bar);
   and (cond64, CK__bar, EN__bar, RD, SE, SI);
   and (cond65, CK__bar, EN__bar, RD, SE, SI__bar);
   and (cond66, CK__bar, D, EN__bar, RD, SE__bar);
   and (cond67, CK__bar, D__bar, EN, RD, SE, SI);
   and (cond68, CK__bar, D__bar, EN, RD, SE, SI__bar);
   and (cond69, CK__bar, D__bar, EN, RD, SE__bar);
   and (cond70, CK__bar, D__bar, EN__bar, RD, SE__bar);
   and (cond71, D, EN, RD, SD, SE, SI);
   and (cond72, EN__bar, RD, SD, SE, SI);
   and (cond73, D, EN__bar, RD, SD, SE__bar);
   and (cond74, D__bar, EN, RD, SD, SE, SI);
   and (cond75, D, EN, RD, SD, SE, SI__bar);
   and (cond76, EN__bar, RD, SD, SE, SI__bar);
   and (cond77, D__bar, EN, RD, SD, SE, SI__bar);
   and (cond78, D__bar, EN__bar, RD, SD, SE__bar);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & SD & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & SD & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & SD & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(EN) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(EN) & SD & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & RD & SE))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & RD & SE))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & RD & SE))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD & SE & ~(SI)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(EN) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(EN) & RD & SE & ~(SI)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD & SE & ~(SI)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((Q && SE && SI) || (Q && !(SE) && D) || (Q && !(SE) && !(D) && EN) || (!(Q) && SE && SI) || (!(Q) && !(SE) && D && !(EN))))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, posedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, negedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, posedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, negedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, posedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, negedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond17, posedge RD &&& cond17, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond18, posedge RD &&& cond18, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& cond39, posedge SD &&& cond39, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond40, posedge SD &&& cond40, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond41, posedge SD &&& cond41, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond42, posedge SD &&& cond42, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond43, posedge SD &&& cond43, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond44, posedge SD &&& cond44, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond45, posedge SD &&& cond45, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond46, posedge SD &&& cond46, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond47, posedge SD &&& cond47, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond48, posedge SD &&& cond48, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond49, posedge SD &&& cond49, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond50, posedge SD &&& cond50, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond51, posedge SD &&& cond51, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond52, posedge SD &&& cond52, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond53, posedge SD &&& cond53, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond54, posedge SD &&& cond54, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge RD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge RD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $recovery (posedge RD &&& cond16, posedge CK &&& cond16, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge RD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge RD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge RD &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond16, posedge RD &&& cond16, 0, viol_0);
      $recovery (posedge SD &&& cond35, posedge CK &&& cond35, 0, viol_0);
      $recovery (posedge SD &&& cond36, posedge CK &&& cond36, 0, viol_0);
      $recovery (posedge SD &&& cond37, posedge CK &&& cond37, 0, viol_0);
      $recovery (posedge SD &&& cond38, posedge CK &&& cond38, 0, viol_0);
      $hold (posedge CK &&& cond35, posedge SD &&& cond35, 0, viol_0);
      $hold (posedge CK &&& cond36, posedge SD &&& cond36, 0, viol_0);
      $hold (posedge CK &&& cond37, posedge SD &&& cond37, 0, viol_0);
      $hold (posedge CK &&& cond38, posedge SD &&& cond38, 0, viol_0);
      $width (negedge RD &&& cond19, 0, 0, viol_0);
      $width (negedge RD &&& cond20, 0, 0, viol_0);
      $width (negedge RD &&& cond21, 0, 0, viol_0);
      $width (negedge RD &&& cond22, 0, 0, viol_0);
      $width (negedge RD &&& cond23, 0, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (negedge RD &&& cond25, 0, 0, viol_0);
      $width (negedge RD &&& cond26, 0, 0, viol_0);
      $width (negedge RD &&& cond27, 0, 0, viol_0);
      $width (negedge RD &&& cond28, 0, 0, viol_0);
      $width (negedge RD &&& cond29, 0, 0, viol_0);
      $width (negedge RD &&& cond30, 0, 0, viol_0);
      $width (negedge RD &&& cond31, 0, 0, viol_0);
      $width (negedge RD &&& cond32, 0, 0, viol_0);
      $width (negedge RD &&& cond33, 0, 0, viol_0);
      $width (negedge RD &&& cond34, 0, 0, viol_0);
      $width (negedge SD &&& cond55, 0, 0, viol_0);
      $width (negedge SD &&& cond56, 0, 0, viol_0);
      $width (negedge SD &&& cond57, 0, 0, viol_0);
      $width (negedge SD &&& cond58, 0, 0, viol_0);
      $width (negedge SD &&& cond59, 0, 0, viol_0);
      $width (negedge SD &&& cond60, 0, 0, viol_0);
      $width (negedge SD &&& cond61, 0, 0, viol_0);
      $width (negedge SD &&& cond62, 0, 0, viol_0);
      $width (negedge SD &&& cond63, 0, 0, viol_0);
      $width (negedge SD &&& cond64, 0, 0, viol_0);
      $width (negedge SD &&& cond65, 0, 0, viol_0);
      $width (negedge SD &&& cond66, 0, 0, viol_0);
      $width (negedge SD &&& cond67, 0, 0, viol_0);
      $width (negedge SD &&& cond68, 0, 0, viol_0);
      $width (negedge SD &&& cond69, 0, 0, viol_0);
      $width (negedge SD &&& cond70, 0, 0, viol_0);
      $width (posedge CK &&& cond71, 0, 0, viol_0);
      $width (negedge CK &&& cond71, 0, 0, viol_0);
      $width (posedge CK &&& cond72, 0, 0, viol_0);
      $width (negedge CK &&& cond72, 0, 0, viol_0);
      $width (posedge CK &&& cond73, 0, 0, viol_0);
      $width (negedge CK &&& cond73, 0, 0, viol_0);
      $width (posedge CK &&& cond74, 0, 0, viol_0);
      $width (negedge CK &&& cond74, 0, 0, viol_0);
      $width (posedge CK &&& cond75, 0, 0, viol_0);
      $width (negedge CK &&& cond75, 0, 0, viol_0);
      $width (posedge CK &&& cond76, 0, 0, viol_0);
      $width (negedge CK &&& cond76, 0, 0, viol_0);
      $width (posedge CK &&& cond77, 0, 0, viol_0);
      $width (negedge CK &&& cond77, 0, 0, viol_0);
      $width (posedge CK &&& cond78, 0, 0, viol_0);
      $width (negedge CK &&& cond78, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPHRBSBQ_D_1

//%BEGIN SEH_FSDPHRBSBQ_D_2

`celldefine
module SEH_FSDPHRBSBQ_D_2 (Q, CK, D, SI, SE, EN, RD, SD);
   output Q;
   input CK, D, SI, SE, EN, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_EN, delayed_RD,
        delayed_SD;
   wire int_res__D, int_res__S, int_res__RD, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_EN, EN);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);

   mux2 (int_res__D, int_res_iq, delayed_D, delayed_EN);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   not (int_res__RD, delayed_RD);
   not (int_res__SD, delayed_SD);
   dff_sr_err (xcr_0, delayed_CK, int_res__S, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__S, int_res__SD, int_res__RD, xcr_0);

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
   `else
       buf (Q, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else
   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, cond27, cond28;
   wire cond29, cond30, cond31;
   wire cond32, cond33, cond34;
   wire cond35, cond36, cond37;
   wire cond38, cond39, cond40;
   wire cond41, cond42, cond43;
   wire cond44, cond45, cond46;
   wire cond47, cond48, cond49;
   wire cond50, cond51, cond52;
   wire cond53, cond54, cond55;
   wire cond56, cond57, cond58;
   wire cond59, cond60, cond61;
   wire cond62, cond63, cond64;
   wire cond65, cond66, cond67;
   wire cond68, cond69, cond70;
   wire cond71, cond72, cond73;
   wire cond74, cond75, cond76;
   wire cond77, cond78, D__bar;
   wire EN__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (EN__bar, EN);
   not (SE__bar, SE);
   and (cond0, EN__bar, RD, SD, SE__bar);
   and (cond1, D, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SD, SE__bar);
   and (cond3, D, EN, RD, SD, SI);
   and (cond4, D__bar, EN, RD, SD, SI);
   and (cond5, D__bar, EN__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond6, D, EN, RD, SD, SI__bar);
   and (cond7, D, EN__bar, RD, SD, SI__bar);
   and (cond8, D__bar, EN, RD, SD, SI__bar);
   and (cond9, D, EN, RD, SD, SE);
   and (cond10, D, EN__bar, RD, SD, SE);
   and (cond11, D__bar, EN, RD, SD, SE);
   and (cond12, D__bar, EN__bar, RD, SD, SE);
   and (cond13, D, EN, SD, SE, SI);
   and (cond14, EN__bar, SD, SE, SI);
   and (cond15, D, EN__bar, SD, SE__bar);
   and (cond16, D__bar, EN, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, EN, SE__bar);
   and (int_twire_2, CK__bar, D, EN__bar, SE__bar);
   or (cond17, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, CK__bar, SE, SI__bar);
   and (int_twire_4, CK__bar, D__bar, EN__bar, SE__bar);
   or (cond18, int_twire_3, int_twire_4);
   and (cond19, CK, D, EN, SD, SE);
   and (cond20, CK, D, EN, SD, SE__bar);
   and (cond21, CK, EN__bar, SD, SE);
   and (cond22, CK, EN__bar, SD, SE__bar);
   and (cond23, CK, D__bar, EN, SD, SE);
   and (cond24, CK, D__bar, EN, SD, SE__bar);
   and (cond25, CK__bar, D, EN, SD, SE, SI);
   and (cond26, CK__bar, D, EN, SD, SE, SI__bar);
   and (cond27, CK__bar, D, EN, SD, SE__bar);
   and (cond28, CK__bar, EN__bar, SD, SE, SI);
   and (cond29, CK__bar, EN__bar, SD, SE, SI__bar);
   and (cond30, CK__bar, D, EN__bar, SD, SE__bar);
   and (cond31, CK__bar, D__bar, EN, SD, SE, SI);
   and (cond32, CK__bar, D__bar, EN, SD, SE, SI__bar);
   and (cond33, CK__bar, D__bar, EN, SD, SE__bar);
   and (cond34, CK__bar, D__bar, EN__bar, SD, SE__bar);
   and (cond35, D, EN, RD, SE, SI__bar);
   and (cond36, EN__bar, RD, SE, SI__bar);
   and (cond37, D__bar, EN, RD, SE, SI__bar);
   and (cond38, D__bar, EN__bar, RD, SE__bar);
   and (cond39, CK, D, EN, SE);
   and (cond40, CK, D, EN, SE__bar);
   and (cond41, CK, EN__bar, SE);
   and (cond42, CK, EN__bar, SE__bar);
   and (cond43, CK, D__bar, EN, SE);
   and (cond44, CK, D__bar, EN, SE__bar);
   and (cond45, CK__bar, D, EN, SE, SI);
   and (cond46, CK__bar, D, EN, SE, SI__bar);
   and (cond47, CK__bar, D, EN, SE__bar);
   and (cond48, CK__bar, EN__bar, SE, SI);
   and (cond49, CK__bar, EN__bar, SE, SI__bar);
   and (cond50, CK__bar, D, EN__bar, SE__bar);
   and (cond51, CK__bar, D__bar, EN, SE, SI);
   and (cond52, CK__bar, D__bar, EN, SE, SI__bar);
   and (cond53, CK__bar, D__bar, EN, SE__bar);
   and (cond54, CK__bar, D__bar, EN__bar, SE__bar);
   and (cond55, CK, D, EN, RD, SE);
   and (cond56, CK, D, EN, RD, SE__bar);
   and (cond57, CK, EN__bar, RD, SE);
   and (cond58, CK, EN__bar, RD, SE__bar);
   and (cond59, CK, D__bar, EN, RD, SE);
   and (cond60, CK, D__bar, EN, RD, SE__bar);
   and (cond61, CK__bar, D, EN, RD, SE, SI);
   and (cond62, CK__bar, D, EN, RD, SE, SI__bar);
   and (cond63, CK__bar, D, EN, RD, SE__bar);
   and (cond64, CK__bar, EN__bar, RD, SE, SI);
   and (cond65, CK__bar, EN__bar, RD, SE, SI__bar);
   and (cond66, CK__bar, D, EN__bar, RD, SE__bar);
   and (cond67, CK__bar, D__bar, EN, RD, SE, SI);
   and (cond68, CK__bar, D__bar, EN, RD, SE, SI__bar);
   and (cond69, CK__bar, D__bar, EN, RD, SE__bar);
   and (cond70, CK__bar, D__bar, EN__bar, RD, SE__bar);
   and (cond71, D, EN, RD, SD, SE, SI);
   and (cond72, EN__bar, RD, SD, SE, SI);
   and (cond73, D, EN__bar, RD, SD, SE__bar);
   and (cond74, D__bar, EN, RD, SD, SE, SI);
   and (cond75, D, EN, RD, SD, SE, SI__bar);
   and (cond76, EN__bar, RD, SD, SE, SI__bar);
   and (cond77, D__bar, EN, RD, SD, SE, SI__bar);
   and (cond78, D__bar, EN__bar, RD, SD, SE__bar);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & SD & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & SD & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & SD & SE))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(EN) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(EN) & SD & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & EN & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & EN & RD & SE))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & D & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & RD & SE))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & RD & SE))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((CK & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD & SE & ~(SI)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(EN) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(EN) & RD & SE & ~(SI)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD & SE & ~(SI)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & EN & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(EN) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((Q && SE && SI) || (Q && !(SE) && D) || (Q && !(SE) && !(D) && EN) || (!(Q) && SE && SI) || (!(Q) && !(SE) && D && !(EN))))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond1, negedge EN &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, posedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond2, negedge EN &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_EN);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, negedge SE &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, negedge SI &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, posedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond10, negedge SI &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, posedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond11, negedge SI &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, posedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond12, negedge SI &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond17, posedge RD &&& cond17, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond18, posedge RD &&& cond18, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& cond39, posedge SD &&& cond39, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond40, posedge SD &&& cond40, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond41, posedge SD &&& cond41, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond42, posedge SD &&& cond42, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond43, posedge SD &&& cond43, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond44, posedge SD &&& cond44, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond45, posedge SD &&& cond45, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond46, posedge SD &&& cond46, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond47, posedge SD &&& cond47, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond48, posedge SD &&& cond48, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond49, posedge SD &&& cond49, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond50, posedge SD &&& cond50, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond51, posedge SD &&& cond51, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond52, posedge SD &&& cond52, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond53, posedge SD &&& cond53, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond54, posedge SD &&& cond54, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge RD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge RD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $recovery (posedge RD &&& cond16, posedge CK &&& cond16, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge RD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge RD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge RD &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond16, posedge RD &&& cond16, 0, viol_0);
      $recovery (posedge SD &&& cond35, posedge CK &&& cond35, 0, viol_0);
      $recovery (posedge SD &&& cond36, posedge CK &&& cond36, 0, viol_0);
      $recovery (posedge SD &&& cond37, posedge CK &&& cond37, 0, viol_0);
      $recovery (posedge SD &&& cond38, posedge CK &&& cond38, 0, viol_0);
      $hold (posedge CK &&& cond35, posedge SD &&& cond35, 0, viol_0);
      $hold (posedge CK &&& cond36, posedge SD &&& cond36, 0, viol_0);
      $hold (posedge CK &&& cond37, posedge SD &&& cond37, 0, viol_0);
      $hold (posedge CK &&& cond38, posedge SD &&& cond38, 0, viol_0);
      $width (negedge RD &&& cond19, 0, 0, viol_0);
      $width (negedge RD &&& cond20, 0, 0, viol_0);
      $width (negedge RD &&& cond21, 0, 0, viol_0);
      $width (negedge RD &&& cond22, 0, 0, viol_0);
      $width (negedge RD &&& cond23, 0, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (negedge RD &&& cond25, 0, 0, viol_0);
      $width (negedge RD &&& cond26, 0, 0, viol_0);
      $width (negedge RD &&& cond27, 0, 0, viol_0);
      $width (negedge RD &&& cond28, 0, 0, viol_0);
      $width (negedge RD &&& cond29, 0, 0, viol_0);
      $width (negedge RD &&& cond30, 0, 0, viol_0);
      $width (negedge RD &&& cond31, 0, 0, viol_0);
      $width (negedge RD &&& cond32, 0, 0, viol_0);
      $width (negedge RD &&& cond33, 0, 0, viol_0);
      $width (negedge RD &&& cond34, 0, 0, viol_0);
      $width (negedge SD &&& cond55, 0, 0, viol_0);
      $width (negedge SD &&& cond56, 0, 0, viol_0);
      $width (negedge SD &&& cond57, 0, 0, viol_0);
      $width (negedge SD &&& cond58, 0, 0, viol_0);
      $width (negedge SD &&& cond59, 0, 0, viol_0);
      $width (negedge SD &&& cond60, 0, 0, viol_0);
      $width (negedge SD &&& cond61, 0, 0, viol_0);
      $width (negedge SD &&& cond62, 0, 0, viol_0);
      $width (negedge SD &&& cond63, 0, 0, viol_0);
      $width (negedge SD &&& cond64, 0, 0, viol_0);
      $width (negedge SD &&& cond65, 0, 0, viol_0);
      $width (negedge SD &&& cond66, 0, 0, viol_0);
      $width (negedge SD &&& cond67, 0, 0, viol_0);
      $width (negedge SD &&& cond68, 0, 0, viol_0);
      $width (negedge SD &&& cond69, 0, 0, viol_0);
      $width (negedge SD &&& cond70, 0, 0, viol_0);
      $width (posedge CK &&& cond71, 0, 0, viol_0);
      $width (negedge CK &&& cond71, 0, 0, viol_0);
      $width (posedge CK &&& cond72, 0, 0, viol_0);
      $width (negedge CK &&& cond72, 0, 0, viol_0);
      $width (posedge CK &&& cond73, 0, 0, viol_0);
      $width (negedge CK &&& cond73, 0, 0, viol_0);
      $width (posedge CK &&& cond74, 0, 0, viol_0);
      $width (negedge CK &&& cond74, 0, 0, viol_0);
      $width (posedge CK &&& cond75, 0, 0, viol_0);
      $width (negedge CK &&& cond75, 0, 0, viol_0);
      $width (posedge CK &&& cond76, 0, 0, viol_0);
      $width (negedge CK &&& cond76, 0, 0, viol_0);
      $width (posedge CK &&& cond77, 0, 0, viol_0);
      $width (negedge CK &&& cond77, 0, 0, viol_0);
      $width (posedge CK &&& cond78, 0, 0, viol_0);
      $width (negedge CK &&& cond78, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPHRBSBQ_D_2

//%BEGIN SEH_FSDPMQO_1

`celldefine
module SEH_FSDPMQO_1 (Q, SO, CK, D0, D1, S, SI, SE);
   output Q, SO;
   input CK, D0, D1, S, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D0, delayed_D1,
	delayed_S, delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, int_res__S, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D0, D0);
   buf (delayed_D1, D1);
   buf (delayed_S, S);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_D1, delayed_D0, delayed_S);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);
   dff (int_res_iq, viol_0, delayed_CK, int_res__S, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire cond21, D0__bar, D1__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire S__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (S__bar, S);
   not (SE__bar, SE);
   and (cond0, D1, S__bar, SE__bar);
   not (D1__bar, D1);
   and (cond1, D1__bar, S__bar, SE__bar);
   and (cond2, D0, S, SE__bar);
   not (D0__bar, D0);
   and (cond3, D0__bar, S, SE__bar);
   and (cond4, D0__bar, D1, SE__bar);
   and (cond5, D0, D1__bar, SE__bar);
   and (cond6, D0, D1__bar, S, SI);
   and (cond7, D0__bar, D1, S__bar, SI);
   and (cond8, D0__bar, D1__bar, S, SI);
   and (cond9, D0__bar, D1__bar, S__bar, SI);
   not (SI__bar, SI);
   and (cond10, D0, D1, S, SI__bar);
   and (cond11, D0, D1, S__bar, SI__bar);
   and (cond12, D0, D1__bar, S__bar, SI__bar);
   and (cond13, D0__bar, D1, S, SI__bar);
   and (cond14, D0, D1, SE);
   and (cond15, D0, D1__bar, S, SE);
   and (cond16, D0, D1__bar, S__bar, SE);
   and (cond17, D0__bar, D1, S, SE);
   and (cond18, D0__bar, D1, S__bar, SE);
   and (cond19, D0__bar, D1__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D1, S, SE__bar);
   and (int_twire_2, D0, S__bar, SE__bar);
   or (cond20, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, SE, SI__bar);
   and (int_twire_4, D1__bar, S, SE__bar);
   and (int_twire_5, D0__bar, S__bar, SE__bar);
   or (cond21, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((D0 && S && D1 && SE && SI) || (D0 && S && D1 && !(SE)) || (D0 && S && !(D1) && SE && SI) || (D0 && !(S) && SE && SI) || (D0 && !(S) && !(SE)) || (!(D0) && S && D1 && SE && SI) || (!(D0) && S && D1 && !(SE)) || (!(D0) && S && !(D1) && SE && SI) || (!(D0) && !(S) && SE && SI)))) = 1;
      (posedge CK => (SO-:((D0 && S && D1 && SE && SI) || (D0 && S && D1 && !(SE)) || (D0 && S && !(D1) && SE && SI) || (D0 && !(S) && SE && SI) || (D0 && !(S) && !(SE)) || (!(D0) && S && D1 && SE && SI) || (!(D0) && S && D1 && !(SE)) || (!(D0) && S && !(D1) && SE && SI) || (!(D0) && !(S) && SE && SI)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond0, negedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, posedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, negedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond2, posedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond2, negedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, posedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, negedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond4, posedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond4, negedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, posedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, negedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, negedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, posedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, negedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, posedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, negedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, posedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, negedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, posedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, negedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, posedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, negedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, posedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, negedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
      $width (posedge CK &&& cond21, 0, 0, viol_0);
      $width (negedge CK &&& cond21, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPMQO_1

//%BEGIN SEH_FSDPMQO_2

`celldefine
module SEH_FSDPMQO_2 (Q, SO, CK, D0, D1, S, SI, SE);
   output Q, SO;
   input CK, D0, D1, S, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D0, delayed_D1,
	delayed_S, delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, int_res__S, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D0, D0);
   buf (delayed_D1, D1);
   buf (delayed_S, S);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_D1, delayed_D0, delayed_S);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);
   dff (int_res_iq, viol_0, delayed_CK, int_res__S, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire cond21, D0__bar, D1__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire S__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (S__bar, S);
   not (SE__bar, SE);
   and (cond0, D1, S__bar, SE__bar);
   not (D1__bar, D1);
   and (cond1, D1__bar, S__bar, SE__bar);
   and (cond2, D0, S, SE__bar);
   not (D0__bar, D0);
   and (cond3, D0__bar, S, SE__bar);
   and (cond4, D0__bar, D1, SE__bar);
   and (cond5, D0, D1__bar, SE__bar);
   and (cond6, D0, D1__bar, S, SI);
   and (cond7, D0__bar, D1, S__bar, SI);
   and (cond8, D0__bar, D1__bar, S, SI);
   and (cond9, D0__bar, D1__bar, S__bar, SI);
   not (SI__bar, SI);
   and (cond10, D0, D1, S, SI__bar);
   and (cond11, D0, D1, S__bar, SI__bar);
   and (cond12, D0, D1__bar, S__bar, SI__bar);
   and (cond13, D0__bar, D1, S, SI__bar);
   and (cond14, D0, D1, SE);
   and (cond15, D0, D1__bar, S, SE);
   and (cond16, D0, D1__bar, S__bar, SE);
   and (cond17, D0__bar, D1, S, SE);
   and (cond18, D0__bar, D1, S__bar, SE);
   and (cond19, D0__bar, D1__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D1, S, SE__bar);
   and (int_twire_2, D0, S__bar, SE__bar);
   or (cond20, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, SE, SI__bar);
   and (int_twire_4, D1__bar, S, SE__bar);
   and (int_twire_5, D0__bar, S__bar, SE__bar);
   or (cond21, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      (posedge CK => (SO-:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond0, negedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, posedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, negedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond2, posedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond2, negedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, posedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, negedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond4, posedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond4, negedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, posedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, negedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, negedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, posedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, negedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, posedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, negedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, posedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, negedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, posedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, negedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, posedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, negedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, posedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, negedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
      $width (posedge CK &&& cond21, 0, 0, viol_0);
      $width (negedge CK &&& cond21, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPMQO_2

//%BEGIN SEH_FSDPMQO_4

`celldefine
module SEH_FSDPMQO_4 (Q, SO, CK, D0, D1, S, SI, SE);
   output Q, SO;
   input CK, D0, D1, S, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D0, delayed_D1,
	delayed_S, delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, int_res__S, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D0, D0);
   buf (delayed_D1, D1);
   buf (delayed_S, S);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_D1, delayed_D0, delayed_S);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);
   dff (int_res_iq, viol_0, delayed_CK, int_res__S, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire cond21, D0__bar, D1__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire S__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (S__bar, S);
   not (SE__bar, SE);
   and (cond0, D1, S__bar, SE__bar);
   not (D1__bar, D1);
   and (cond1, D1__bar, S__bar, SE__bar);
   and (cond2, D0, S, SE__bar);
   not (D0__bar, D0);
   and (cond3, D0__bar, S, SE__bar);
   and (cond4, D0__bar, D1, SE__bar);
   and (cond5, D0, D1__bar, SE__bar);
   and (cond6, D0, D1__bar, S, SI);
   and (cond7, D0__bar, D1, S__bar, SI);
   and (cond8, D0__bar, D1__bar, S, SI);
   and (cond9, D0__bar, D1__bar, S__bar, SI);
   not (SI__bar, SI);
   and (cond10, D0, D1, S, SI__bar);
   and (cond11, D0, D1, S__bar, SI__bar);
   and (cond12, D0, D1__bar, S__bar, SI__bar);
   and (cond13, D0__bar, D1, S, SI__bar);
   and (cond14, D0, D1, SE);
   and (cond15, D0, D1__bar, S, SE);
   and (cond16, D0, D1__bar, S__bar, SE);
   and (cond17, D0__bar, D1, S, SE);
   and (cond18, D0__bar, D1, S__bar, SE);
   and (cond19, D0__bar, D1__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D1, S, SE__bar);
   and (int_twire_2, D0, S__bar, SE__bar);
   or (cond20, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, SE, SI__bar);
   and (int_twire_4, D1__bar, S, SE__bar);
   and (int_twire_5, D0__bar, S__bar, SE__bar);
   or (cond21, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      (posedge CK => (SO-:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond0, negedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, posedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, negedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond2, posedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond2, negedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, posedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, negedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond4, posedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond4, negedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, posedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, negedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, negedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, posedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, negedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, posedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, negedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, posedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, negedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, posedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, negedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, posedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, negedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, posedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, negedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
      $width (posedge CK &&& cond21, 0, 0, viol_0);
      $width (negedge CK &&& cond21, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPMQO_4

//%BEGIN SEH_FSDPMQO_D_1

`celldefine
module SEH_FSDPMQO_D_1 (Q, SO, CK, D0, D1, S, SI, SE);
   output Q, SO;
   input CK, D0, D1, S, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D0, delayed_D1,
	delayed_S, delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, int_res__S, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D0, D0);
   buf (delayed_D1, D1);
   buf (delayed_S, S);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_D1, delayed_D0, delayed_S);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);
   dff (int_res_iq, viol_0, delayed_CK, int_res__S, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire cond21, D0__bar, D1__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire S__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (S__bar, S);
   not (SE__bar, SE);
   and (cond0, D1, S__bar, SE__bar);
   not (D1__bar, D1);
   and (cond1, D1__bar, S__bar, SE__bar);
   and (cond2, D0, S, SE__bar);
   not (D0__bar, D0);
   and (cond3, D0__bar, S, SE__bar);
   and (cond4, D0__bar, D1, SE__bar);
   and (cond5, D0, D1__bar, SE__bar);
   and (cond6, D0, D1__bar, S, SI);
   and (cond7, D0__bar, D1, S__bar, SI);
   and (cond8, D0__bar, D1__bar, S, SI);
   and (cond9, D0__bar, D1__bar, S__bar, SI);
   not (SI__bar, SI);
   and (cond10, D0, D1, S, SI__bar);
   and (cond11, D0, D1, S__bar, SI__bar);
   and (cond12, D0, D1__bar, S__bar, SI__bar);
   and (cond13, D0__bar, D1, S, SI__bar);
   and (cond14, D0, D1, SE);
   and (cond15, D0, D1__bar, S, SE);
   and (cond16, D0, D1__bar, S__bar, SE);
   and (cond17, D0__bar, D1, S, SE);
   and (cond18, D0__bar, D1, S__bar, SE);
   and (cond19, D0__bar, D1__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D1, S, SE__bar);
   and (int_twire_2, D0, S__bar, SE__bar);
   or (cond20, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, SE, SI__bar);
   and (int_twire_4, D1__bar, S, SE__bar);
   and (int_twire_5, D0__bar, S__bar, SE__bar);
   or (cond21, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      (posedge CK => (SO-:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond0, negedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, posedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, negedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond2, posedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond2, negedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, posedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, negedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond4, posedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond4, negedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, posedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, negedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, negedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, posedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, negedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, posedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, negedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, posedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, negedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, posedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, negedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, posedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, negedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, posedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, negedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
      $width (posedge CK &&& cond21, 0, 0, viol_0);
      $width (negedge CK &&& cond21, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPMQO_D_1

//%BEGIN SEH_FSDPMQO_D_2

`celldefine
module SEH_FSDPMQO_D_2 (Q, SO, CK, D0, D1, S, SI, SE);
   output Q, SO;
   input CK, D0, D1, S, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D0, delayed_D1,
	delayed_S, delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, int_res__S, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D0, D0);
   buf (delayed_D1, D1);
   buf (delayed_S, S);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_D1, delayed_D0, delayed_S);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);
   dff (int_res_iq, viol_0, delayed_CK, int_res__S, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire cond21, D0__bar, D1__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire S__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (S__bar, S);
   not (SE__bar, SE);
   and (cond0, D1, S__bar, SE__bar);
   not (D1__bar, D1);
   and (cond1, D1__bar, S__bar, SE__bar);
   and (cond2, D0, S, SE__bar);
   not (D0__bar, D0);
   and (cond3, D0__bar, S, SE__bar);
   and (cond4, D0__bar, D1, SE__bar);
   and (cond5, D0, D1__bar, SE__bar);
   and (cond6, D0, D1__bar, S, SI);
   and (cond7, D0__bar, D1, S__bar, SI);
   and (cond8, D0__bar, D1__bar, S, SI);
   and (cond9, D0__bar, D1__bar, S__bar, SI);
   not (SI__bar, SI);
   and (cond10, D0, D1, S, SI__bar);
   and (cond11, D0, D1, S__bar, SI__bar);
   and (cond12, D0, D1__bar, S__bar, SI__bar);
   and (cond13, D0__bar, D1, S, SI__bar);
   and (cond14, D0, D1, SE);
   and (cond15, D0, D1__bar, S, SE);
   and (cond16, D0, D1__bar, S__bar, SE);
   and (cond17, D0__bar, D1, S, SE);
   and (cond18, D0__bar, D1, S__bar, SE);
   and (cond19, D0__bar, D1__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D1, S, SE__bar);
   and (int_twire_2, D0, S__bar, SE__bar);
   or (cond20, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, SE, SI__bar);
   and (int_twire_4, D1__bar, S, SE__bar);
   and (int_twire_5, D0__bar, S__bar, SE__bar);
   or (cond21, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      (posedge CK => (SO-:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond0, negedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, posedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, negedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond2, posedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond2, negedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, posedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, negedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond4, posedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond4, negedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, posedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, negedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, negedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, posedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, negedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, posedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, negedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, posedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, negedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, posedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, negedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, posedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, negedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, posedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, negedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
      $width (posedge CK &&& cond21, 0, 0, viol_0);
      $width (negedge CK &&& cond21, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPMQO_D_2

//%BEGIN SEH_FSDPMQO_D_4

`celldefine
module SEH_FSDPMQO_D_4 (Q, SO, CK, D0, D1, S, SI, SE);
   output Q, SO;
   input CK, D0, D1, S, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D0, delayed_D1,
	delayed_S, delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, int_res__S, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D0, D0);
   buf (delayed_D1, D1);
   buf (delayed_S, S);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_D1, delayed_D0, delayed_S);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);
   dff (int_res_iq, viol_0, delayed_CK, int_res__S, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);
    `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire cond21, D0__bar, D1__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire S__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (S__bar, S);
   not (SE__bar, SE);
   and (cond0, D1, S__bar, SE__bar);
   not (D1__bar, D1);
   and (cond1, D1__bar, S__bar, SE__bar);
   and (cond2, D0, S, SE__bar);
   not (D0__bar, D0);
   and (cond3, D0__bar, S, SE__bar);
   and (cond4, D0__bar, D1, SE__bar);
   and (cond5, D0, D1__bar, SE__bar);
   and (cond6, D0, D1__bar, S, SI);
   and (cond7, D0__bar, D1, S__bar, SI);
   and (cond8, D0__bar, D1__bar, S, SI);
   and (cond9, D0__bar, D1__bar, S__bar, SI);
   not (SI__bar, SI);
   and (cond10, D0, D1, S, SI__bar);
   and (cond11, D0, D1, S__bar, SI__bar);
   and (cond12, D0, D1__bar, S__bar, SI__bar);
   and (cond13, D0__bar, D1, S, SI__bar);
   and (cond14, D0, D1, SE);
   and (cond15, D0, D1__bar, S, SE);
   and (cond16, D0, D1__bar, S__bar, SE);
   and (cond17, D0__bar, D1, S, SE);
   and (cond18, D0__bar, D1, S__bar, SE);
   and (cond19, D0__bar, D1__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D1, S, SE__bar);
   and (int_twire_2, D0, S__bar, SE__bar);
   or (cond20, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, SE, SI__bar);
   and (int_twire_4, D1__bar, S, SE__bar);
   and (int_twire_5, D0__bar, S__bar, SE__bar);
   or (cond21, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      (posedge CK => (SO-:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond0, negedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, posedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, negedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond2, posedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond2, negedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, posedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, negedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond4, posedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond4, negedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, posedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, negedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, negedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, posedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, negedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, posedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, negedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, posedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, negedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, posedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, negedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, posedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, negedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, posedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, negedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
      $width (posedge CK &&& cond21, 0, 0, viol_0);
      $width (negedge CK &&& cond21, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPMQO_D_4

//%BEGIN SEH_FSDPMQ_D_1

`celldefine
module SEH_FSDPMQ_D_1 (Q, CK, D0, D1, S, SI, SE);
   output Q;
   input CK, D0, D1, S, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D0, delayed_D1,
	delayed_S, delayed_SI, delayed_SE;

   wire int_res__D, int_res__S, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D0, D0);
   buf (delayed_D1, D1);
   buf (delayed_S, S);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_D1, delayed_D0, delayed_S);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);

   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res__S, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res__S, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire cond21, D0__bar, D1__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire S__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (S__bar, S);
   not (SE__bar, SE);
   and (cond0, D1, S__bar, SE__bar);
   not (D1__bar, D1);
   and (cond1, D1__bar, S__bar, SE__bar);
   and (cond2, D0, S, SE__bar);
   not (D0__bar, D0);
   and (cond3, D0__bar, S, SE__bar);
   and (cond4, D0__bar, D1, SE__bar);
   and (cond5, D0, D1__bar, SE__bar);
   and (cond6, D0, D1__bar, S, SI);
   and (cond7, D0__bar, D1, S__bar, SI);
   and (cond8, D0__bar, D1__bar, S, SI);
   and (cond9, D0__bar, D1__bar, S__bar, SI);
   not (SI__bar, SI);
   and (cond10, D0, D1, S, SI__bar);
   and (cond11, D0, D1, S__bar, SI__bar);
   and (cond12, D0, D1__bar, S__bar, SI__bar);
   and (cond13, D0__bar, D1, S, SI__bar);
   and (cond14, D0, D1, SE);
   and (cond15, D0, D1__bar, S, SE);
   and (cond16, D0, D1__bar, S__bar, SE);
   and (cond17, D0__bar, D1, S, SE);
   and (cond18, D0__bar, D1, S__bar, SE);
   and (cond19, D0__bar, D1__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D1, S, SE__bar);
   and (int_twire_2, D0, S__bar, SE__bar);
   or (cond20, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, SE, SI__bar);
   and (int_twire_4, D1__bar, S, SE__bar);
   and (int_twire_5, D0__bar, S__bar, SE__bar);
   or (cond21, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond0, negedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, posedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, negedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond2, posedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond2, negedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, posedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, negedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond4, posedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond4, negedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, posedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, negedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, negedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, posedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, negedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, posedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, negedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, posedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, negedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, posedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, negedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, posedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, negedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, posedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, negedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
      $width (posedge CK &&& cond21, 0, 0, viol_0);
      $width (negedge CK &&& cond21, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPMQ_D_1

//%BEGIN SEH_FSDPMQ_D_2

`celldefine
module SEH_FSDPMQ_D_2 (Q, CK, D0, D1, S, SI, SE);
   output Q;
   input CK, D0, D1, S, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D0, delayed_D1,
	delayed_S, delayed_SI, delayed_SE;

   wire int_res__D, int_res__S, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D0, D0);
   buf (delayed_D1, D1);
   buf (delayed_S, S);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_D1, delayed_D0, delayed_S);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);

   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res__S, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res__S, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire cond21, D0__bar, D1__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire S__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (S__bar, S);
   not (SE__bar, SE);
   and (cond0, D1, S__bar, SE__bar);
   not (D1__bar, D1);
   and (cond1, D1__bar, S__bar, SE__bar);
   and (cond2, D0, S, SE__bar);
   not (D0__bar, D0);
   and (cond3, D0__bar, S, SE__bar);
   and (cond4, D0__bar, D1, SE__bar);
   and (cond5, D0, D1__bar, SE__bar);
   and (cond6, D0, D1__bar, S, SI);
   and (cond7, D0__bar, D1, S__bar, SI);
   and (cond8, D0__bar, D1__bar, S, SI);
   and (cond9, D0__bar, D1__bar, S__bar, SI);
   not (SI__bar, SI);
   and (cond10, D0, D1, S, SI__bar);
   and (cond11, D0, D1, S__bar, SI__bar);
   and (cond12, D0, D1__bar, S__bar, SI__bar);
   and (cond13, D0__bar, D1, S, SI__bar);
   and (cond14, D0, D1, SE);
   and (cond15, D0, D1__bar, S, SE);
   and (cond16, D0, D1__bar, S__bar, SE);
   and (cond17, D0__bar, D1, S, SE);
   and (cond18, D0__bar, D1, S__bar, SE);
   and (cond19, D0__bar, D1__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D1, S, SE__bar);
   and (int_twire_2, D0, S__bar, SE__bar);
   or (cond20, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, SE, SI__bar);
   and (int_twire_4, D1__bar, S, SE__bar);
   and (int_twire_5, D0__bar, S__bar, SE__bar);
   or (cond21, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond0, negedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, posedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, negedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond2, posedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond2, negedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, posedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, negedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond4, posedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond4, negedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, posedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, negedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, negedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, posedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, negedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, posedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, negedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, posedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, negedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, posedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, negedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, posedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, negedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, posedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, negedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
      $width (posedge CK &&& cond21, 0, 0, viol_0);
      $width (negedge CK &&& cond21, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPMQ_D_2

//%BEGIN SEH_FSDPMQ_D_4

`celldefine
module SEH_FSDPMQ_D_4 (Q, CK, D0, D1, S, SI, SE);
   output Q;
   input CK, D0, D1, S, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D0, delayed_D1,
	delayed_S, delayed_SI, delayed_SE;

   wire int_res__D, int_res__S, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D0, D0);
   buf (delayed_D1, D1);
   buf (delayed_S, S);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_D1, delayed_D0, delayed_S);
   mux2 (int_res__S, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__S);

   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res__S, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res__S, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire cond12, cond13, cond14;
   wire cond15, cond16, cond17;
   wire cond18, cond19, cond20;
   wire cond21, D0__bar, D1__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire S__bar, SE__bar, SI__bar;


   // Additional timing gates
   not (S__bar, S);
   not (SE__bar, SE);
   and (cond0, D1, S__bar, SE__bar);
   not (D1__bar, D1);
   and (cond1, D1__bar, S__bar, SE__bar);
   and (cond2, D0, S, SE__bar);
   not (D0__bar, D0);
   and (cond3, D0__bar, S, SE__bar);
   and (cond4, D0__bar, D1, SE__bar);
   and (cond5, D0, D1__bar, SE__bar);
   and (cond6, D0, D1__bar, S, SI);
   and (cond7, D0__bar, D1, S__bar, SI);
   and (cond8, D0__bar, D1__bar, S, SI);
   and (cond9, D0__bar, D1__bar, S__bar, SI);
   not (SI__bar, SI);
   and (cond10, D0, D1, S, SI__bar);
   and (cond11, D0, D1, S__bar, SI__bar);
   and (cond12, D0, D1__bar, S__bar, SI__bar);
   and (cond13, D0__bar, D1, S, SI__bar);
   and (cond14, D0, D1, SE);
   and (cond15, D0, D1__bar, S, SE);
   and (cond16, D0, D1__bar, S__bar, SE);
   and (cond17, D0__bar, D1, S, SE);
   and (cond18, D0__bar, D1, S__bar, SE);
   and (cond19, D0__bar, D1__bar, SE);
   and (int_twire_0, SE, SI);
   and (int_twire_1, D1, S, SE__bar);
   and (int_twire_2, D0, S__bar, SE__bar);
   or (cond20, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, SE, SI__bar);
   and (int_twire_4, D1__bar, S, SE__bar);
   and (int_twire_5, D0__bar, S__bar, SE__bar);
   or (cond21, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((D0 && SE && SI) || (D0 && !(SE) && D1) || (D0 && !(SE) && !(D1) && !(S)) || (!(D0) && SE && SI) || (!(D0) && !(SE) && D1 && S)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond0, negedge D0 &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, posedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond1, negedge D0 &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D0);
      $setuphold (posedge CK &&& cond2, posedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond2, negedge D1 &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, posedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond3, negedge D1 &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_D1);
      $setuphold (posedge CK &&& cond4, posedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond4, negedge S &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, posedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond5, negedge S &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_S);
      $setuphold (posedge CK &&& cond6, posedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond6, negedge SE &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, posedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond7, negedge SE &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, posedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond8, negedge SE &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, posedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond9, negedge SE &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, posedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond10, negedge SE &&& cond10, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, posedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond11, negedge SE &&& cond11, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, posedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond12, negedge SE &&& cond12, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, posedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond13, negedge SE &&& cond13, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond14, posedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond14, negedge SI &&& cond14, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, posedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond15, negedge SI &&& cond15, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, posedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond16, negedge SI &&& cond16, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, posedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond17, negedge SI &&& cond17, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, posedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond18, negedge SI &&& cond18, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, posedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond19, negedge SI &&& cond19, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
      $width (posedge CK &&& cond21, 0, 0, viol_0);
      $width (negedge CK &&& cond21, 0, 0, viol_0);
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_FSDPMQ_D_4

//%BEGIN SEH_FSDPQB_1

`celldefine
module SEH_FSDPQB_1 (QN, CK, D, SI, SE);
   output QN;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D, 
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (SI__bar, SI);
   and (cond0, D, SI__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI__bar);
   and (int_twire_1, D__bar, SE, SI__bar);
   and (int_twire_2, D__bar, SE__bar);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI);
   and (int_twire_4, D, SE__bar);
   and (int_twire_5, D__bar, SE, SI);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (QN+:((SE && !(SI)) || (!(SE) && !(D))))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQB_1

//%BEGIN SEH_FSDPQB_1P5

`celldefine
module SEH_FSDPQB_1P5 (QN, CK, D, SI, SE);
   output QN;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D, 
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (SI__bar, SI);
   and (cond0, D, SI__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI__bar);
   and (int_twire_1, D__bar, SE, SI__bar);
   and (int_twire_2, D__bar, SE__bar);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI);
   and (int_twire_4, D, SE__bar);
   and (int_twire_5, D__bar, SE, SI);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (QN+:((SE && !(SI)) || (!(SE) && !(D))))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQB_1P5

//%BEGIN SEH_FSDPQB_2

`celldefine
module SEH_FSDPQB_2 (QN, CK, D, SI, SE);
   output QN;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D, 
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (SI__bar, SI);
   and (cond0, D, SI__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI__bar);
   and (int_twire_1, D__bar, SE, SI__bar);
   and (int_twire_2, D__bar, SE__bar);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI);
   and (int_twire_4, D, SE__bar);
   and (int_twire_5, D__bar, SE, SI);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (QN+:((SE && !(SI)) || (!(SE) && !(D))))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQB_2

//%BEGIN SEH_FSDPQB_3

`celldefine
module SEH_FSDPQB_3 (QN, CK, D, SI, SE);
   output QN;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D, 
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (SI__bar, SI);
   and (cond0, D, SI__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI__bar);
   and (int_twire_1, D__bar, SE, SI__bar);
   and (int_twire_2, D__bar, SE__bar);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI);
   and (int_twire_4, D, SE__bar);
   and (int_twire_5, D__bar, SE, SI);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (QN+:((SE && !(SI)) || (!(SE) && !(D))))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQB_3

//%BEGIN SEH_FSDPQB_4

`celldefine
module SEH_FSDPQB_4 (QN, CK, D, SI, SE);
   output QN;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D, 
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (SI__bar, SI);
   and (cond0, D, SI__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI__bar);
   and (int_twire_1, D__bar, SE, SI__bar);
   and (int_twire_2, D__bar, SE__bar);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI);
   and (int_twire_4, D, SE__bar);
   and (int_twire_5, D__bar, SE, SI);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (QN+:((SE && !(SI)) || (!(SE) && !(D))))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQB_4

//%BEGIN SEH_FSDPQB_V2_1

`celldefine
module SEH_FSDPQB_V2_1 (QN, CK, D, SI, SE);
   output QN;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D, 
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (SI__bar, SI);
   and (cond0, D, SI__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI__bar);
   and (int_twire_1, D__bar, SE, SI__bar);
   and (int_twire_2, D__bar, SE__bar);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI);
   and (int_twire_4, D, SE__bar);
   and (int_twire_5, D__bar, SE, SI);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (QN+:((SE && !(SI)) || (!(SE) && !(D))))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQB_V2_1

//%BEGIN SEH_FSDPQB_V2_1P5

`celldefine
module SEH_FSDPQB_V2_1P5 (QN, CK, D, SI, SE);
   output QN;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D, 
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (SI__bar, SI);
   and (cond0, D, SI__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI__bar);
   and (int_twire_1, D__bar, SE, SI__bar);
   and (int_twire_2, D__bar, SE__bar);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI);
   and (int_twire_4, D, SE__bar);
   and (int_twire_5, D__bar, SE, SI);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (QN+:((SE && !(SI)) || (!(SE) && !(D))))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQB_V2_1P5

//%BEGIN SEH_FSDPQB_V2_2

`celldefine
module SEH_FSDPQB_V2_2 (QN, CK, D, SI, SE);
   output QN;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D, 
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (SI__bar, SI);
   and (cond0, D, SI__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI__bar);
   and (int_twire_1, D__bar, SE, SI__bar);
   and (int_twire_2, D__bar, SE__bar);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI);
   and (int_twire_4, D, SE__bar);
   and (int_twire_5, D__bar, SE, SI);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (QN+:((SE && !(SI)) || (!(SE) && !(D))))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQB_V2_2

//%BEGIN SEH_FSDPQB_V2_3

`celldefine
module SEH_FSDPQB_V2_3 (QN, CK, D, SI, SE);
   output QN;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D, 
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (SI__bar, SI);
   and (cond0, D, SI__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI__bar);
   and (int_twire_1, D__bar, SE, SI__bar);
   and (int_twire_2, D__bar, SE__bar);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI);
   and (int_twire_4, D, SE__bar);
   and (int_twire_5, D__bar, SE, SI);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (QN+:((SE && !(SI)) || (!(SE) && !(D))))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQB_V2_3

//%BEGIN SEH_FSDPQB_V2_4

`celldefine
module SEH_FSDPQB_V2_4 (QN, CK, D, SI, SE);
   output QN;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D, 
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        not #1 (QN, int_res_iq);
   `else
        not (QN, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (SI__bar, SI);
   and (cond0, D, SI__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI__bar);
   and (int_twire_1, D__bar, SE, SI__bar);
   and (int_twire_2, D__bar, SE__bar);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI);
   and (int_twire_4, D, SE__bar);
   and (int_twire_5, D__bar, SE, SI);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (QN+:((SE && !(SI)) || (!(SE) && !(D))))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQB_V2_4

//%BEGIN SEH_FSDPQO_1

`celldefine
module SEH_FSDPQO_1 (Q, SO, CK, D, SI, SE);
   output Q, SO;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQO_1

//%BEGIN SEH_FSDPQO_2

`celldefine
module SEH_FSDPQO_2 (Q, SO, CK, D, SI, SE);
   output Q, SO;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQO_2

//%BEGIN SEH_FSDPQO_4

`celldefine
module SEH_FSDPQO_4 (Q, SO, CK, D, SI, SE);
   output Q, SO;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQO_4

//%BEGIN SEH_FSDPQO_6

`celldefine
module SEH_FSDPQO_6 (Q, SO, CK, D, SI, SE);
   output Q, SO;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQO_6

//%BEGIN SEH_FSDPQO_8

`celldefine
module SEH_FSDPQO_8 (Q, SO, CK, D, SI, SE);
   output Q, SO;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQO_8

//%BEGIN SEH_FSDPQO_D_1

`celldefine
module SEH_FSDPQO_D_1 (Q, SO, CK, D, SI, SE);
   output Q, SO;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQO_D_1

//%BEGIN SEH_FSDPQO_D_2

`celldefine
module SEH_FSDPQO_D_2 (Q, SO, CK, D, SI, SE);
   output Q, SO;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQO_D_2

//%BEGIN SEH_FSDPQO_D_4

`celldefine
module SEH_FSDPQO_D_4 (Q, SO, CK, D, SI, SE);
   output Q, SO;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);
   dff (int_res_iq, viol_0, delayed_CK, int_res__D, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);
   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQO_D_4

//%BEGIN SEH_FSDPQ_D_1

`celldefine
module SEH_FSDPQ_D_1 (Q, CK, D, SI, SE);
   output Q;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQ_D_1

//%BEGIN SEH_FSDPQ_D_2

`celldefine
module SEH_FSDPQ_D_2 (Q, CK, D, SI, SE);
   output Q;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQ_D_2

//%BEGIN SEH_FSDPQ_D_4

`celldefine
module SEH_FSDPQ_D_4 (Q, CK, D, SI, SE);
   output Q;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQ_D_4

//%BEGIN SEH_FSDPQ_V2_1

`celldefine
module SEH_FSDPQ_V2_1 (Q, CK, D, SI, SE);
   output Q;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQ_V2_1

//%BEGIN SEH_FSDPQ_V2_1P5

`celldefine
module SEH_FSDPQ_V2_1P5 (Q, CK, D, SI, SE);
   output Q;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQ_V2_1P5

//%BEGIN SEH_FSDPQ_V2_2

`celldefine
module SEH_FSDPQ_V2_2 (Q, CK, D, SI, SE);
   output Q;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQ_V2_2

//%BEGIN SEH_FSDPQ_V2_3

`celldefine
module SEH_FSDPQ_V2_3 (Q, CK, D, SI, SE);
   output Q;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQ_V2_3

//%BEGIN SEH_FSDPQ_V2_4

`celldefine
module SEH_FSDPQ_V2_4 (Q, CK, D, SI, SE);
   output Q;
   input CK, D, SI, SE;

   reg viol_0;
   wire delayed_CK, delayed_D,
	delayed_SI, delayed_SE;

   wire int_res__D, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res__D);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff #1 (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `else
        dff (Q, viol_0, delayed_CK, int_res__D, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, SE__bar, SI__bar;


   // Additional timing gates
   not (D__bar, D);
   and (cond0, D__bar, SI);
   not (SI__bar, SI);
   and (cond1, D, SI__bar);
   and (cond2, D, SE);
   and (cond3, D__bar, SE);
   not (SE__bar, SE);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   or (cond4, int_twire_0, int_twire_1, int_twire_2);
   and (int_twire_3, D, SE, SI__bar);
   and (int_twire_4, D__bar, SE, SI__bar);
   and (int_twire_5, D__bar, SE__bar);
   or (cond5, int_twire_3, int_twire_4, int_twire_5);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& ~SE, posedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& ~SE, negedge D &&& ~SE, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, posedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond0, negedge SE &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond2, negedge SI &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $width (posedge CK &&& cond4, 0, 0, viol_0);
      $width (negedge CK &&& cond4, 0, 0, viol_0);
      $width (posedge CK &&& cond5, 0, 0, viol_0);
      $width (negedge CK &&& cond5, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPQ_V2_4

//%BEGIN SEH_FSDPRBQO_1

`celldefine
module SEH_FSDPRBQO_1 (Q, SO, CK, D, SI, SE, RD);
   output Q, SO;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);
   dff_r (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar, SI);
   not (SI__bar, SI);
   and (cond1, RD, SE__bar, SI__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SI);
   and (cond3, D, RD, SI__bar);
   and (cond4, D, RD, SE);
   and (cond5, D__bar, RD, SE);
   and (cond6, D, SE, SI);
   and (cond7, D, SE__bar, SI);
   and (cond8, D, SE__bar, SI__bar);
   and (cond9, D__bar, SE, SI);
   and (cond10, CK, D, SE, SI);
   and (cond11, CK, SE, SI__bar);
   and (cond12, CK, D, SE__bar, SI);
   and (cond13, CK, D, SE__bar, SI__bar);
   and (cond14, CK, D__bar, SE, SI);
   and (cond15, CK, D__bar, SE__bar, SI);
   and (cond16, CK, D__bar, SE__bar, SI__bar);
   not (CK__bar, CK);
   and (cond17, CK__bar, D, SE, SI);
   and (cond18, CK__bar, D, SE, SI__bar);
   and (cond19, CK__bar, D, SE__bar, SI);
   and (cond20, CK__bar, D, SE__bar, SI__bar);
   and (cond21, CK__bar, D__bar, SE, SI);
   and (cond22, CK__bar, D__bar, SE, SI__bar);
   and (cond23, CK__bar, D__bar, SE__bar, SI);
   and (cond24, CK__bar, D__bar, SE__bar, SI__bar);
   and (int_twire_0, RD, SE, SI);
   and (int_twire_1, D, RD, SE__bar);
   or (cond25, int_twire_0, int_twire_1);
   and (int_twire_2, RD, SE, SI__bar);
   and (int_twire_3, D__bar, RD, SE__bar);
   or (cond26, int_twire_2, int_twire_3);

   specify
      if ((CK & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & D & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, negedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $recovery (posedge RD &&& cond8, posedge CK &&& cond8, 0, viol_0);
      $recovery (posedge RD &&& cond9, posedge CK &&& cond9, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond8, posedge RD &&& cond8, 0, viol_0);
      $hold (posedge CK &&& cond9, posedge RD &&& cond9, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge RD &&& cond13, 0, 0, viol_0);
      $width (negedge RD &&& cond14, 0, 0, viol_0);
      $width (negedge RD &&& cond15, 0, 0, viol_0);
      $width (negedge RD &&& cond16, 0, 0, viol_0);
      $width (negedge RD &&& cond17, 0, 0, viol_0);
      $width (negedge RD &&& cond18, 0, 0, viol_0);
      $width (negedge RD &&& cond19, 0, 0, viol_0);
      $width (negedge RD &&& cond20, 0, 0, viol_0);
      $width (negedge RD &&& cond21, 0, 0, viol_0);
      $width (negedge RD &&& cond22, 0, 0, viol_0);
      $width (negedge RD &&& cond23, 0, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (posedge CK &&& cond25, 0, 0, viol_0);
      $width (negedge CK &&& cond25, 0, 0, viol_0);
      $width (posedge CK &&& cond26, 0, 0, viol_0);
      $width (negedge CK &&& cond26, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQO_1

//%BEGIN SEH_FSDPRBQO_2

`celldefine
module SEH_FSDPRBQO_2 (Q, SO, CK, D, SI, SE, RD);
   output Q, SO;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);
   dff_r (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar, SI);
   not (SI__bar, SI);
   and (cond1, RD, SE__bar, SI__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SI);
   and (cond3, D, RD, SI__bar);
   and (cond4, D, RD, SE);
   and (cond5, D__bar, RD, SE);
   and (cond6, D, SE, SI);
   and (cond7, D, SE__bar, SI);
   and (cond8, D, SE__bar, SI__bar);
   and (cond9, D__bar, SE, SI);
   and (cond10, CK, D, SE, SI);
   and (cond11, CK, SE, SI__bar);
   and (cond12, CK, D, SE__bar, SI);
   and (cond13, CK, D, SE__bar, SI__bar);
   and (cond14, CK, D__bar, SE, SI);
   and (cond15, CK, D__bar, SE__bar, SI);
   and (cond16, CK, D__bar, SE__bar, SI__bar);
   not (CK__bar, CK);
   and (cond17, CK__bar, D, SE, SI);
   and (cond18, CK__bar, D, SE, SI__bar);
   and (cond19, CK__bar, D, SE__bar, SI);
   and (cond20, CK__bar, D, SE__bar, SI__bar);
   and (cond21, CK__bar, D__bar, SE, SI);
   and (cond22, CK__bar, D__bar, SE, SI__bar);
   and (cond23, CK__bar, D__bar, SE__bar, SI);
   and (cond24, CK__bar, D__bar, SE__bar, SI__bar);
   and (int_twire_0, RD, SE, SI);
   and (int_twire_1, D, RD, SE__bar);
   or (cond25, int_twire_0, int_twire_1);
   and (int_twire_2, RD, SE, SI__bar);
   and (int_twire_3, D__bar, RD, SE__bar);
   or (cond26, int_twire_2, int_twire_3);

   specify
      if ((CK & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & D & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, negedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $recovery (posedge RD &&& cond8, posedge CK &&& cond8, 0, viol_0);
      $recovery (posedge RD &&& cond9, posedge CK &&& cond9, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond8, posedge RD &&& cond8, 0, viol_0);
      $hold (posedge CK &&& cond9, posedge RD &&& cond9, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge RD &&& cond13, 0, 0, viol_0);
      $width (negedge RD &&& cond14, 0, 0, viol_0);
      $width (negedge RD &&& cond15, 0, 0, viol_0);
      $width (negedge RD &&& cond16, 0, 0, viol_0);
      $width (negedge RD &&& cond17, 0, 0, viol_0);
      $width (negedge RD &&& cond18, 0, 0, viol_0);
      $width (negedge RD &&& cond19, 0, 0, viol_0);
      $width (negedge RD &&& cond20, 0, 0, viol_0);
      $width (negedge RD &&& cond21, 0, 0, viol_0);
      $width (negedge RD &&& cond22, 0, 0, viol_0);
      $width (negedge RD &&& cond23, 0, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (posedge CK &&& cond25, 0, 0, viol_0);
      $width (negedge CK &&& cond25, 0, 0, viol_0);
      $width (posedge CK &&& cond26, 0, 0, viol_0);
      $width (negedge CK &&& cond26, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQO_2

//%BEGIN SEH_FSDPRBQO_4

`celldefine
module SEH_FSDPRBQO_4 (Q, SO, CK, D, SI, SE, RD);
   output Q, SO;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);
   dff_r (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar, SI);
   not (SI__bar, SI);
   and (cond1, RD, SE__bar, SI__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SI);
   and (cond3, D, RD, SI__bar);
   and (cond4, D, RD, SE);
   and (cond5, D__bar, RD, SE);
   and (cond6, D, SE, SI);
   and (cond7, D, SE__bar, SI);
   and (cond8, D, SE__bar, SI__bar);
   and (cond9, D__bar, SE, SI);
   and (cond10, CK, D, SE, SI);
   and (cond11, CK, SE, SI__bar);
   and (cond12, CK, D, SE__bar, SI);
   and (cond13, CK, D, SE__bar, SI__bar);
   and (cond14, CK, D__bar, SE, SI);
   and (cond15, CK, D__bar, SE__bar, SI);
   and (cond16, CK, D__bar, SE__bar, SI__bar);
   not (CK__bar, CK);
   and (cond17, CK__bar, D, SE, SI);
   and (cond18, CK__bar, D, SE, SI__bar);
   and (cond19, CK__bar, D, SE__bar, SI);
   and (cond20, CK__bar, D, SE__bar, SI__bar);
   and (cond21, CK__bar, D__bar, SE, SI);
   and (cond22, CK__bar, D__bar, SE, SI__bar);
   and (cond23, CK__bar, D__bar, SE__bar, SI);
   and (cond24, CK__bar, D__bar, SE__bar, SI__bar);
   and (int_twire_0, RD, SE, SI);
   and (int_twire_1, D, RD, SE__bar);
   or (cond25, int_twire_0, int_twire_1);
   and (int_twire_2, RD, SE, SI__bar);
   and (int_twire_3, D__bar, RD, SE__bar);
   or (cond26, int_twire_2, int_twire_3);

   specify
      if ((CK & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & D & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, negedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $recovery (posedge RD &&& cond8, posedge CK &&& cond8, 0, viol_0);
      $recovery (posedge RD &&& cond9, posedge CK &&& cond9, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond8, posedge RD &&& cond8, 0, viol_0);
      $hold (posedge CK &&& cond9, posedge RD &&& cond9, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge RD &&& cond13, 0, 0, viol_0);
      $width (negedge RD &&& cond14, 0, 0, viol_0);
      $width (negedge RD &&& cond15, 0, 0, viol_0);
      $width (negedge RD &&& cond16, 0, 0, viol_0);
      $width (negedge RD &&& cond17, 0, 0, viol_0);
      $width (negedge RD &&& cond18, 0, 0, viol_0);
      $width (negedge RD &&& cond19, 0, 0, viol_0);
      $width (negedge RD &&& cond20, 0, 0, viol_0);
      $width (negedge RD &&& cond21, 0, 0, viol_0);
      $width (negedge RD &&& cond22, 0, 0, viol_0);
      $width (negedge RD &&& cond23, 0, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (posedge CK &&& cond25, 0, 0, viol_0);
      $width (negedge CK &&& cond25, 0, 0, viol_0);
      $width (posedge CK &&& cond26, 0, 0, viol_0);
      $width (negedge CK &&& cond26, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQO_4

//%BEGIN SEH_FSDPRBQO_6

`celldefine
module SEH_FSDPRBQO_6 (Q, SO, CK, D, SI, SE, RD);
   output Q, SO;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);
   dff_r (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar, SI);
   not (SI__bar, SI);
   and (cond1, RD, SE__bar, SI__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SI);
   and (cond3, D, RD, SI__bar);
   and (cond4, D, RD, SE);
   and (cond5, D__bar, RD, SE);
   and (cond6, D, SE, SI);
   and (cond7, D, SE__bar, SI);
   and (cond8, D, SE__bar, SI__bar);
   and (cond9, D__bar, SE, SI);
   and (cond10, CK, D, SE, SI);
   and (cond11, CK, SE, SI__bar);
   and (cond12, CK, D, SE__bar, SI);
   and (cond13, CK, D, SE__bar, SI__bar);
   and (cond14, CK, D__bar, SE, SI);
   and (cond15, CK, D__bar, SE__bar, SI);
   and (cond16, CK, D__bar, SE__bar, SI__bar);
   not (CK__bar, CK);
   and (cond17, CK__bar, D, SE, SI);
   and (cond18, CK__bar, D, SE, SI__bar);
   and (cond19, CK__bar, D, SE__bar, SI);
   and (cond20, CK__bar, D, SE__bar, SI__bar);
   and (cond21, CK__bar, D__bar, SE, SI);
   and (cond22, CK__bar, D__bar, SE, SI__bar);
   and (cond23, CK__bar, D__bar, SE__bar, SI);
   and (cond24, CK__bar, D__bar, SE__bar, SI__bar);
   and (int_twire_0, RD, SE, SI);
   and (int_twire_1, D, RD, SE__bar);
   or (cond25, int_twire_0, int_twire_1);
   and (int_twire_2, RD, SE, SI__bar);
   and (int_twire_3, D__bar, RD, SE__bar);
   or (cond26, int_twire_2, int_twire_3);

   specify
      if ((CK & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & D & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, negedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $recovery (posedge RD &&& cond8, posedge CK &&& cond8, 0, viol_0);
      $recovery (posedge RD &&& cond9, posedge CK &&& cond9, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond8, posedge RD &&& cond8, 0, viol_0);
      $hold (posedge CK &&& cond9, posedge RD &&& cond9, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge RD &&& cond13, 0, 0, viol_0);
      $width (negedge RD &&& cond14, 0, 0, viol_0);
      $width (negedge RD &&& cond15, 0, 0, viol_0);
      $width (negedge RD &&& cond16, 0, 0, viol_0);
      $width (negedge RD &&& cond17, 0, 0, viol_0);
      $width (negedge RD &&& cond18, 0, 0, viol_0);
      $width (negedge RD &&& cond19, 0, 0, viol_0);
      $width (negedge RD &&& cond20, 0, 0, viol_0);
      $width (negedge RD &&& cond21, 0, 0, viol_0);
      $width (negedge RD &&& cond22, 0, 0, viol_0);
      $width (negedge RD &&& cond23, 0, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (posedge CK &&& cond25, 0, 0, viol_0);
      $width (negedge CK &&& cond25, 0, 0, viol_0);
      $width (posedge CK &&& cond26, 0, 0, viol_0);
      $width (negedge CK &&& cond26, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQO_6

//%BEGIN SEH_FSDPRBQO_8

`celldefine
module SEH_FSDPRBQO_8 (Q, SO, CK, D, SI, SE, RD);
   output Q, SO;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);
   dff_r (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, cond21, cond22;
   wire cond23, cond24, cond25;
   wire cond26, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar, SI);
   not (SI__bar, SI);
   and (cond1, RD, SE__bar, SI__bar);
   not (D__bar, D);
   and (cond2, D__bar, RD, SI);
   and (cond3, D, RD, SI__bar);
   and (cond4, D, RD, SE);
   and (cond5, D__bar, RD, SE);
   and (cond6, D, SE, SI);
   and (cond7, D, SE__bar, SI);
   and (cond8, D, SE__bar, SI__bar);
   and (cond9, D__bar, SE, SI);
   and (cond10, CK, D, SE, SI);
   and (cond11, CK, SE, SI__bar);
   and (cond12, CK, D, SE__bar, SI);
   and (cond13, CK, D, SE__bar, SI__bar);
   and (cond14, CK, D__bar, SE, SI);
   and (cond15, CK, D__bar, SE__bar, SI);
   and (cond16, CK, D__bar, SE__bar, SI__bar);
   not (CK__bar, CK);
   and (cond17, CK__bar, D, SE, SI);
   and (cond18, CK__bar, D, SE, SI__bar);
   and (cond19, CK__bar, D, SE__bar, SI);
   and (cond20, CK__bar, D, SE__bar, SI__bar);
   and (cond21, CK__bar, D__bar, SE, SI);
   and (cond22, CK__bar, D__bar, SE, SI__bar);
   and (cond23, CK__bar, D__bar, SE__bar, SI);
   and (cond24, CK__bar, D__bar, SE__bar, SI__bar);
   and (int_twire_0, RD, SE, SI);
   and (int_twire_1, D, RD, SE__bar);
   or (cond25, int_twire_0, int_twire_1);
   and (int_twire_2, RD, SE, SI__bar);
   and (int_twire_3, D__bar, RD, SE__bar);
   or (cond26, int_twire_2, int_twire_3);

   specify
      if ((CK & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & SE & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & D & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & D & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & SE & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(D) & ~(SE) & ~(SI)))
         (negedge RD => (SO-:1'b1)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, negedge D &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $recovery (posedge RD &&& cond8, posedge CK &&& cond8, 0, viol_0);
      $recovery (posedge RD &&& cond9, posedge CK &&& cond9, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond8, posedge RD &&& cond8, 0, viol_0);
      $hold (posedge CK &&& cond9, posedge RD &&& cond9, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge RD &&& cond13, 0, 0, viol_0);
      $width (negedge RD &&& cond14, 0, 0, viol_0);
      $width (negedge RD &&& cond15, 0, 0, viol_0);
      $width (negedge RD &&& cond16, 0, 0, viol_0);
      $width (negedge RD &&& cond17, 0, 0, viol_0);
      $width (negedge RD &&& cond18, 0, 0, viol_0);
      $width (negedge RD &&& cond19, 0, 0, viol_0);
      $width (negedge RD &&& cond20, 0, 0, viol_0);
      $width (negedge RD &&& cond21, 0, 0, viol_0);
      $width (negedge RD &&& cond22, 0, 0, viol_0);
      $width (negedge RD &&& cond23, 0, 0, viol_0);
      $width (negedge RD &&& cond24, 0, 0, viol_0);
      $width (posedge CK &&& cond25, 0, 0, viol_0);
      $width (negedge CK &&& cond25, 0, 0, viol_0);
      $width (posedge CK &&& cond26, 0, 0, viol_0);
      $width (negedge CK &&& cond26, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQO_8

//%BEGIN SEH_FSDPRBQO_D_1

`celldefine
module SEH_FSDPRBQO_D_1 (Q, SO, CK, D, SI, SE, RD);
   output Q, SO;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);
   dff_r (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if (CK)
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQO_D_1

//%BEGIN SEH_FSDPRBQO_D_2

`celldefine
module SEH_FSDPRBQO_D_2 (Q, SO, CK, D, SI, SE, RD);
   output Q, SO;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);
   dff_r (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if (CK)
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQO_D_2

//%BEGIN SEH_FSDPRBQO_D_4

`celldefine
module SEH_FSDPRBQO_D_4 (Q, SO, CK, D, SI, SE, RD);
   output Q, SO;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);
   dff_r (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        buf #1 (Q, int_res_iq);
        buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if (CK)
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQO_D_4

//%BEGIN SEH_FSDPRBQ_D_1

`celldefine
module SEH_FSDPRBQ_D_1 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `else
        dff_r (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQ_D_1

//%BEGIN SEH_FSDPRBQ_D_2

`celldefine
module SEH_FSDPRBQ_D_2 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `else
        dff_r (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQ_D_2

//%BEGIN SEH_FSDPRBQ_D_4

`celldefine
module SEH_FSDPRBQ_D_4 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `else
        dff_r (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQ_D_4

//%BEGIN SEH_FSDPRBQ_V2_1

`celldefine
module SEH_FSDPRBQ_V2_1 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `else
        dff_r (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQ_V2_1

//%BEGIN SEH_FSDPRBQ_V2_1P5

`celldefine
module SEH_FSDPRBQ_V2_1P5 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `else
        dff_r (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQ_V2_1P5

//%BEGIN SEH_FSDPRBQ_V2_2

`celldefine
module SEH_FSDPRBQ_V2_2 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `else
        dff_r (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQ_V2_2

//%BEGIN SEH_FSDPRBQ_V2_3

`celldefine
module SEH_FSDPRBQ_V2_3 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `else
        dff_r (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQ_V2_3

//%BEGIN SEH_FSDPRBQ_V2_4

`celldefine
module SEH_FSDPRBQ_V2_4 (Q, CK, D, SI, SE, RD);
   output Q;
   input CK, D, SI, SE, RD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD;

   wire int_res__D, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__RD, delayed_RD);
   dff_r_err (xcr_0, delayed_CK, int_res__D, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_r #1 (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `else
        dff_r (Q, viol_0, delayed_CK, int_res__D, int_res__RD, xcr_0);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SI__bar);
   and (cond3, D, RD, SE);
   and (cond4, D__bar, RD, SE);
   and (cond5, D, SE, SI);
   and (cond6, D, SE__bar);
   and (cond7, D__bar, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, RD, SE, SI);
   and (int_twire_5, D, RD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, RD, SE, SI__bar);
   and (int_twire_7, D__bar, RD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $width (negedge RD &&& CK, 0, 0, viol_0);
      $width (negedge RD &&& cond8, 0, 0, viol_0);
      $width (negedge RD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBQ_V2_4

//%BEGIN SEH_FSDPRBSBQO_1

`celldefine
module SEH_FSDPRBSBQO_1 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQO_1

//%BEGIN SEH_FSDPRBSBQO_2

`celldefine
module SEH_FSDPRBSBQO_2 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQO_2

//%BEGIN SEH_FSDPRBSBQO_4

`celldefine
module SEH_FSDPRBSBQO_4 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQO_4

//%BEGIN SEH_FSDPRBSBQO_6

`celldefine
module SEH_FSDPRBSBQO_6 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQO_6

//%BEGIN SEH_FSDPRBSBQO_8

`celldefine
module SEH_FSDPRBSBQO_8 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQO_8

//%BEGIN SEH_FSDPRBSBQO_CTY2_4

`celldefine
module SEH_FSDPRBSBQO_CTY2_4 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((D && SE && SI) || (D && !(SE)) || (!(D) && SE && SI)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((D && SE && SI) || (D && !(SE)) || (!(D) && SE && SI)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond8, posedge SD &&& cond8, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond9, posedge SD &&& cond9, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQO_CTY2_4

//%BEGIN SEH_FSDPRBSBQO_D_1

`celldefine
module SEH_FSDPRBSBQO_D_1 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond8, posedge SD &&& cond8, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond9, posedge SD &&& cond9, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQO_D_1

//%BEGIN SEH_FSDPRBSBQO_D_2

`celldefine
module SEH_FSDPRBSBQO_D_2 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond8, posedge SD &&& cond8, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond9, posedge SD &&& cond9, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQO_D_2

//%BEGIN SEH_FSDPRBSBQO_D_4

`celldefine
module SEH_FSDPRBSBQO_D_4 (Q, SO, CK, D, SI, SE, RD, SD);
   output Q, SO;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);
   dff_sr_0 (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);
   `else
       buf (Q, int_res_iq);
       buf (SO, int_res_iq);
   `endif

   `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if ((CK & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (SO-:1'b0)) = 0;
      if ((CK & SD))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (SO-:1'b1)) = 0;
      if ((CK & RD))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond8, posedge SD &&& cond8, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond9, posedge SD &&& cond9, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQO_D_4

//%BEGIN SEH_FSDPRBSBQ_D_1

`celldefine
module SEH_FSDPRBSBQ_D_1 (Q, CK, D, SI, SE, RD, SD);
   output Q;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_sr_0 #1 (Q, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);
   `else
        dff_sr_0 (Q, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);
    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond8, posedge SD &&& cond8, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond9, posedge SD &&& cond9, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQ_D_1

//%BEGIN SEH_FSDPRBSBQ_D_2

`celldefine
module SEH_FSDPRBSBQ_D_2 (Q, CK, D, SI, SE, RD, SD);
   output Q;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_sr_0 #1 (Q, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);
   `else
        dff_sr_0 (Q, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);
    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond8, posedge SD &&& cond8, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond9, posedge SD &&& cond9, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQ_D_2

//%BEGIN SEH_FSDPRBSBQ_D_4

`celldefine
module SEH_FSDPRBSBQ_D_4 (Q, CK, D, SI, SE, RD, SD);
   output Q;
   input CK, D, SI, SE, RD, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_RD, delayed_SD;

   wire int_res__D, int_res__SD, int_res__RD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_RD, RD);
   buf (delayed_SD, SD);
`endif

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   not (int_res__RD, delayed_RD);
   dff_sr_err (xcr_0, delayed_CK, int_res__D, int_res__SD, int_res__RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_sr_0 #1 (Q, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);
   `else
        dff_sr_0 (Q, viol_0, delayed_CK, int_res__D, int_res__SD, int_res__RD, xcr_0);
    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, cond12, cond13;
   wire cond14, cond15, cond16;
   wire cond17, cond18, cond19;
   wire cond20, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, int_twire_8, int_twire_9;
   wire int_twire_10, int_twire_11, int_twire_12;
   wire int_twire_13, int_twire_14, int_twire_15;
   wire SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, RD, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, RD, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, RD, SD, SI__bar);
   and (cond3, D, RD, SD, SE);
   and (cond4, D__bar, RD, SD, SE);
   and (cond5, D, SD, SE, SI);
   and (cond6, D, SD, SE__bar);
   and (cond7, D__bar, SD, SE, SI);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (cond10, CK, SD);
   and (int_twire_4, CK__bar, SD, SE, SI);
   and (int_twire_5, CK__bar, D, SD, SE__bar);
   or (cond11, int_twire_4, int_twire_5);
   and (int_twire_6, CK__bar, SD, SE, SI__bar);
   and (int_twire_7, CK__bar, D__bar, SD, SE__bar);
   or (cond12, int_twire_6, int_twire_7);
   and (cond13, D, RD, SE, SI__bar);
   and (cond14, D__bar, RD, SE, SI__bar);
   and (cond15, D__bar, RD, SE__bar);
   and (cond16, CK, RD);
   and (int_twire_8, CK__bar, RD, SE, SI);
   and (int_twire_9, CK__bar, D, RD, SE__bar);
   or (cond17, int_twire_8, int_twire_9);
   and (int_twire_10, CK__bar, RD, SE, SI__bar);
   and (int_twire_11, CK__bar, D__bar, RD, SE__bar);
   or (cond18, int_twire_10, int_twire_11);
   and (int_twire_12, RD, SD, SE, SI);
   and (int_twire_13, D, RD, SD, SE__bar);
   or (cond19, int_twire_12, int_twire_13);
   and (int_twire_14, RD, SD, SE, SI__bar);
   and (int_twire_15, D__bar, RD, SD, SE__bar);
   or (cond20, int_twire_14, int_twire_15);

   specify
      if ((CK & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((~(CK) & ~(SD)))
         (posedge RD => (Q+:1'b1)) = 0;
      if ((CK & SD))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & SI) | (~(CK) & D & SD & ~(SE)) | (~(CK) & ~(D) & SD & SE & SI))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & D & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & SE & ~(SI)) | (~(CK) & ~(D) & SD & ~(SE)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(CK) & ~(SD)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((CK & RD))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & SI) | (~(CK) & D & RD & ~(SE)) | (~(CK) & ~(D) & RD & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & SE & ~(SI)) | (~(CK) & ~(D) & RD & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge SD &&& CK, posedge RD &&& CK, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond8, posedge RD &&& cond8, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge SD &&& cond9, posedge RD &&& cond9, 0, 0, viol_0,,, delayed_SD, delayed_RD);
      $setuphold (posedge RD &&& CK, posedge SD &&& CK, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond8, posedge SD &&& cond8, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $setuphold (posedge RD &&& cond9, posedge SD &&& cond9, 0, 0, viol_0,,, delayed_RD, delayed_SD);
      $recovery (posedge RD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge RD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge RD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge RD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge RD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge RD &&& cond7, 0, viol_0);
      $recovery (posedge SD &&& cond13, posedge CK &&& cond13, 0, viol_0);
      $recovery (posedge SD &&& cond14, posedge CK &&& cond14, 0, viol_0);
      $recovery (posedge SD &&& cond15, posedge CK &&& cond15, 0, viol_0);
      $hold (posedge CK &&& cond13, posedge SD &&& cond13, 0, viol_0);
      $hold (posedge CK &&& cond14, posedge SD &&& cond14, 0, viol_0);
      $hold (posedge CK &&& cond15, posedge SD &&& cond15, 0, viol_0);
      $width (negedge RD &&& cond10, 0, 0, viol_0);
      $width (negedge RD &&& cond11, 0, 0, viol_0);
      $width (negedge RD &&& cond12, 0, 0, viol_0);
      $width (negedge SD &&& cond16, 0, 0, viol_0);
      $width (negedge SD &&& cond17, 0, 0, viol_0);
      $width (negedge SD &&& cond18, 0, 0, viol_0);
      $width (posedge CK &&& cond19, 0, 0, viol_0);
      $width (negedge CK &&& cond19, 0, 0, viol_0);
      $width (posedge CK &&& cond20, 0, 0, viol_0);
      $width (negedge CK &&& cond20, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_FSDPRBSBQ_D_4

//%BEGIN SEH_FSDPSBQO_1

`celldefine
module SEH_FSDPSBQO_1 (Q, SO, CK, D, SI, SE, SD);
   output Q, SO;
   input CK, D, SI, SE, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SD;

   wire int_res__D, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, int_res__D, int_res__SD);
   dff_s (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, SD, SI__bar);
   and (cond3, D, SD, SE);
   and (cond4, D__bar, SD, SE);
   and (cond5, D, SE, SI__bar);
   and (cond6, D__bar, SE, SI__bar);
   and (cond7, D__bar, SE__bar);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, SD, SE, SI);
   and (int_twire_5, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, SD, SE, SI__bar);
   and (int_twire_7, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if (CK)
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge SD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge SD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge SD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge SD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPSBQO_1

//%BEGIN SEH_FSDPSBQO_2

`celldefine
module SEH_FSDPSBQO_2 (Q, SO, CK, D, SI, SE, SD);
   output Q, SO;
   input CK, D, SI, SE, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SD;

   wire int_res__D, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, int_res__D, int_res__SD);
   dff_s (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, SD, SI__bar);
   and (cond3, D, SD, SE);
   and (cond4, D__bar, SD, SE);
   and (cond5, D, SE, SI__bar);
   and (cond6, D__bar, SE, SI__bar);
   and (cond7, D__bar, SE__bar);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, SD, SE, SI);
   and (int_twire_5, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, SD, SE, SI__bar);
   and (int_twire_7, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if (CK)
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge SD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge SD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge SD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge SD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPSBQO_2

//%BEGIN SEH_FSDPSBQO_4

`celldefine
module SEH_FSDPSBQO_4 (Q, SO, CK, D, SI, SE, SD);
   output Q, SO;
   input CK, D, SI, SE, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SD;

   wire int_res__D, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, int_res__D, int_res__SD);
   dff_s (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, SD, SI__bar);
   and (cond3, D, SD, SE);
   and (cond4, D__bar, SD, SE);
   and (cond5, D, SE, SI__bar);
   and (cond6, D__bar, SE, SI__bar);
   and (cond7, D__bar, SE__bar);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, SD, SE, SI);
   and (int_twire_5, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, SD, SE, SI__bar);
   and (int_twire_7, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if (CK)
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge SD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge SD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge SD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge SD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPSBQO_4

//%BEGIN SEH_FSDPSBQO_6

`celldefine
module SEH_FSDPSBQO_6 (Q, SO, CK, D, SI, SE, SD);
   output Q, SO;
   input CK, D, SI, SE, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SD;

   wire int_res__D, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, int_res__D, int_res__SD);
   dff_s (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, SD, SI__bar);
   and (cond3, D, SD, SE);
   and (cond4, D__bar, SD, SE);
   and (cond5, D, SE, SI__bar);
   and (cond6, D__bar, SE, SI__bar);
   and (cond7, D__bar, SE__bar);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, SD, SE, SI);
   and (int_twire_5, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, SD, SE, SI__bar);
   and (int_twire_7, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if (CK)
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge SD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge SD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge SD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge SD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPSBQO_6

//%BEGIN SEH_FSDPSBQO_8

`celldefine
module SEH_FSDPSBQO_8 (Q, SO, CK, D, SI, SE, SD);
   output Q, SO;
   input CK, D, SI, SE, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SD;

   wire int_res__D, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, int_res__D, int_res__SD);
   dff_s (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, SD, SI__bar);
   and (cond3, D, SD, SE);
   and (cond4, D__bar, SD, SE);
   and (cond5, D, SE, SI__bar);
   and (cond6, D__bar, SE, SI__bar);
   and (cond7, D__bar, SE__bar);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, SD, SE, SI);
   and (int_twire_5, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, SD, SE, SI__bar);
   and (int_twire_7, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if (CK)
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge SD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge SD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge SD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge SD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPSBQO_8

//%BEGIN SEH_FSDPSBQO_D_1

`celldefine
module SEH_FSDPSBQO_D_1 (Q, SO, CK, D, SI, SE, SD);
   output Q, SO;
   input CK, D, SI, SE, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SD;

   wire int_res__D, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, int_res__D, int_res__SD);
   dff_s (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, SD, SI__bar);
   and (cond3, D, SD, SE);
   and (cond4, D__bar, SD, SE);
   and (cond5, D, SE, SI__bar);
   and (cond6, D__bar, SE, SI__bar);
   and (cond7, D__bar, SE__bar);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, SD, SE, SI);
   and (int_twire_5, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, SD, SE, SI__bar);
   and (int_twire_7, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if (CK)
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge SD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge SD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge SD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge SD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPSBQO_D_1

//%BEGIN SEH_FSDPSBQO_D_2

`celldefine
module SEH_FSDPSBQO_D_2 (Q, SO, CK, D, SI, SE, SD);
   output Q, SO;
   input CK, D, SI, SE, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SD;

   wire int_res__D, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, int_res__D, int_res__SD);
   dff_s (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, SD, SI__bar);
   and (cond3, D, SD, SE);
   and (cond4, D__bar, SD, SE);
   and (cond5, D, SE, SI__bar);
   and (cond6, D__bar, SE, SI__bar);
   and (cond7, D__bar, SE__bar);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, SD, SE, SI);
   and (int_twire_5, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, SD, SE, SI__bar);
   and (int_twire_7, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if (CK)
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge SD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge SD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge SD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge SD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPSBQO_D_2

//%BEGIN SEH_FSDPSBQO_D_4

`celldefine
module SEH_FSDPSBQO_D_4 (Q, SO, CK, D, SI, SE, SD);
   output Q, SO;
   input CK, D, SI, SE, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SD;

   wire int_res__D, int_res__SD, int_res_iq, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, int_res__D, int_res__SD);
   dff_s (int_res_iq, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       buf #1 (Q, int_res_iq);
       buf #1 (SO, int_res_iq);

   `else
        buf (Q, int_res_iq);
        buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, SD, SI__bar);
   and (cond3, D, SD, SE);
   and (cond4, D__bar, SD, SE);
   and (cond5, D, SE, SI__bar);
   and (cond6, D__bar, SE, SI__bar);
   and (cond7, D__bar, SE__bar);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, SD, SE, SI);
   and (int_twire_5, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, SD, SE, SI__bar);
   and (int_twire_7, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      if (CK)
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (SO-:1'b0)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (SO-:1'b0)) = 0;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge SD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge SD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge SD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge SD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPSBQO_D_4

//%BEGIN SEH_FSDPSBQ_D_1

`celldefine
module SEH_FSDPSBQ_D_1 (Q, CK, D, SI, SE, SD);
   output Q;
   input CK, D, SI, SE, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SD;

   wire int_res__D, int_res__SD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, int_res__D, int_res__SD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_s #1 (Q, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

    `else
        dff_s (Q, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, SD, SI__bar);
   and (cond3, D, SD, SE);
   and (cond4, D__bar, SD, SE);
   and (cond5, D, SE, SI__bar);
   and (cond6, D__bar, SE, SI__bar);
   and (cond7, D__bar, SE__bar);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, SD, SE, SI);
   and (int_twire_5, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, SD, SE, SI__bar);
   and (int_twire_7, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge SD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge SD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge SD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge SD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_FSDPSBQ_D_1

//%BEGIN SEH_FSDPSBQ_D_2

`celldefine
module SEH_FSDPSBQ_D_2 (Q, CK, D, SI, SE, SD);
   output Q;
   input CK, D, SI, SE, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SD;

   wire int_res__D, int_res__SD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, int_res__D, int_res__SD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_s #1 (Q, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

    `else
        dff_s (Q, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, SD, SI__bar);
   and (cond3, D, SD, SE);
   and (cond4, D__bar, SD, SE);
   and (cond5, D, SE, SI__bar);
   and (cond6, D__bar, SE, SI__bar);
   and (cond7, D__bar, SE__bar);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, SD, SE, SI);
   and (int_twire_5, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, SD, SE, SI__bar);
   and (int_twire_7, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge SD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge SD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge SD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge SD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_FSDPSBQ_D_2

//%BEGIN SEH_FSDPSBQ_D_4

`celldefine
module SEH_FSDPSBQ_D_4 (Q, CK, D, SI, SE, SD);
   output Q;
   input CK, D, SI, SE, SD;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SD;

   wire int_res__D, int_res__SD, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
`endif
   buf (delayed_SD, SD);

   mux2 (int_res__D, delayed_SI, delayed_D, delayed_SE);
   not (int_res__SD, delayed_SD);
   dff_s_err (xcr_0, delayed_CK, int_res__D, int_res__SD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        dff_s #1 (Q, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

    `else
        dff_s (Q, viol_0, delayed_CK, int_res__D, int_res__SD, xcr_0);

    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire CK__bar, cond0, cond1;
   wire cond2, cond3, cond4;
   wire cond5, cond6, cond7;
   wire cond8, cond9, cond10;
   wire cond11, D__bar, int_twire_0;
   wire int_twire_1, int_twire_2, int_twire_3;
   wire int_twire_4, int_twire_5, int_twire_6;
   wire int_twire_7, SE__bar, SI__bar;


   // Additional timing gates
   not (SE__bar, SE);
   and (cond0, SD, SE__bar);
   not (D__bar, D);
   and (cond1, D__bar, SD, SI);
   not (SI__bar, SI);
   and (cond2, D, SD, SI__bar);
   and (cond3, D, SD, SE);
   and (cond4, D__bar, SD, SE);
   and (cond5, D, SE, SI__bar);
   and (cond6, D__bar, SE, SI__bar);
   and (cond7, D__bar, SE__bar);
   not (CK__bar, CK);
   and (int_twire_0, CK__bar, SE, SI);
   and (int_twire_1, CK__bar, D, SE__bar);
   or (cond8, int_twire_0, int_twire_1);
   and (int_twire_2, CK__bar, SE, SI__bar);
   and (int_twire_3, CK__bar, D__bar, SE__bar);
   or (cond9, int_twire_2, int_twire_3);
   and (int_twire_4, SD, SE, SI);
   and (int_twire_5, D, SD, SE__bar);
   or (cond10, int_twire_4, int_twire_5);
   and (int_twire_6, SD, SE, SI__bar);
   and (int_twire_7, D__bar, SD, SE__bar);
   or (cond11, int_twire_6, int_twire_7);

   specify
      if (CK)
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & SI) | (~(CK) & D & ~(SE)) | (~(CK) & ~(D) & SE & SI))
         (negedge SD => (Q+:1'b1)) = 0;
      if ((~(CK) & D & SE & ~(SI)) | (~(CK) & ~(D) & SE & ~(SI)) | (~(CK) & ~(D) & ~(SE)))
         (negedge SD => (Q+:1'b1)) = 0;
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond3, negedge SI &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, posedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond4, negedge SI &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $recovery (posedge SD &&& cond5, posedge CK &&& cond5, 0, viol_0);
      $recovery (posedge SD &&& cond6, posedge CK &&& cond6, 0, viol_0);
      $recovery (posedge SD &&& cond7, posedge CK &&& cond7, 0, viol_0);
      $hold (posedge CK &&& cond5, posedge SD &&& cond5, 0, viol_0);
      $hold (posedge CK &&& cond6, posedge SD &&& cond6, 0, viol_0);
      $hold (posedge CK &&& cond7, posedge SD &&& cond7, 0, viol_0);
      $width (negedge SD &&& CK, 0, 0, viol_0);
      $width (negedge SD &&& cond8, 0, 0, viol_0);
      $width (negedge SD &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_FSDPSBQ_D_4

//%BEGIN SEH_FSDPTQO_1

`celldefine
module SEH_FSDPTQO_1 (Q, SO, CK, D, SI, SE, SS);
   output Q, SO;
   input CK, D, SI, SE, SS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SS;

   wire int_res__D, int_res_iq, int_res__SS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_SS, SS);
`endif

   or (int_res__D, delayed_D, delayed_SS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         buf #1 (Q, int_res_iq);
         buf #1 (SO, int_res_iq);

   `else
         buf (Q, int_res_iq);
         buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, SE__bar;
   wire SI__bar, SS__bar;


   // Additional timing gates
   not (SE__bar, SE);
   not (SS__bar, SS);
   and (cond0, SE__bar, SS__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI, SS__bar);
   not (SI__bar, SI);
   and (cond2, D, SI__bar, SS);
   and (cond3, D, SI__bar, SS__bar);
   and (cond4, D__bar, SI__bar, SS);
   and (cond5, D, SE, SS);
   and (cond6, D, SE, SS__bar);
   and (cond7, D__bar, SE, SS);
   and (cond8, D__bar, SE, SS__bar);
   and (cond9, D__bar, SE__bar);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   and (int_twire_3, D__bar, SE__bar, SS);
   or (cond10, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   and (int_twire_4, D, SE, SI__bar);
   and (int_twire_5, D__bar, SE, SI__bar);
   and (int_twire_6, D__bar, SE__bar, SS__bar);
   or (cond11, int_twire_4, int_twire_5, int_twire_6);

   specify
      (posedge CK => (Q+:((SI && SE) || (SI && !(SE) && D) || (SI && !(SE) && !(D) && SS) || (!(SI) && !(SE) && D) || (!(SI) && !(SE) && !(D) && SS)))) = 1;
      (posedge CK => (SO-:((SI && SE) || (SI && !(SE) && D) || (SI && !(SE) && !(D) && SS) || (!(SI) && !(SE) && D) || (!(SI) && !(SE) && !(D) && SS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, posedge SS &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $setuphold (posedge CK &&& cond9, negedge SS &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPTQO_1

//%BEGIN SEH_FSDPTQO_2

`celldefine
module SEH_FSDPTQO_2 (Q, SO, CK, D, SI, SE, SS);
   output Q, SO;
   input CK, D, SI, SE, SS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SS;

   wire int_res__D, int_res_iq, int_res__SS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_SS, SS);
`endif

   or (int_res__D, delayed_D, delayed_SS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         buf #1 (Q, int_res_iq);
         buf #1 (SO, int_res_iq);

   `else
         buf (Q, int_res_iq);
         buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, SE__bar;
   wire SI__bar, SS__bar;


   // Additional timing gates
   not (SE__bar, SE);
   not (SS__bar, SS);
   and (cond0, SE__bar, SS__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI, SS__bar);
   not (SI__bar, SI);
   and (cond2, D, SI__bar, SS);
   and (cond3, D, SI__bar, SS__bar);
   and (cond4, D__bar, SI__bar, SS);
   and (cond5, D, SE, SS);
   and (cond6, D, SE, SS__bar);
   and (cond7, D__bar, SE, SS);
   and (cond8, D__bar, SE, SS__bar);
   and (cond9, D__bar, SE__bar);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   and (int_twire_3, D__bar, SE__bar, SS);
   or (cond10, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   and (int_twire_4, D, SE, SI__bar);
   and (int_twire_5, D__bar, SE, SI__bar);
   and (int_twire_6, D__bar, SE__bar, SS__bar);
   or (cond11, int_twire_4, int_twire_5, int_twire_6);

   specify
      (posedge CK => (Q+:((SI && SE) || (SI && !(SE) && D) || (SI && !(SE) && !(D) && SS) || (!(SI) && !(SE) && D) || (!(SI) && !(SE) && !(D) && SS)))) = 1;
      (posedge CK => (SO-:((SI && SE) || (SI && !(SE) && D) || (SI && !(SE) && !(D) && SS) || (!(SI) && !(SE) && D) || (!(SI) && !(SE) && !(D) && SS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, posedge SS &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $setuphold (posedge CK &&& cond9, negedge SS &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPTQO_2

//%BEGIN SEH_FSDPTQO_4

`celldefine
module SEH_FSDPTQO_4 (Q, SO, CK, D, SI, SE, SS);
   output Q, SO;
   input CK, D, SI, SE, SS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SS;

   wire int_res__D, int_res_iq, int_res__SS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_SS, SS);
`endif

   or (int_res__D, delayed_D, delayed_SS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         buf #1 (Q, int_res_iq);
         buf #1 (SO, int_res_iq);

   `else
         buf (Q, int_res_iq);
         buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, cond11;
   wire D__bar, int_twire_0, int_twire_1;
   wire int_twire_2, int_twire_3, int_twire_4;
   wire int_twire_5, int_twire_6, SE__bar;
   wire SI__bar, SS__bar;


   // Additional timing gates
   not (SE__bar, SE);
   not (SS__bar, SS);
   and (cond0, SE__bar, SS__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI, SS__bar);
   not (SI__bar, SI);
   and (cond2, D, SI__bar, SS);
   and (cond3, D, SI__bar, SS__bar);
   and (cond4, D__bar, SI__bar, SS);
   and (cond5, D, SE, SS);
   and (cond6, D, SE, SS__bar);
   and (cond7, D__bar, SE, SS);
   and (cond8, D__bar, SE, SS__bar);
   and (cond9, D__bar, SE__bar);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   and (int_twire_3, D__bar, SE__bar, SS);
   or (cond10, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   and (int_twire_4, D, SE, SI__bar);
   and (int_twire_5, D__bar, SE, SI__bar);
   and (int_twire_6, D__bar, SE__bar, SS__bar);
   or (cond11, int_twire_4, int_twire_5, int_twire_6);

   specify
      (posedge CK => (Q+:((SI && SE) || (SI && !(SE) && D) || (SI && !(SE) && !(D) && SS) || (!(SI) && !(SE) && D) || (!(SI) && !(SE) && !(D) && SS)))) = 1;
      (posedge CK => (SO-:((SI && SE) || (SI && !(SE) && D) || (SI && !(SE) && !(D) && SS) || (!(SI) && !(SE) && D) || (!(SI) && !(SE) && !(D) && SS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, negedge SI &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond9, posedge SS &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $setuphold (posedge CK &&& cond9, negedge SS &&& cond9, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
      $width (posedge CK &&& cond11, 0, 0, viol_0);
      $width (negedge CK &&& cond11, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPTQO_4

//%BEGIN SEH_FSDPTQO_D_1

`celldefine
module SEH_FSDPTQO_D_1 (Q, SO, CK, D, SI, SE, SS);
   output Q, SO;
   input CK, D, SI, SE, SS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SS;

   wire int_res__D, int_res_iq, int_res__SS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_SS, SS);
`endif

   or (int_res__D, delayed_D, delayed_SS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         buf #1 (Q, int_res_iq);
         buf #1 (SO, int_res_iq);

   `else
         buf (Q, int_res_iq);
         buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire int_twire_6, SE__bar, SI__bar;
   wire SS__bar;


   // Additional timing gates
   not (SE__bar, SE);
   not (SS__bar, SS);
   and (cond0, SE__bar, SS__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI, SS__bar);
   not (SI__bar, SI);
   and (cond2, D, SI__bar, SS);
   and (cond3, D, SI__bar, SS__bar);
   and (cond4, D__bar, SI__bar, SS);
   and (cond5, D, SE);
   and (cond6, D__bar, SE, SS);
   and (cond7, D__bar, SE, SS__bar);
   and (cond8, D__bar, SE__bar);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   and (int_twire_3, D__bar, SE__bar, SS);
   or (cond9, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   and (int_twire_4, D, SE, SI__bar);
   and (int_twire_5, D__bar, SE, SI__bar);
   and (int_twire_6, D__bar, SE__bar, SS__bar);
   or (cond10, int_twire_4, int_twire_5, int_twire_6);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D) || (!(SE) && !(D) && SS)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D) || (!(SE) && !(D) && SS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $setuphold (posedge CK &&& cond8, negedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPTQO_D_1

//%BEGIN SEH_FSDPTQO_D_2

`celldefine
module SEH_FSDPTQO_D_2 (Q, SO, CK, D, SI, SE, SS);
   output Q, SO;
   input CK, D, SI, SE, SS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SS;

   wire int_res__D, int_res_iq, int_res__SS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_SS, SS);
`endif

   or (int_res__D, delayed_D, delayed_SS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         buf #1 (Q, int_res_iq);
         buf #1 (SO, int_res_iq);

   `else
         buf (Q, int_res_iq);
         buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire int_twire_6, SE__bar, SI__bar;
   wire SS__bar;


   // Additional timing gates
   not (SE__bar, SE);
   not (SS__bar, SS);
   and (cond0, SE__bar, SS__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI, SS__bar);
   not (SI__bar, SI);
   and (cond2, D, SI__bar, SS);
   and (cond3, D, SI__bar, SS__bar);
   and (cond4, D__bar, SI__bar, SS);
   and (cond5, D, SE);
   and (cond6, D__bar, SE, SS);
   and (cond7, D__bar, SE, SS__bar);
   and (cond8, D__bar, SE__bar);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   and (int_twire_3, D__bar, SE__bar, SS);
   or (cond9, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   and (int_twire_4, D, SE, SI__bar);
   and (int_twire_5, D__bar, SE, SI__bar);
   and (int_twire_6, D__bar, SE__bar, SS__bar);
   or (cond10, int_twire_4, int_twire_5, int_twire_6);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D) || (!(SE) && !(D) && SS)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D) || (!(SE) && !(D) && SS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $setuphold (posedge CK &&& cond8, negedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPTQO_D_2

//%BEGIN SEH_FSDPTQO_D_4

`celldefine
module SEH_FSDPTQO_D_4 (Q, SO, CK, D, SI, SE, SS);
   output Q, SO;
   input CK, D, SI, SE, SS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SS;

   wire int_res__D, int_res_iq, int_res__SS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_SS, SS);
`endif

   or (int_res__D, delayed_D, delayed_SS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);
   dff (int_res_iq, viol_0, delayed_CK, int_res_mux, xcr_0);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         buf #1 (Q, int_res_iq);
         buf #1 (SO, int_res_iq);

   `else
         buf (Q, int_res_iq);
         buf (SO, int_res_iq);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire int_twire_6, SE__bar, SI__bar;
   wire SS__bar;


   // Additional timing gates
   not (SE__bar, SE);
   not (SS__bar, SS);
   and (cond0, SE__bar, SS__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI, SS__bar);
   not (SI__bar, SI);
   and (cond2, D, SI__bar, SS);
   and (cond3, D, SI__bar, SS__bar);
   and (cond4, D__bar, SI__bar, SS);
   and (cond5, D, SE);
   and (cond6, D__bar, SE, SS);
   and (cond7, D__bar, SE, SS__bar);
   and (cond8, D__bar, SE__bar);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   and (int_twire_3, D__bar, SE__bar, SS);
   or (cond9, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   and (int_twire_4, D, SE, SI__bar);
   and (int_twire_5, D__bar, SE, SI__bar);
   and (int_twire_6, D__bar, SE__bar, SS__bar);
   or (cond10, int_twire_4, int_twire_5, int_twire_6);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D) || (!(SE) && !(D) && SS)))) = 1;
      (posedge CK => (SO-:((SE && SI) || (!(SE) && D) || (!(SE) && !(D) && SS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $setuphold (posedge CK &&& cond8, negedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPTQO_D_4

//%BEGIN SEH_FSDPTQ_D_1

`celldefine
module SEH_FSDPTQ_D_1 (Q, CK, D, SI, SE, SS);
   output Q;
   input CK, D, SI, SE, SS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SS;

   wire int_res__D, int_res__SS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_SS, SS);
`endif

   or (int_res__D, delayed_D, delayed_SS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire int_twire_6, SE__bar, SI__bar;
   wire SS__bar;


   // Additional timing gates
   not (SE__bar, SE);
   not (SS__bar, SS);
   and (cond0, SE__bar, SS__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI, SS__bar);
   not (SI__bar, SI);
   and (cond2, D, SI__bar, SS);
   and (cond3, D, SI__bar, SS__bar);
   and (cond4, D__bar, SI__bar, SS);
   and (cond5, D, SE);
   and (cond6, D__bar, SE, SS);
   and (cond7, D__bar, SE, SS__bar);
   and (cond8, D__bar, SE__bar);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   and (int_twire_3, D__bar, SE__bar, SS);
   or (cond9, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   and (int_twire_4, D, SE, SI__bar);
   and (int_twire_5, D__bar, SE, SI__bar);
   and (int_twire_6, D__bar, SE__bar, SS__bar);
   or (cond10, int_twire_4, int_twire_5, int_twire_6);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D) || (!(SE) && !(D) && SS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $setuphold (posedge CK &&& cond8, negedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPTQ_D_1

//%BEGIN SEH_FSDPTQ_D_2

`celldefine
module SEH_FSDPTQ_D_2 (Q, CK, D, SI, SE, SS);
   output Q;
   input CK, D, SI, SE, SS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SS;

   wire int_res__D, int_res__SS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_SS, SS);
`endif

   or (int_res__D, delayed_D, delayed_SS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire int_twire_6, SE__bar, SI__bar;
   wire SS__bar;


   // Additional timing gates
   not (SE__bar, SE);
   not (SS__bar, SS);
   and (cond0, SE__bar, SS__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI, SS__bar);
   not (SI__bar, SI);
   and (cond2, D, SI__bar, SS);
   and (cond3, D, SI__bar, SS__bar);
   and (cond4, D__bar, SI__bar, SS);
   and (cond5, D, SE);
   and (cond6, D__bar, SE, SS);
   and (cond7, D__bar, SE, SS__bar);
   and (cond8, D__bar, SE__bar);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   and (int_twire_3, D__bar, SE__bar, SS);
   or (cond9, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   and (int_twire_4, D, SE, SI__bar);
   and (int_twire_5, D__bar, SE, SI__bar);
   and (int_twire_6, D__bar, SE__bar, SS__bar);
   or (cond10, int_twire_4, int_twire_5, int_twire_6);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D) || (!(SE) && !(D) && SS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $setuphold (posedge CK &&& cond8, negedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPTQ_D_2

//%BEGIN SEH_FSDPTQ_D_4

`celldefine
module SEH_FSDPTQ_D_4 (Q, CK, D, SI, SE, SS);
   output Q;
   input CK, D, SI, SE, SS;

   reg viol_0;
   wire delayed_CK, delayed_D, delayed_SI,
	delayed_SE, delayed_SS;

   wire int_res__D, int_res__SS, xcr_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_CK, CK);
   buf (delayed_D, D);
   buf (delayed_SI, SI);
   buf (delayed_SE, SE);
   buf (delayed_SS, SS);
`endif

   or (int_res__D, delayed_D, delayed_SS);
   mux2 (int_res_mux, delayed_SI, int_res__D, delayed_SE);
   dff_err (xcr_0, delayed_CK, int_res_mux);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      dff #1 (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `else
      dff (Q, viol_0, delayed_CK, int_res_mux, xcr_0);
   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, cond4, cond5;
   wire cond6, cond7, cond8;
   wire cond9, cond10, D__bar;
   wire int_twire_0, int_twire_1, int_twire_2;
   wire int_twire_3, int_twire_4, int_twire_5;
   wire int_twire_6, SE__bar, SI__bar;
   wire SS__bar;


   // Additional timing gates
   not (SE__bar, SE);
   not (SS__bar, SS);
   and (cond0, SE__bar, SS__bar);
   not (D__bar, D);
   and (cond1, D__bar, SI, SS__bar);
   not (SI__bar, SI);
   and (cond2, D, SI__bar, SS);
   and (cond3, D, SI__bar, SS__bar);
   and (cond4, D__bar, SI__bar, SS);
   and (cond5, D, SE);
   and (cond6, D__bar, SE, SS);
   and (cond7, D__bar, SE, SS__bar);
   and (cond8, D__bar, SE__bar);
   and (int_twire_0, D, SE, SI);
   and (int_twire_1, D, SE__bar);
   and (int_twire_2, D__bar, SE, SI);
   and (int_twire_3, D__bar, SE__bar, SS);
   or (cond9, int_twire_0, int_twire_1, int_twire_2, int_twire_3);
   and (int_twire_4, D, SE, SI__bar);
   and (int_twire_5, D__bar, SE, SI__bar);
   and (int_twire_6, D__bar, SE__bar, SS__bar);
   or (cond10, int_twire_4, int_twire_5, int_twire_6);

   specify
      (posedge CK => (Q+:((SE && SI) || (!(SE) && D) || (!(SE) && !(D) && SS)))) = 1;
      $setuphold (posedge CK &&& cond0, posedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond0, negedge D &&& cond0, 0, 0, viol_0,,, delayed_CK, delayed_D);
      $setuphold (posedge CK &&& cond1, posedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond1, negedge SE &&& cond1, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, posedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond2, negedge SE &&& cond2, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, posedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond3, negedge SE &&& cond3, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, posedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond4, negedge SE &&& cond4, 0, 0, viol_0,,, delayed_CK, delayed_SE);
      $setuphold (posedge CK &&& cond5, posedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond5, negedge SI &&& cond5, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, posedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond6, negedge SI &&& cond6, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, posedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond7, negedge SI &&& cond7, 0, 0, viol_0,,, delayed_CK, delayed_SI);
      $setuphold (posedge CK &&& cond8, posedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $setuphold (posedge CK &&& cond8, negedge SS &&& cond8, 0, 0, viol_0,,, delayed_CK, delayed_SS);
      $width (posedge CK &&& cond9, 0, 0, viol_0);
      $width (negedge CK &&& cond9, 0, 0, viol_0);
      $width (posedge CK &&& cond10, 0, 0, viol_0);
      $width (negedge CK &&& cond10, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_FSDPTQ_D_4

//%BEGIN SEH_INV_0P5

`celldefine
module SEH_INV_0P5 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_0P5

//%BEGIN SEH_INV_0P65

`celldefine
module SEH_INV_0P65 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_0P65

//%BEGIN SEH_INV_0P8

`celldefine
module SEH_INV_0P8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_0P8

//%BEGIN SEH_INV_1

`celldefine
module SEH_INV_1 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_1

//%BEGIN SEH_INV_10

`celldefine
module SEH_INV_10 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_10

//%BEGIN SEH_INV_12

`celldefine
module SEH_INV_12 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_12

//%BEGIN SEH_INV_16

`celldefine
module SEH_INV_16 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_16

//%BEGIN SEH_INV_1P25

`celldefine
module SEH_INV_1P25 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_1P25

//%BEGIN SEH_INV_1P5

`celldefine
module SEH_INV_1P5 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_1P5

//%BEGIN SEH_INV_2

`celldefine
module SEH_INV_2 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_2

//%BEGIN SEH_INV_20

`celldefine
module SEH_INV_20 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_20

//%BEGIN SEH_INV_24

`celldefine
module SEH_INV_24 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_24

//%BEGIN SEH_INV_2P5

`celldefine
module SEH_INV_2P5 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_2P5

//%BEGIN SEH_INV_3

`celldefine
module SEH_INV_3 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_3

//%BEGIN SEH_INV_32

`celldefine
module SEH_INV_32 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_32

//%BEGIN SEH_INV_4

`celldefine
module SEH_INV_4 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_4

//%BEGIN SEH_INV_5

`celldefine
module SEH_INV_5 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_5

//%BEGIN SEH_INV_6

`celldefine
module SEH_INV_6 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_6

//%BEGIN SEH_INV_8

`celldefine
module SEH_INV_8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_8

//%BEGIN SEH_INV_CTY2_12

`celldefine
module SEH_INV_CTY2_12 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_CTY2_12

//%BEGIN SEH_INV_CTY2_16

`celldefine
module SEH_INV_CTY2_16 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_CTY2_16

//%BEGIN SEH_INV_CTY2_2

`celldefine
module SEH_INV_CTY2_2 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_CTY2_2

//%BEGIN SEH_INV_CTY2_24

`celldefine
module SEH_INV_CTY2_24 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_CTY2_24

//%BEGIN SEH_INV_CTY2_32

`celldefine
module SEH_INV_CTY2_32 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_CTY2_32

//%BEGIN SEH_INV_CTY2_4

`celldefine
module SEH_INV_CTY2_4 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_CTY2_4

//%BEGIN SEH_INV_CTY2_48

`celldefine
module SEH_INV_CTY2_48 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_CTY2_48

//%BEGIN SEH_INV_CTY2_6

`celldefine
module SEH_INV_CTY2_6 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_CTY2_6

//%BEGIN SEH_INV_CTY2_64

`celldefine
module SEH_INV_CTY2_64 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_CTY2_64

//%BEGIN SEH_INV_CTY2_8

`celldefine
module SEH_INV_CTY2_8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_CTY2_8

//%BEGIN SEH_INV_S_0P5

`celldefine
module SEH_INV_S_0P5 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_0P5

//%BEGIN SEH_INV_S_0P65

`celldefine
module SEH_INV_S_0P65 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_0P65

//%BEGIN SEH_INV_S_0P8

`celldefine
module SEH_INV_S_0P8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_0P8

//%BEGIN SEH_INV_S_1

`celldefine
module SEH_INV_S_1 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_1

//%BEGIN SEH_INV_S_10

`celldefine
module SEH_INV_S_10 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_10

//%BEGIN SEH_INV_S_12

`celldefine
module SEH_INV_S_12 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_12

//%BEGIN SEH_INV_S_16

`celldefine
module SEH_INV_S_16 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_16

//%BEGIN SEH_INV_S_1P25

`celldefine
module SEH_INV_S_1P25 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_1P25

//%BEGIN SEH_INV_S_1P5

`celldefine
module SEH_INV_S_1P5 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_1P5

//%BEGIN SEH_INV_S_2

`celldefine
module SEH_INV_S_2 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_2

//%BEGIN SEH_INV_S_24

`celldefine
module SEH_INV_S_24 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_24

//%BEGIN SEH_INV_S_3

`celldefine
module SEH_INV_S_3 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_3

//%BEGIN SEH_INV_S_32

`celldefine
module SEH_INV_S_32 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_32

//%BEGIN SEH_INV_S_4

`celldefine
module SEH_INV_S_4 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_4

//%BEGIN SEH_INV_S_5

`celldefine
module SEH_INV_S_5 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_5

//%BEGIN SEH_INV_S_6

`celldefine
module SEH_INV_S_6 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_6

//%BEGIN SEH_INV_S_8

`celldefine
module SEH_INV_S_8 (X, A);
   output X;
   input A;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
        not #1 (X, A);
    `else
        not (X, A);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_INV_S_8

//%BEGIN SEH_LDNQ_1

`celldefine
module SEH_LDNQ_1 (Q, G, D);
   output Q;
   input G, D;

   reg viol_0;
   wire delayed_G, delayed_D;

   wire int_res__G;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif

   not (int_res__G, delayed_G);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch #1 (Q, viol_0, int_res__G, delayed_D);

   `else

        latch (Q, viol_0, int_res__G, delayed_D);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D => Q) = 0;
      (negedge G => (Q+:D)) = 1;
      $setuphold (posedge G, posedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (posedge G, negedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $width (negedge G &&& D, 0, 0, viol_0);
      $width (negedge G &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_LDNQ_1

//%BEGIN SEH_LDNQ_2

`celldefine
module SEH_LDNQ_2 (Q, G, D);
   output Q;
   input G, D;

   reg viol_0;
   wire delayed_G, delayed_D;

   wire int_res__G;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif

   not (int_res__G, delayed_G);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch #1 (Q, viol_0, int_res__G, delayed_D);

   `else

        latch (Q, viol_0, int_res__G, delayed_D);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D => Q) = 0;
      (negedge G => (Q+:D)) = 1;
      $setuphold (posedge G, posedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (posedge G, negedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $width (negedge G &&& D, 0, 0, viol_0);
      $width (negedge G &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_LDNQ_2

//%BEGIN SEH_LDNQ_4

`celldefine
module SEH_LDNQ_4 (Q, G, D);
   output Q;
   input G, D;

   reg viol_0;
   wire delayed_G, delayed_D;

   wire int_res__G;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif

   not (int_res__G, delayed_G);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch #1 (Q, viol_0, int_res__G, delayed_D);

   `else

        latch (Q, viol_0, int_res__G, delayed_D);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D => Q) = 0;
      (negedge G => (Q+:D)) = 1;
      $setuphold (posedge G, posedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (posedge G, negedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $width (negedge G &&& D, 0, 0, viol_0);
      $width (negedge G &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_LDNQ_4

//%BEGIN SEH_LDNRBQ_1

`celldefine
module SEH_LDNRBQ_1 (Q, G, D, RD);
   output Q;
   input G, D, RD;

   reg viol_0;
   wire delayed_G, delayed_D, delayed_RD;

   wire int_res__G, int_res__RD;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__G, delayed_G);
   not (int_res__RD, delayed_RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch_r #1 (Q, viol_0, int_res__G, delayed_D, int_res__RD);
    `else
        latch_r (Q, viol_0, int_res__G, delayed_D, int_res__RD);
    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, D__bar;


   // Additional timing gates
   and (cond0, D, G);
   not (D__bar, D);
   and (cond1, D__bar, G);
   and (cond2, D, RD);
   and (cond3, D__bar, RD);

   specify
      (D => Q) = 0;
      (posedge RD => (Q+:1'b1)) = 0;
      if ((D & G))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((D & ~(G)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(D) & G))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge G => (Q+:D)) = 1;
      $setuphold (posedge G &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (posedge G &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $recovery (posedge RD &&& D, posedge G &&& D, 0, viol_0);
      $hold (posedge G &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge G &&& cond2, 0, 0, viol_0);
      $width (negedge G &&& cond3, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_LDNRBQ_1

//%BEGIN SEH_LDNRBQ_2

`celldefine
module SEH_LDNRBQ_2 (Q, G, D, RD);
   output Q;
   input G, D, RD;

   reg viol_0;
   wire delayed_G, delayed_D, delayed_RD;

   wire int_res__G, int_res__RD;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__G, delayed_G);
   not (int_res__RD, delayed_RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch_r #1 (Q, viol_0, int_res__G, delayed_D, int_res__RD);
    `else
        latch_r (Q, viol_0, int_res__G, delayed_D, int_res__RD);
    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, D__bar;


   // Additional timing gates
   and (cond0, D, G);
   not (D__bar, D);
   and (cond1, D__bar, G);
   and (cond2, D, RD);
   and (cond3, D__bar, RD);

   specify
      (D => Q) = 0;
      (posedge RD => (Q+:1'b1)) = 0;
      if ((D & G))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((D & ~(G)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(D) & G))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge G => (Q+:D)) = 1;
      $setuphold (posedge G &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (posedge G &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $recovery (posedge RD &&& D, posedge G &&& D, 0, viol_0);
      $hold (posedge G &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge G &&& cond2, 0, 0, viol_0);
      $width (negedge G &&& cond3, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_LDNRBQ_2

//%BEGIN SEH_LDNRBQ_4

`celldefine
module SEH_LDNRBQ_4 (Q, G, D, RD);
   output Q;
   input G, D, RD;

   reg viol_0;
   wire delayed_G, delayed_D, delayed_RD;

   wire int_res__G, int_res__RD;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__G, delayed_G);
   not (int_res__RD, delayed_RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch_r #1 (Q, viol_0, int_res__G, delayed_D, int_res__RD);
    `else
        latch_r (Q, viol_0, int_res__G, delayed_D, int_res__RD);
    `endif

    `ifdef VIRL_functiononly

    `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, D__bar;


   // Additional timing gates
   and (cond0, D, G);
   not (D__bar, D);
   and (cond1, D__bar, G);
   and (cond2, D, RD);
   and (cond3, D__bar, RD);

   specify
      (D => Q) = 0;
      (posedge RD => (Q+:1'b1)) = 0;
      if ((D & G))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((D & ~(G)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(D) & G))
         (negedge RD => (Q+:1'b0)) = 0;
      (negedge G => (Q+:D)) = 1;
      $setuphold (posedge G &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (posedge G &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $recovery (posedge RD &&& D, posedge G &&& D, 0, viol_0);
      $hold (posedge G &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (negedge G &&& cond2, 0, 0, viol_0);
      $width (negedge G &&& cond3, 0, 0, viol_0);
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_LDNRBQ_4

//%BEGIN SEH_LDPQ_1

`celldefine
module SEH_LDPQ_1 (Q, G, D);
   output Q;
   input G, D;

   reg viol_0;
   wire delayed_G, delayed_D;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch #1 (Q, viol_0, delayed_G, delayed_D);

    `else

        latch (Q, viol_0, delayed_G, delayed_D);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D => Q) = 0;
      (posedge G => (Q+:D)) = 1;
      $setuphold (negedge G, posedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (negedge G, negedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $width (posedge G &&& D, 0, 0, viol_0);
      $width (posedge G &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_LDPQ_1

//%BEGIN SEH_LDPQ_2

`celldefine
module SEH_LDPQ_2 (Q, G, D);
   output Q;
   input G, D;

   reg viol_0;
   wire delayed_G, delayed_D;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch #1 (Q, viol_0, delayed_G, delayed_D);

    `else

        latch (Q, viol_0, delayed_G, delayed_D);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D => Q) = 0;
      (posedge G => (Q+:D)) = 1;
      $setuphold (negedge G, posedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (negedge G, negedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $width (posedge G &&& D, 0, 0, viol_0);
      $width (posedge G &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_LDPQ_2

//%BEGIN SEH_LDPQ_4

`celldefine
module SEH_LDPQ_4 (Q, G, D);
   output Q;
   input G, D;

   reg viol_0;
   wire delayed_G, delayed_D;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch #1 (Q, viol_0, delayed_G, delayed_D);

    `else

        latch (Q, viol_0, delayed_G, delayed_D);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D => Q) = 0;
      (posedge G => (Q+:D)) = 1;
      $setuphold (negedge G, posedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (negedge G, negedge D, 0, 0, viol_0,,, delayed_G, delayed_D);
      $width (posedge G &&& D, 0, 0, viol_0);
      $width (posedge G &&& ~D, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_LDPQ_4

//%BEGIN SEH_LDPRBQ_1

`celldefine
module SEH_LDPRBQ_1 (Q, G, D, RD);
   output Q;
   input G, D, RD;

   reg viol_0;
   wire delayed_G, delayed_D, delayed_RD;

   wire int_res__RD;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__RD, delayed_RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch_r #1 (Q, viol_0, delayed_G, delayed_D, int_res__RD);

   `else
        latch_r (Q, viol_0, delayed_G, delayed_D, int_res__RD);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, D__bar, G__bar;


   // Additional timing gates
   not (G__bar, G);
   and (cond0, D, G__bar);
   not (D__bar, D);
   and (cond1, D__bar, G__bar);
   and (cond2, D, RD);
   and (cond3, D__bar, RD);

   specify
      (D => Q) = 0;
      (posedge RD => (Q+:1'b1)) = 0;
      if ((D & G))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((D & ~(G)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(D) & ~(G)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge G => (Q+:D)) = 1;
      $setuphold (negedge G &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (negedge G &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $recovery (posedge RD &&& D, negedge G &&& D, 0, viol_0);
      $hold (negedge G &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (posedge G &&& cond2, 0, 0, viol_0);
      $width (posedge G &&& cond3, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_LDPRBQ_1

//%BEGIN SEH_LDPRBQ_2

`celldefine
module SEH_LDPRBQ_2 (Q, G, D, RD);
   output Q;
   input G, D, RD;

   reg viol_0;
   wire delayed_G, delayed_D, delayed_RD;

   wire int_res__RD;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__RD, delayed_RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch_r #1 (Q, viol_0, delayed_G, delayed_D, int_res__RD);

   `else
        latch_r (Q, viol_0, delayed_G, delayed_D, int_res__RD);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, D__bar, G__bar;


   // Additional timing gates
   not (G__bar, G);
   and (cond0, D, G__bar);
   not (D__bar, D);
   and (cond1, D__bar, G__bar);
   and (cond2, D, RD);
   and (cond3, D__bar, RD);

   specify
      (D => Q) = 0;
      (posedge RD => (Q+:1'b1)) = 0;
      if ((D & G))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((D & ~(G)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(D) & ~(G)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge G => (Q+:D)) = 1;
      $setuphold (negedge G &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (negedge G &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $recovery (posedge RD &&& D, negedge G &&& D, 0, viol_0);
      $hold (negedge G &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (posedge G &&& cond2, 0, 0, viol_0);
      $width (posedge G &&& cond3, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_LDPRBQ_2

//%BEGIN SEH_LDPRBQ_4

`celldefine
module SEH_LDPRBQ_4 (Q, G, D, RD);
   output Q;
   input G, D, RD;

   reg viol_0;
   wire delayed_G, delayed_D, delayed_RD;

   wire int_res__RD;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

`ifdef _fv
   buf (delayed_G, G);
   buf (delayed_D, D);
`endif
   buf (delayed_RD, RD);

   not (int_res__RD, delayed_RD);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        latch_r #1 (Q, viol_0, delayed_G, delayed_D, int_res__RD);

   `else
        latch_r (Q, viol_0, delayed_G, delayed_D, int_res__RD);

   `endif

   `ifdef VIRL_functiononly

   `else



   // Additional timing wires
   wire cond0, cond1, cond2;
   wire cond3, D__bar, G__bar;


   // Additional timing gates
   not (G__bar, G);
   and (cond0, D, G__bar);
   not (D__bar, D);
   and (cond1, D__bar, G__bar);
   and (cond2, D, RD);
   and (cond3, D__bar, RD);

   specify
      (D => Q) = 0;
      (posedge RD => (Q+:1'b1)) = 0;
      if ((D & G))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((D & ~(G)))
         (negedge RD => (Q+:1'b0)) = 0;
      if ((~(D) & ~(G)))
         (negedge RD => (Q+:1'b0)) = 0;
      (posedge G => (Q+:D)) = 1;
      $setuphold (negedge G &&& RD, posedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $setuphold (negedge G &&& RD, negedge D &&& RD, 0, 0, viol_0,,, delayed_G, delayed_D);
      $recovery (posedge RD &&& D, negedge G &&& D, 0, viol_0);
      $hold (negedge G &&& D, posedge RD &&& D, 0, viol_0);
      $width (negedge RD &&& cond0, 0, 0, viol_0);
      $width (negedge RD &&& cond1, 0, 0, viol_0);
      $width (posedge G &&& cond2, 0, 0, viol_0);
      $width (posedge G &&& cond3, 0, 0, viol_0);
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_LDPRBQ_4

//%BEGIN SEH_MAJ3_0P5

`celldefine
module SEH_MAJ3_0P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        or (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJ3_0P5

//%BEGIN SEH_MAJ3_1

`celldefine
module SEH_MAJ3_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        or (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJ3_1

//%BEGIN SEH_MAJ3_1P5

`celldefine
module SEH_MAJ3_1P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        or (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJ3_1P5

//%BEGIN SEH_MAJ3_2

`celldefine
module SEH_MAJ3_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        or (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJ3_2

//%BEGIN SEH_MAJ3_4

`celldefine
module SEH_MAJ3_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        or (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJ3_4

//%BEGIN SEH_MAJ3_6

`celldefine
module SEH_MAJ3_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        or #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        or (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJ3_6

//%BEGIN SEH_MAJI3_1

`celldefine
module SEH_MAJI3_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_1

//%BEGIN SEH_MAJI3_2

`celldefine
module SEH_MAJI3_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_2

//%BEGIN SEH_MAJI3_3

`celldefine
module SEH_MAJI3_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_3

//%BEGIN SEH_MAJI3_4

`celldefine
module SEH_MAJI3_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_4

//%BEGIN SEH_MAJI3_5

`celldefine
module SEH_MAJI3_5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_5

//%BEGIN SEH_MAJI3_6

`celldefine
module SEH_MAJI3_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_6

//%BEGIN SEH_MAJI3_8

`celldefine
module SEH_MAJI3_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_8

//%BEGIN SEH_MAJI3_T_1

`celldefine
module SEH_MAJI3_T_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_T_1

//%BEGIN SEH_MAJI3_T_2

`celldefine
module SEH_MAJI3_T_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_T_2

//%BEGIN SEH_MAJI3_T_3

`celldefine
module SEH_MAJI3_T_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_T_3

//%BEGIN SEH_MAJI3_T_4

`celldefine
module SEH_MAJI3_T_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_T_4

//%BEGIN SEH_MAJI3_T_5

`celldefine
module SEH_MAJI3_T_5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_T_5

//%BEGIN SEH_MAJI3_T_6

`celldefine
module SEH_MAJI3_T_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_T_6

//%BEGIN SEH_MAJI3_T_8

`celldefine
module SEH_MAJI3_T_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A2);
   and (int_res_1, A1, A3);
   and (int_res_2, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, int_res_1, int_res_2);
   `else
        nor (X, int_res_0, int_res_1, int_res_2);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A2 & ~(A3)))
         (A1 => X) = 0;
      if ((~(A2) & A3))
         (A1 => X) = 0;
      if ((A1 & ~(A3)))
         (A2 => X) = 0;
      if ((~(A1) & A3))
         (A2 => X) = 0;
      if ((A1 & ~(A2)))
         (A3 => X) = 0;
      if ((~(A1) & A2))
         (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MAJI3_T_8

//%BEGIN SEH_MUX2AN2_DG_1

`celldefine
module SEH_MUX2AN2_DG_1 (X, D0A1, D0A2, D1, S);
   output X;
   input D0A1, D0A2, D1, S;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, D0A1, D0A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, int_res_0, S);
    `else
        mux2 (X, D1, int_res_0, S);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0A1 => X) = 0;
      (D0A2 => X) = 0;
      (D1 => X) = 0;
      if ((D0A1 & ~(D0A2) & D1))
         (S => X) = 0;
      if ((~(D0A1) & D0A2 & D1))
         (S => X) = 0;
      if ((~(D0A1) & ~(D0A2) & D1))
         (S => X) = 0;
      if ((D0A1 & D0A2 & ~(D1)))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUX2AN2_DG_1

//%BEGIN SEH_MUX2AN2_DG_2

`celldefine
module SEH_MUX2AN2_DG_2 (X, D0A1, D0A2, D1, S);
   output X;
   input D0A1, D0A2, D1, S;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, D0A1, D0A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, int_res_0, S);
    `else
        mux2 (X, D1, int_res_0, S);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0A1 => X) = 0;
      (D0A2 => X) = 0;
      (D1 => X) = 0;
      if ((D0A1 & ~(D0A2) & D1))
         (S => X) = 0;
      if ((~(D0A1) & D0A2 & D1))
         (S => X) = 0;
      if ((~(D0A1) & ~(D0A2) & D1))
         (S => X) = 0;
      if ((D0A1 & D0A2 & ~(D1)))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUX2AN2_DG_2

//%BEGIN SEH_MUX2AN2_DG_4

`celldefine
module SEH_MUX2AN2_DG_4 (X, D0A1, D0A2, D1, S);
   output X;
   input D0A1, D0A2, D1, S;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, D0A1, D0A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, int_res_0, S);
    `else
        mux2 (X, D1, int_res_0, S);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0A1 => X) = 0;
      (D0A2 => X) = 0;
      (D1 => X) = 0;
      if ((D0A1 & ~(D0A2) & D1))
         (S => X) = 0;
      if ((~(D0A1) & D0A2 & D1))
         (S => X) = 0;
      if ((~(D0A1) & ~(D0A2) & D1))
         (S => X) = 0;
      if ((D0A1 & D0A2 & ~(D1)))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUX2AN2_DG_4

//%BEGIN SEH_MUX2AN2_DG_8

`celldefine
module SEH_MUX2AN2_DG_8 (X, D0A1, D0A2, D1, S);
   output X;
   input D0A1, D0A2, D1, S;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, D0A1, D0A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, int_res_0, S);
    `else
        mux2 (X, D1, int_res_0, S);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0A1 => X) = 0;
      (D0A2 => X) = 0;
      (D1 => X) = 0;
      if ((D0A1 & ~(D0A2) & D1))
         (S => X) = 0;
      if ((~(D0A1) & D0A2 & D1))
         (S => X) = 0;
      if ((~(D0A1) & ~(D0A2) & D1))
         (S => X) = 0;
      if ((D0A1 & D0A2 & ~(D1)))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUX2AN2_DG_8

//%BEGIN SEH_MUX2OR2B_DG_1

`celldefine
module SEH_MUX2OR2B_DG_1 (X, D0A, D0B, D1, S);
   output X;
   input D0A, D0B, D1, S;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, D0A);
   or (int_res_1, int_res_0, D0B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, int_res_1, S);
   `else
        mux2 (X, D1, int_res_1, S);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0A => X) = 0;
      (D0B => X) = 0;
      (D1 => X) = 0;
      if ((D0A & ~(D0B) & D1))
         (S => X) = 0;
      if ((D0A & D0B & ~(D1)))
         (S => X) = 0;
      if ((~(D0A) & D0B & ~(D1)))
         (S => X) = 0;
      if ((~(D0A) & ~(D0B) & ~(D1)))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUX2OR2B_DG_1

//%BEGIN SEH_MUX2OR2B_DG_2

`celldefine
module SEH_MUX2OR2B_DG_2 (X, D0A, D0B, D1, S);
   output X;
   input D0A, D0B, D1, S;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, D0A);
   or (int_res_1, int_res_0, D0B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, int_res_1, S);
   `else
        mux2 (X, D1, int_res_1, S);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0A => X) = 0;
      (D0B => X) = 0;
      (D1 => X) = 0;
      if ((D0A & ~(D0B) & D1))
         (S => X) = 0;
      if ((D0A & D0B & ~(D1)))
         (S => X) = 0;
      if ((~(D0A) & D0B & ~(D1)))
         (S => X) = 0;
      if ((~(D0A) & ~(D0B) & ~(D1)))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUX2OR2B_DG_2

//%BEGIN SEH_MUX2OR2B_DG_4

`celldefine
module SEH_MUX2OR2B_DG_4 (X, D0A, D0B, D1, S);
   output X;
   input D0A, D0B, D1, S;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, D0A);
   or (int_res_1, int_res_0, D0B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, int_res_1, S);
   `else
        mux2 (X, D1, int_res_1, S);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0A => X) = 0;
      (D0B => X) = 0;
      (D1 => X) = 0;
      if ((D0A & ~(D0B) & D1))
         (S => X) = 0;
      if ((D0A & D0B & ~(D1)))
         (S => X) = 0;
      if ((~(D0A) & D0B & ~(D1)))
         (S => X) = 0;
      if ((~(D0A) & ~(D0B) & ~(D1)))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUX2OR2B_DG_4

//%BEGIN SEH_MUX2OR2B_DG_8

`celldefine
module SEH_MUX2OR2B_DG_8 (X, D0A, D0B, D1, S);
   output X;
   input D0A, D0B, D1, S;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, D0A);
   or (int_res_1, int_res_0, D0B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, int_res_1, S);
   `else
        mux2 (X, D1, int_res_1, S);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0A => X) = 0;
      (D0B => X) = 0;
      (D1 => X) = 0;
      if ((D0A & ~(D0B) & D1))
         (S => X) = 0;
      if ((D0A & D0B & ~(D1)))
         (S => X) = 0;
      if ((~(D0A) & D0B & ~(D1)))
         (S => X) = 0;
      if ((~(D0A) & ~(D0B) & ~(D1)))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUX2OR2B_DG_8

//%BEGIN SEH_MUX2_0P5

`celldefine
module SEH_MUX2_0P5 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_0P5

//%BEGIN SEH_MUX2_1

`celldefine
module SEH_MUX2_1 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_1

//%BEGIN SEH_MUX2_2

`celldefine
module SEH_MUX2_2 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_2

//%BEGIN SEH_MUX2_3

`celldefine
module SEH_MUX2_3 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_3

//%BEGIN SEH_MUX2_4

`celldefine
module SEH_MUX2_4 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_4

//%BEGIN SEH_MUX2_5

`celldefine
module SEH_MUX2_5 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_5

//%BEGIN SEH_MUX2_6

`celldefine
module SEH_MUX2_6 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_6

//%BEGIN SEH_MUX2_8

`celldefine
module SEH_MUX2_8 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_8

//%BEGIN SEH_MUX2_CTY2_16

`celldefine
module SEH_MUX2_CTY2_16 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_CTY2_16

//%BEGIN SEH_MUX2_CTY2_4

`celldefine
module SEH_MUX2_CTY2_4 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_CTY2_4

//%BEGIN SEH_MUX2_CTY2_6

`celldefine
module SEH_MUX2_CTY2_6 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_CTY2_6

//%BEGIN SEH_MUX2_CTY2_8

`celldefine
module SEH_MUX2_CTY2_8 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_CTY2_8

//%BEGIN SEH_MUX2_DG_1

`celldefine
module SEH_MUX2_DG_1 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_DG_1

//%BEGIN SEH_MUX2_DG_16

`celldefine
module SEH_MUX2_DG_16 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_DG_16

//%BEGIN SEH_MUX2_DG_2

`celldefine
module SEH_MUX2_DG_2 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_DG_2

//%BEGIN SEH_MUX2_DG_4

`celldefine
module SEH_MUX2_DG_4 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_DG_4

//%BEGIN SEH_MUX2_DG_8

`celldefine
module SEH_MUX2_DG_8 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_DG_8

//%BEGIN SEH_MUX2_G_1

`celldefine
module SEH_MUX2_G_1 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_G_1

//%BEGIN SEH_MUX2_G_12

`celldefine
module SEH_MUX2_G_12 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_G_12

//%BEGIN SEH_MUX2_G_16

`celldefine
module SEH_MUX2_G_16 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_G_16

//%BEGIN SEH_MUX2_G_2

`celldefine
module SEH_MUX2_G_2 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_G_2

//%BEGIN SEH_MUX2_G_3

`celldefine
module SEH_MUX2_G_3 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_G_3

//%BEGIN SEH_MUX2_G_4

`celldefine
module SEH_MUX2_G_4 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_G_4

//%BEGIN SEH_MUX2_G_6

`celldefine
module SEH_MUX2_G_6 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_G_6

//%BEGIN SEH_MUX2_G_8

`celldefine
module SEH_MUX2_G_8 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_G_8

//%BEGIN SEH_MUX2_S_0P5

`celldefine
module SEH_MUX2_S_0P5 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_S_0P5

//%BEGIN SEH_MUX2_S_1

`celldefine
module SEH_MUX2_S_1 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_S_1

//%BEGIN SEH_MUX2_S_2

`celldefine
module SEH_MUX2_S_2 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_S_2

//%BEGIN SEH_MUX2_S_4

`celldefine
module SEH_MUX2_S_4 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_S_4

//%BEGIN SEH_MUX2_S_6

`celldefine
module SEH_MUX2_S_6 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_S_6

//%BEGIN SEH_MUX2_S_8

`celldefine
module SEH_MUX2_S_8 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D1, D0, S);
   `else
        mux2 (X, D1, D0, S);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX2_S_8

//%BEGIN SEH_MUX3_CTY2_24

`celldefine
module SEH_MUX3_CTY2_24 (X, D0, D1, D2, S0, S1);
   output X;
   input D0, D1, D2, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux4 #1 (X, D2, D2, D1, D0, S1, S0);
   `else
        mux4 (X, D2, D2, D1, D0, S1, S0);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      if ((~(D0) & D1 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D1) & D2 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D2) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif 

endmodule
`endcelldefine

//%END SEH_MUX3_CTY2_24

//%BEGIN SEH_MUX3_CTY2_32

`celldefine
module SEH_MUX3_CTY2_32 (X, D0, D1, D2, S0, S1);
   output X;
   input D0, D1, D2, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux4 #1 (X, D2, D2, D1, D0, S1, S0);
   `else
        mux4 (X, D2, D2, D1, D0, S1, S0);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      if ((~(D0) & D1 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D1) & D2 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D2) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif 

endmodule
`endcelldefine

//%END SEH_MUX3_CTY2_32

//%BEGIN SEH_MUX3_DGY2_8

`celldefine
module SEH_MUX3_DGY2_8 (X, D0, D1, D2, S0, S1);
   output X;
   input D0, D1, D2, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux4 #1 (X, D2, D2, D1, D0, S1, S0);
   `else
        mux4 (X, D2, D2, D1, D0, S1, S0);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      if ((~(D0) & D1 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D1) & D2 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D2) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif 

endmodule
`endcelldefine

//%END SEH_MUX3_DGY2_8

//%BEGIN SEH_MUX3_DG_1

`celldefine
module SEH_MUX3_DG_1 (X, D0, D1, D2, S0, S1);
   output X;
   input D0, D1, D2, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux4 #1 (X, D2, D2, D1, D0, S1, S0);
   `else
        mux4 (X, D2, D2, D1, D0, S1, S0);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      if ((~(D0) & D1 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D1) & D2 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D2) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif 

endmodule
`endcelldefine

//%END SEH_MUX3_DG_1

//%BEGIN SEH_MUX3_DG_2

`celldefine
module SEH_MUX3_DG_2 (X, D0, D1, D2, S0, S1);
   output X;
   input D0, D1, D2, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux4 #1 (X, D2, D2, D1, D0, S1, S0);
   `else
        mux4 (X, D2, D2, D1, D0, S1, S0);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      if ((~(D0) & D1 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D1) & D2 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D2) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif 

endmodule
`endcelldefine

//%END SEH_MUX3_DG_2

//%BEGIN SEH_MUX3_DG_3

`celldefine
module SEH_MUX3_DG_3 (X, D0, D1, D2, S0, S1);
   output X;
   input D0, D1, D2, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux4 #1 (X, D2, D2, D1, D0, S1, S0);
   `else
        mux4 (X, D2, D2, D1, D0, S1, S0);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      if ((~(D0) & D1 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D1) & D2 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D2) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif 

endmodule
`endcelldefine

//%END SEH_MUX3_DG_3

//%BEGIN SEH_MUX3_DG_4

`celldefine
module SEH_MUX3_DG_4 (X, D0, D1, D2, S0, S1);
   output X;
   input D0, D1, D2, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux4 #1 (X, D2, D2, D1, D0, S1, S0);
   `else
        mux4 (X, D2, D2, D1, D0, S1, S0);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      if ((~(D0) & D1 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D1) & D2 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D2) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif 

endmodule
`endcelldefine

//%END SEH_MUX3_DG_4

//%BEGIN SEH_MUX3_DG_6

`celldefine
module SEH_MUX3_DG_6 (X, D0, D1, D2, S0, S1);
   output X;
   input D0, D1, D2, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux4 #1 (X, D2, D2, D1, D0, S1, S0);
   `else
        mux4 (X, D2, D2, D1, D0, S1, S0);
    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      if ((~(D0) & D1 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D1) & D2 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D2) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif 

endmodule
`endcelldefine

//%END SEH_MUX3_DG_6

//%BEGIN SEH_MUX4_CTY2_16

`celldefine
module SEH_MUX4_CTY2_16 (X, D0, D1, D2, D3, S0, S1);
   output X;
   input D0, D1, D2, D3, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         mux4 #1 (X, D3, D2, D1, D0, S1, S0);
   `else
         mux4 (X, D3, D2, D1, D0, S1, S0);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      (D3 => X) = 0;
      if ((D0 & D1 & ~(D2) & D3 & S1) | (~(D0) & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & D3 & ~(S1)) | (~(D0) & D1 & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & D1 & D2 & ~(D3) & S1) | (~(D0) & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & D3 & ~(S1)) | (D0 & ~(D1) & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((~(D1) & D3 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D3) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX4_CTY2_16

//%BEGIN SEH_MUX4_CTY2_4

`celldefine
module SEH_MUX4_CTY2_4 (X, D0, D1, D2, D3, S0, S1);
   output X;
   input D0, D1, D2, D3, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         mux4 #1 (X, D3, D2, D1, D0, S1, S0);
   `else
         mux4 (X, D3, D2, D1, D0, S1, S0);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      (D3 => X) = 0;
      if ((D0 & D1 & ~(D2) & D3 & S1) | (~(D0) & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & D3 & ~(S1)) | (~(D0) & D1 & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & D1 & D2 & ~(D3) & S1) | (~(D0) & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & D3 & ~(S1)) | (D0 & ~(D1) & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((~(D1) & D3 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D3) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX4_CTY2_4

//%BEGIN SEH_MUX4_CTY2_8

`celldefine
module SEH_MUX4_CTY2_8 (X, D0, D1, D2, D3, S0, S1);
   output X;
   input D0, D1, D2, D3, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         mux4 #1 (X, D3, D2, D1, D0, S1, S0);
   `else
         mux4 (X, D3, D2, D1, D0, S1, S0);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      (D3 => X) = 0;
      if ((D0 & D1 & ~(D2) & D3 & S1) | (~(D0) & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & D3 & ~(S1)) | (~(D0) & D1 & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & D1 & D2 & ~(D3) & S1) | (~(D0) & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & D3 & ~(S1)) | (D0 & ~(D1) & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((~(D1) & D3 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D3) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX4_CTY2_8

//%BEGIN SEH_MUX4_DG_1

`celldefine
module SEH_MUX4_DG_1 (X, D0, D1, D2, D3, S0, S1);
   output X;
   input D0, D1, D2, D3, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         mux4 #1 (X, D3, D2, D1, D0, S1, S0);
   `else
         mux4 (X, D3, D2, D1, D0, S1, S0);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      (D3 => X) = 0;
      if ((D0 & D1 & ~(D2) & D3 & S1) | (~(D0) & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & D3 & ~(S1)) | (~(D0) & D1 & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & D1 & D2 & ~(D3) & S1) | (~(D0) & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & D3 & ~(S1)) | (D0 & ~(D1) & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((~(D1) & D3 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D3) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX4_DG_1

//%BEGIN SEH_MUX4_DG_2

`celldefine
module SEH_MUX4_DG_2 (X, D0, D1, D2, D3, S0, S1);
   output X;
   input D0, D1, D2, D3, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         mux4 #1 (X, D3, D2, D1, D0, S1, S0);
   `else
         mux4 (X, D3, D2, D1, D0, S1, S0);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      (D3 => X) = 0;
      if ((D0 & D1 & ~(D2) & D3 & S1) | (~(D0) & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & D3 & ~(S1)) | (~(D0) & D1 & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & D1 & D2 & ~(D3) & S1) | (~(D0) & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & D3 & ~(S1)) | (D0 & ~(D1) & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((~(D1) & D3 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D3) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX4_DG_2

//%BEGIN SEH_MUX4_DG_3

`celldefine
module SEH_MUX4_DG_3 (X, D0, D1, D2, D3, S0, S1);
   output X;
   input D0, D1, D2, D3, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         mux4 #1 (X, D3, D2, D1, D0, S1, S0);
   `else
         mux4 (X, D3, D2, D1, D0, S1, S0);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      (D3 => X) = 0;
      if ((D0 & D1 & ~(D2) & D3 & S1) | (~(D0) & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & D3 & ~(S1)) | (~(D0) & D1 & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & D1 & D2 & ~(D3) & S1) | (~(D0) & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & D3 & ~(S1)) | (D0 & ~(D1) & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((~(D1) & D3 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D3) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX4_DG_3

//%BEGIN SEH_MUX4_DG_4

`celldefine
module SEH_MUX4_DG_4 (X, D0, D1, D2, D3, S0, S1);
   output X;
   input D0, D1, D2, D3, S0, S1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         mux4 #1 (X, D3, D2, D1, D0, S1, S0);
   `else
         mux4 (X, D3, D2, D1, D0, S1, S0);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      (D3 => X) = 0;
      if ((D0 & D1 & ~(D2) & D3 & S1) | (~(D0) & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & D3 & ~(S1)) | (~(D0) & D1 & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & S1))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & D1 & D2 & ~(D3) & S1) | (~(D0) & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & D3 & ~(S1)) | (D0 & ~(D1) & ~(D2) & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & ~(S1)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & ~(S1)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & S1))
         (S0 => X) = 0;
      if ((~(D1) & D3 & S0))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0)))
         (S1 => X) = 0;
      if ((D1 & ~(D3) & S0))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0)))
         (S1 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX4_DG_4

//%BEGIN SEH_MUX5_CTY2_24

`celldefine
module SEH_MUX5_CTY2_24 (X, D0, D1, D2, D3, D4, S0, S1, S2);
   output X;
   input D0, D1, D2, D3, D4, S0, S1, S2;
   wire int_res_0, int_res_1, int_res_2;
   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_0, D1, D0, S0);
   mux2 (int_res_1, D3, D2, S0);
   mux2 (int_res_2, int_res_1, int_res_0, S1);


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D4, int_res_2, S2);
   `else
        mux2 (X, D4, int_res_2, S2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      (D3 => X) = 0;
      (D4 => X) = 0;
      if ((D0 & D1 & ~(D2) & D3 & S1 & ~(S2)) | (~(D0) & ~(D1) & ~(D2) & D3 & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & D3 & ~(S1) & ~(S2)) | (~(D0) & D1 & ~(D2) & ~(D3) & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & D1 & D2 & ~(D3) & S1 & ~(S2)) | (~(D0) & ~(D1) & D2 & ~(D3) & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & D3 & ~(S1) & ~(S2)) | (D0 & ~(D1) & ~(D2) & ~(D3) & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((~(D1) & D3 & S0 & ~(S2)))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0) & ~(S2)))
         (S1 => X) = 0;
      if ((D1 & ~(D3) & S0 & ~(S2)))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0) & ~(S2)))
         (S1 => X) = 0;
      if ((~(D3) & D4 & S0 & S1))
         (S2 => X) = 0;
      if ((~(D2) & D4 & ~(S0) & S1))
         (S2 => X) = 0;
      if ((~(D1) & D4 & S0 & ~(S1)))
         (S2 => X) = 0;
      if ((~(D0) & D4 & ~(S0) & ~(S1)))
         (S2 => X) = 0;
      if ((D3 & ~(D4) & S0 & S1))
         (S2 => X) = 0;
      if ((D1 & ~(D4) & S0 & ~(S1)))
         (S2 => X) = 0;
      if ((D2 & ~(D4) & ~(S0) & S1))
         (S2 => X) = 0;
      if ((D0 & ~(D4) & ~(S0) & ~(S1)))
         (S2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX5_CTY2_24

//%BEGIN SEH_MUX5_CTY2_32

`celldefine
module SEH_MUX5_CTY2_32 (X, D0, D1, D2, D3, D4, S0, S1, S2);
   output X;
   input D0, D1, D2, D3, D4, S0, S1, S2;
   wire int_res_0, int_res_1, int_res_2;
   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_0, D1, D0, S0);
   mux2 (int_res_1, D3, D2, S0);
   mux2 (int_res_2, int_res_1, int_res_0, S1);


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        mux2 #1 (X, D4, int_res_2, S2);
   `else
        mux2 (X, D4, int_res_2, S2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      (D2 => X) = 0;
      (D3 => X) = 0;
      (D4 => X) = 0;
      if ((D0 & D1 & ~(D2) & D3 & S1 & ~(S2)) | (~(D0) & ~(D1) & ~(D2) & D3 & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & D3 & ~(S1) & ~(S2)) | (~(D0) & D1 & ~(D2) & ~(D3) & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & ~(D2) & D3 & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & D1 & D2 & ~(D3) & S1 & ~(S2)) | (~(D0) & ~(D1) & D2 & ~(D3) & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & D3 & ~(S1) & ~(S2)) | (D0 & ~(D1) & ~(D2) & ~(D3) & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & D2 & ~(D3) & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((D0 & ~(D1) & ~(D2) & D3 & ~(S1) & ~(S2)))
         (S0 => X) = 0;
      if ((~(D0) & D1 & D2 & ~(D3) & S1 & ~(S2)))
         (S0 => X) = 0;
      if ((~(D1) & D3 & S0 & ~(S2)))
         (S1 => X) = 0;
      if ((~(D0) & D2 & ~(S0) & ~(S2)))
         (S1 => X) = 0;
      if ((D1 & ~(D3) & S0 & ~(S2)))
         (S1 => X) = 0;
      if ((D0 & ~(D2) & ~(S0) & ~(S2)))
         (S1 => X) = 0;
      if ((~(D3) & D4 & S0 & S1))
         (S2 => X) = 0;
      if ((~(D2) & D4 & ~(S0) & S1))
         (S2 => X) = 0;
      if ((~(D1) & D4 & S0 & ~(S1)))
         (S2 => X) = 0;
      if ((~(D0) & D4 & ~(S0) & ~(S1)))
         (S2 => X) = 0;
      if ((D3 & ~(D4) & S0 & S1))
         (S2 => X) = 0;
      if ((D1 & ~(D4) & S0 & ~(S1)))
         (S2 => X) = 0;
      if ((D2 & ~(D4) & ~(S0) & S1))
         (S2 => X) = 0;
      if ((D0 & ~(D4) & ~(S0) & ~(S1)))
         (S2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_MUX5_CTY2_32

//%BEGIN SEH_MUXI2_0P5

`celldefine
module SEH_MUXI2_0P5 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_0P5

//%BEGIN SEH_MUXI2_1

`celldefine
module SEH_MUXI2_1 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_1

//%BEGIN SEH_MUXI2_10

`celldefine
module SEH_MUXI2_10 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_10

//%BEGIN SEH_MUXI2_2

`celldefine
module SEH_MUXI2_2 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_2

//%BEGIN SEH_MUXI2_3

`celldefine
module SEH_MUXI2_3 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_3

//%BEGIN SEH_MUXI2_4

`celldefine
module SEH_MUXI2_4 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_4

//%BEGIN SEH_MUXI2_6

`celldefine
module SEH_MUXI2_6 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_6

//%BEGIN SEH_MUXI2_8

`celldefine
module SEH_MUXI2_8 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_8

//%BEGIN SEH_MUXI2_DGY2_16

`celldefine
module SEH_MUXI2_DGY2_16 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DGY2_16

//%BEGIN SEH_MUXI2_DG_0P5

`celldefine
module SEH_MUXI2_DG_0P5 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_0P5

//%BEGIN SEH_MUXI2_DG_0P75

`celldefine
module SEH_MUXI2_DG_0P75 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_0P75

//%BEGIN SEH_MUXI2_DG_1

`celldefine
module SEH_MUXI2_DG_1 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_1

//%BEGIN SEH_MUXI2_DG_10

`celldefine
module SEH_MUXI2_DG_10 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_10

//%BEGIN SEH_MUXI2_DG_12

`celldefine
module SEH_MUXI2_DG_12 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_12

//%BEGIN SEH_MUXI2_DG_1P5

`celldefine
module SEH_MUXI2_DG_1P5 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_1P5

//%BEGIN SEH_MUXI2_DG_2

`celldefine
module SEH_MUXI2_DG_2 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_2

//%BEGIN SEH_MUXI2_DG_2P5

`celldefine
module SEH_MUXI2_DG_2P5 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_2P5

//%BEGIN SEH_MUXI2_DG_3

`celldefine
module SEH_MUXI2_DG_3 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_3

//%BEGIN SEH_MUXI2_DG_4

`celldefine
module SEH_MUXI2_DG_4 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_4

//%BEGIN SEH_MUXI2_DG_5

`celldefine
module SEH_MUXI2_DG_5 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_5

//%BEGIN SEH_MUXI2_DG_6

`celldefine
module SEH_MUXI2_DG_6 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_6

//%BEGIN SEH_MUXI2_DG_8

`celldefine
module SEH_MUXI2_DG_8 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      if ((D1 & ~(S)))
         (D0 => X) = 0;
      if ((~(D1) & ~(S)))
         (D0 => X) = 0;
      if ((D0 & S))
         (D1 => X) = 0;
      if ((~(D0) & S))
         (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_DG_8

//%BEGIN SEH_MUXI2_S_0P5

`celldefine
module SEH_MUXI2_S_0P5 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_S_0P5

//%BEGIN SEH_MUXI2_S_1

`celldefine
module SEH_MUXI2_S_1 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_S_1

//%BEGIN SEH_MUXI2_S_2

`celldefine
module SEH_MUXI2_S_2 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_S_2

//%BEGIN SEH_MUXI2_S_3

`celldefine
module SEH_MUXI2_S_3 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_S_3

//%BEGIN SEH_MUXI2_S_4

`celldefine
module SEH_MUXI2_S_4 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_S_4

//%BEGIN SEH_MUXI2_S_6

`celldefine
module SEH_MUXI2_S_6 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_S_6

//%BEGIN SEH_MUXI2_S_8

`celldefine
module SEH_MUXI2_S_8 (X, D0, D1, S);
   output X;
   input D0, D1, S;

   wire int_res_mux1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   mux2 (int_res_mux1, D1, D0, S);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
        not #1 (X, int_res_mux1);
    `else
        not (X, int_res_mux1);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (D0 => X) = 0;
      (D1 => X) = 0;
      if ((D0 & ~(D1)))
         (S => X) = 0;
      if ((~(D0) & D1))
         (S => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_MUXI2_S_8

//%BEGIN SEH_ND2B_1

`celldefine
module SEH_ND2B_1 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_1

//%BEGIN SEH_ND2B_12

`celldefine
module SEH_ND2B_12 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_12

//%BEGIN SEH_ND2B_16

`celldefine
module SEH_ND2B_16 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_16

//%BEGIN SEH_ND2B_2

`celldefine
module SEH_ND2B_2 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_2

//%BEGIN SEH_ND2B_3

`celldefine
module SEH_ND2B_3 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_3

//%BEGIN SEH_ND2B_4

`celldefine
module SEH_ND2B_4 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_4

//%BEGIN SEH_ND2B_6

`celldefine
module SEH_ND2B_6 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_6

//%BEGIN SEH_ND2B_8

`celldefine
module SEH_ND2B_8 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_8

//%BEGIN SEH_ND2B_S_0P5

`celldefine
module SEH_ND2B_S_0P5 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_S_0P5

//%BEGIN SEH_ND2B_S_1

`celldefine
module SEH_ND2B_S_1 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_S_1

//%BEGIN SEH_ND2B_S_2

`celldefine
module SEH_ND2B_S_2 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_S_2

//%BEGIN SEH_ND2B_S_4

`celldefine
module SEH_ND2B_S_4 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_S_4

//%BEGIN SEH_ND2B_S_8

`celldefine
module SEH_ND2B_S_8 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_S_8

//%BEGIN SEH_ND2B_V1DG_1

`celldefine
module SEH_ND2B_V1DG_1 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1DG_1

//%BEGIN SEH_ND2B_V1DG_2

`celldefine
module SEH_ND2B_V1DG_2 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1DG_2

//%BEGIN SEH_ND2B_V1DG_4

`celldefine
module SEH_ND2B_V1DG_4 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1DG_4

//%BEGIN SEH_ND2B_V1DG_8

`celldefine
module SEH_ND2B_V1DG_8 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1DG_8

//%BEGIN SEH_ND2B_V1_1

`celldefine
module SEH_ND2B_V1_1 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1_1

//%BEGIN SEH_ND2B_V1_12

`celldefine
module SEH_ND2B_V1_12 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1_12

//%BEGIN SEH_ND2B_V1_16

`celldefine
module SEH_ND2B_V1_16 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1_16

//%BEGIN SEH_ND2B_V1_2

`celldefine
module SEH_ND2B_V1_2 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1_2

//%BEGIN SEH_ND2B_V1_3

`celldefine
module SEH_ND2B_V1_3 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1_3

//%BEGIN SEH_ND2B_V1_4

`celldefine
module SEH_ND2B_V1_4 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1_4

//%BEGIN SEH_ND2B_V1_5

`celldefine
module SEH_ND2B_V1_5 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1_5

//%BEGIN SEH_ND2B_V1_6

`celldefine
module SEH_ND2B_V1_6 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1_6

//%BEGIN SEH_ND2B_V1_8

`celldefine
module SEH_ND2B_V1_8 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2B_V1_8

//%BEGIN SEH_ND2EN2_0P5

`celldefine
module SEH_ND2EN2_0P5 (XD, XE, A1, A2);
   output XD, XE;
   input A1, A2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   
   xor (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (XD, A1, A2);
         not  #1 (XE, int_res_0);
   `else
         nand (XD, A1, A2);
         not  (XE, int_res_0);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => XD) = 0;
      (A2 => XD) = 0;
      if (A2)
         (A1 => XE) = 0;
      if (~(A2))
         (A1 => XE) = 0;
      if (A1)
         (A2 => XE) = 0;
      if (~(A1))
         (A2 => XE) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_ND2EN2_0P5

//%BEGIN SEH_ND2EN2_1

`celldefine
module SEH_ND2EN2_1 (XD, XE, A1, A2);
   output XD, XE;
   input A1, A2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   
   xor (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (XD, A1, A2);
         not  #1 (XE, int_res_0);
   `else
         nand (XD, A1, A2);
         not  (XE, int_res_0);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => XD) = 0;
      (A2 => XD) = 0;
      if (A2)
         (A1 => XE) = 0;
      if (~(A2))
         (A1 => XE) = 0;
      if (A1)
         (A2 => XE) = 0;
      if (~(A1))
         (A2 => XE) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_ND2EN2_1

//%BEGIN SEH_ND2EN2_2

`celldefine
module SEH_ND2EN2_2 (XD, XE, A1, A2);
   output XD, XE;
   input A1, A2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   
   xor (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (XD, A1, A2);
         not  #1 (XE, int_res_0);
   `else
         nand (XD, A1, A2);
         not  (XE, int_res_0);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => XD) = 0;
      (A2 => XD) = 0;
      if (A2)
         (A1 => XE) = 0;
      if (~(A2))
         (A1 => XE) = 0;
      if (A1)
         (A2 => XE) = 0;
      if (~(A1))
         (A2 => XE) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_ND2EN2_2

//%BEGIN SEH_ND2NR2EN2_0P5

`celldefine
module SEH_ND2NR2EN2_0P5 (XD, XE, XR, A1, A2);
   output XD, XE, XR;
   input A1, A2;
   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A1, A2);


   `ifdef VIRL_functiononly
         nand #1 (XD, A1, A2);
         not  #1 (XE, int_res_0);
         nor #1 (XR, A1, A2);
   `else
         nand (XD, A1, A2);
         not  (XE, int_res_0);
         nor  (XR, A1, A2);
   `endif

   `ifdef VIRL_functiononly
   

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////



   `else


   specify
      (A1 => XD) = 0;
      (A2 => XD) = 0;
      if (A2)
         (A1 => XE) = 0;
      if (~(A2))
         (A1 => XE) = 0;
      if (A1)
         (A2 => XE) = 0;
      if (~(A1))
         (A2 => XE) = 0;
      (A1 => XR) = 0;
      (A2 => XR) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_ND2NR2EN2_0P5

//%BEGIN SEH_ND2NR2EN2_1

`celldefine
module SEH_ND2NR2EN2_1 (XD, XE, XR, A1, A2);
   output XD, XE, XR;
   input A1, A2;
   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A1, A2);


   `ifdef VIRL_functiononly
         nand #1 (XD, A1, A2);
         not  #1 (XE, int_res_0);
         nor #1 (XR, A1, A2);
   `else
         nand (XD, A1, A2);
         not  (XE, int_res_0);
         nor  (XR, A1, A2);
   `endif

   `ifdef VIRL_functiononly
   

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////



   `else


   specify
      (A1 => XD) = 0;
      (A2 => XD) = 0;
      if (A2)
         (A1 => XE) = 0;
      if (~(A2))
         (A1 => XE) = 0;
      if (A1)
         (A2 => XE) = 0;
      if (~(A1))
         (A2 => XE) = 0;
      (A1 => XR) = 0;
      (A2 => XR) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_ND2NR2EN2_1

//%BEGIN SEH_ND2NR2EN2_2

`celldefine
module SEH_ND2NR2EN2_2 (XD, XE, XR, A1, A2);
   output XD, XE, XR;
   input A1, A2;
   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   xor (int_res_0, A1, A2);


   `ifdef VIRL_functiononly
         nand #1 (XD, A1, A2);
         not  #1 (XE, int_res_0);
         nor #1 (XR, A1, A2);
   `else
         nand (XD, A1, A2);
         not  (XE, int_res_0);
         nor  (XR, A1, A2);
   `endif

   `ifdef VIRL_functiononly
   

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////



   `else


   specify
      (A1 => XD) = 0;
      (A2 => XD) = 0;
      if (A2)
         (A1 => XE) = 0;
      if (~(A2))
         (A1 => XE) = 0;
      if (A1)
         (A2 => XE) = 0;
      if (~(A1))
         (A2 => XE) = 0;
      (A1 => XR) = 0;
      (A2 => XR) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_ND2NR2EN2_2

//%BEGIN SEH_ND2NR2_0P5

`celldefine
module SEH_ND2NR2_0P5 (XD, XR, A1, A2);
   output XD, XR;
   input A1, A2;


   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (XD, A1, A2);
         nor #1 (XR, A1, A2);
   `else
         nand (XD, A1, A2);
         nor  (XR, A1, A2);
   `endif

   `ifdef VIRL_functiononly
   

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////



   `else


   specify
      (A1 => XD) = 0;
      (A2 => XD) = 0;
      (A1 => XR) = 0;
      (A2 => XR) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_ND2NR2_0P5

//%BEGIN SEH_ND2NR2_1

`celldefine
module SEH_ND2NR2_1 (XD, XR, A1, A2);
   output XD, XR;
   input A1, A2;


   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (XD, A1, A2);
         nor #1 (XR, A1, A2);
   `else
         nand (XD, A1, A2);
         nor  (XR, A1, A2);
   `endif

   `ifdef VIRL_functiononly
   

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////



   `else


   specify
      (A1 => XD) = 0;
      (A2 => XD) = 0;
      (A1 => XR) = 0;
      (A2 => XR) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_ND2NR2_1

//%BEGIN SEH_ND2NR2_2

`celldefine
module SEH_ND2NR2_2 (XD, XR, A1, A2);
   output XD, XR;
   input A1, A2;


   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (XD, A1, A2);
         nor #1 (XR, A1, A2);
   `else
         nand (XD, A1, A2);
         nor  (XR, A1, A2);
   `endif

   `ifdef VIRL_functiononly
   

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////



   `else


   specify
      (A1 => XD) = 0;
      (A2 => XD) = 0;
      (A1 => XR) = 0;
      (A2 => XR) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_ND2NR2_2

//%BEGIN SEH_ND2_0P5

`celldefine
module SEH_ND2_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_0P5

//%BEGIN SEH_ND2_0P65

`celldefine
module SEH_ND2_0P65 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_0P65

//%BEGIN SEH_ND2_0P8

`celldefine
module SEH_ND2_0P8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_0P8

//%BEGIN SEH_ND2_1

`celldefine
module SEH_ND2_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_1

//%BEGIN SEH_ND2_10

`celldefine
module SEH_ND2_10 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_10

//%BEGIN SEH_ND2_12

`celldefine
module SEH_ND2_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_12

//%BEGIN SEH_ND2_16

`celldefine
module SEH_ND2_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_16

//%BEGIN SEH_ND2_1P5

`celldefine
module SEH_ND2_1P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_1P5

//%BEGIN SEH_ND2_2

`celldefine
module SEH_ND2_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_2

//%BEGIN SEH_ND2_20

`celldefine
module SEH_ND2_20 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_20

//%BEGIN SEH_ND2_24

`celldefine
module SEH_ND2_24 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_24

//%BEGIN SEH_ND2_3

`celldefine
module SEH_ND2_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_3

//%BEGIN SEH_ND2_4

`celldefine
module SEH_ND2_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_4

//%BEGIN SEH_ND2_5

`celldefine
module SEH_ND2_5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_5

//%BEGIN SEH_ND2_6

`celldefine
module SEH_ND2_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_6

//%BEGIN SEH_ND2_8

`celldefine
module SEH_ND2_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_8

//%BEGIN SEH_ND2_CTY2_16

`celldefine
module SEH_ND2_CTY2_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_CTY2_16

//%BEGIN SEH_ND2_CTY2_2

`celldefine
module SEH_ND2_CTY2_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_CTY2_2

//%BEGIN SEH_ND2_CTY2_4

`celldefine
module SEH_ND2_CTY2_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_CTY2_4

//%BEGIN SEH_ND2_CTY2_6

`celldefine
module SEH_ND2_CTY2_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_CTY2_6

//%BEGIN SEH_ND2_CTY2_8

`celldefine
module SEH_ND2_CTY2_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_CTY2_8

//%BEGIN SEH_ND2_GY2_32

`celldefine
module SEH_ND2_GY2_32 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_GY2_32

//%BEGIN SEH_ND2_G_0P65

`celldefine
module SEH_ND2_G_0P65 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_G_0P65

//%BEGIN SEH_ND2_G_1

`celldefine
module SEH_ND2_G_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_G_1

//%BEGIN SEH_ND2_G_10

`celldefine
module SEH_ND2_G_10 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_G_10

//%BEGIN SEH_ND2_G_12

`celldefine
module SEH_ND2_G_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_G_12

//%BEGIN SEH_ND2_G_16

`celldefine
module SEH_ND2_G_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_G_16

//%BEGIN SEH_ND2_G_2

`celldefine
module SEH_ND2_G_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_G_2

//%BEGIN SEH_ND2_G_24

`celldefine
module SEH_ND2_G_24 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_G_24

//%BEGIN SEH_ND2_G_3

`celldefine
module SEH_ND2_G_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_G_3

//%BEGIN SEH_ND2_G_4

`celldefine
module SEH_ND2_G_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_G_4

//%BEGIN SEH_ND2_G_6

`celldefine
module SEH_ND2_G_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_G_6

//%BEGIN SEH_ND2_G_8

`celldefine
module SEH_ND2_G_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_G_8

//%BEGIN SEH_ND2_S_0P5

`celldefine
module SEH_ND2_S_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_0P5

//%BEGIN SEH_ND2_S_0P65

`celldefine
module SEH_ND2_S_0P65 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_0P65

//%BEGIN SEH_ND2_S_0P8

`celldefine
module SEH_ND2_S_0P8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_0P8

//%BEGIN SEH_ND2_S_1

`celldefine
module SEH_ND2_S_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_1

//%BEGIN SEH_ND2_S_10

`celldefine
module SEH_ND2_S_10 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_10

//%BEGIN SEH_ND2_S_12

`celldefine
module SEH_ND2_S_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_12

//%BEGIN SEH_ND2_S_16

`celldefine
module SEH_ND2_S_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_16

//%BEGIN SEH_ND2_S_1P25

`celldefine
module SEH_ND2_S_1P25 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_1P25

//%BEGIN SEH_ND2_S_1P5

`celldefine
module SEH_ND2_S_1P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_1P5

//%BEGIN SEH_ND2_S_2

`celldefine
module SEH_ND2_S_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_2

//%BEGIN SEH_ND2_S_20

`celldefine
module SEH_ND2_S_20 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_20

//%BEGIN SEH_ND2_S_24

`celldefine
module SEH_ND2_S_24 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_24

//%BEGIN SEH_ND2_S_2P5

`celldefine
module SEH_ND2_S_2P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_2P5

//%BEGIN SEH_ND2_S_3

`celldefine
module SEH_ND2_S_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_3

//%BEGIN SEH_ND2_S_4

`celldefine
module SEH_ND2_S_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_4

//%BEGIN SEH_ND2_S_5

`celldefine
module SEH_ND2_S_5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_5

//%BEGIN SEH_ND2_S_6

`celldefine
module SEH_ND2_S_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_6

//%BEGIN SEH_ND2_S_8

`celldefine
module SEH_ND2_S_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_S_8

//%BEGIN SEH_ND2_TY2_24

`celldefine
module SEH_ND2_TY2_24 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_TY2_24

//%BEGIN SEH_ND2_T_0P5

`celldefine
module SEH_ND2_T_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_0P5

//%BEGIN SEH_ND2_T_0P65

`celldefine
module SEH_ND2_T_0P65 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_0P65

//%BEGIN SEH_ND2_T_0P8

`celldefine
module SEH_ND2_T_0P8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_0P8

//%BEGIN SEH_ND2_T_1

`celldefine
module SEH_ND2_T_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_1

//%BEGIN SEH_ND2_T_10

`celldefine
module SEH_ND2_T_10 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_10

//%BEGIN SEH_ND2_T_12

`celldefine
module SEH_ND2_T_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_12

//%BEGIN SEH_ND2_T_16

`celldefine
module SEH_ND2_T_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_16

//%BEGIN SEH_ND2_T_1P25

`celldefine
module SEH_ND2_T_1P25 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_1P25

//%BEGIN SEH_ND2_T_1P5

`celldefine
module SEH_ND2_T_1P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_1P5

//%BEGIN SEH_ND2_T_2

`celldefine
module SEH_ND2_T_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_2

//%BEGIN SEH_ND2_T_2P5

`celldefine
module SEH_ND2_T_2P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_2P5

//%BEGIN SEH_ND2_T_3

`celldefine
module SEH_ND2_T_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_3

//%BEGIN SEH_ND2_T_4

`celldefine
module SEH_ND2_T_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_4

//%BEGIN SEH_ND2_T_5

`celldefine
module SEH_ND2_T_5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_5

//%BEGIN SEH_ND2_T_6

`celldefine
module SEH_ND2_T_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_6

//%BEGIN SEH_ND2_T_8

`celldefine
module SEH_ND2_T_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_T_8

//%BEGIN SEH_ND2_Y2_32

`celldefine
module SEH_ND2_Y2_32 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2);
   `else
        nand (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND2_Y2_32

//%BEGIN SEH_ND3B_0P5

`celldefine
module SEH_ND3B_0P5 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_0P5

//%BEGIN SEH_ND3B_1

`celldefine
module SEH_ND3B_1 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_1

//%BEGIN SEH_ND3B_2

`celldefine
module SEH_ND3B_2 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_2

//%BEGIN SEH_ND3B_4

`celldefine
module SEH_ND3B_4 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_4

//%BEGIN SEH_ND3B_8

`celldefine
module SEH_ND3B_8 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_8

//%BEGIN SEH_ND3B_DG_1

`celldefine
module SEH_ND3B_DG_1 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_DG_1

//%BEGIN SEH_ND3B_DG_2

`celldefine
module SEH_ND3B_DG_2 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_DG_2

//%BEGIN SEH_ND3B_DG_4

`celldefine
module SEH_ND3B_DG_4 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_DG_4

//%BEGIN SEH_ND3B_V1DG_1

`celldefine
module SEH_ND3B_V1DG_1 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_V1DG_1

//%BEGIN SEH_ND3B_V1DG_2

`celldefine
module SEH_ND3B_V1DG_2 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_V1DG_2

//%BEGIN SEH_ND3B_V1DG_4

`celldefine
module SEH_ND3B_V1DG_4 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_V1DG_4

//%BEGIN SEH_ND3B_V1DG_8

`celldefine
module SEH_ND3B_V1DG_8 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

    `ifdef VIRL_functiononly
          nand #1 (X, int_res_0, B1, B2);

    `else
          nand (X, int_res_0, B1, B2);

    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_ND3B_V1DG_8

//%BEGIN SEH_ND3_0P5

`celldefine
module SEH_ND3_0P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_0P5

//%BEGIN SEH_ND3_1

`celldefine
module SEH_ND3_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_1

//%BEGIN SEH_ND3_2

`celldefine
module SEH_ND3_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_2

//%BEGIN SEH_ND3_3

`celldefine
module SEH_ND3_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_3

//%BEGIN SEH_ND3_4

`celldefine
module SEH_ND3_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_4

//%BEGIN SEH_ND3_6

`celldefine
module SEH_ND3_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_6

//%BEGIN SEH_ND3_8

`celldefine
module SEH_ND3_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_8

//%BEGIN SEH_ND3_S_0P5

`celldefine
module SEH_ND3_S_0P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_S_0P5

//%BEGIN SEH_ND3_S_1

`celldefine
module SEH_ND3_S_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_S_1

//%BEGIN SEH_ND3_S_2

`celldefine
module SEH_ND3_S_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_S_2

//%BEGIN SEH_ND3_S_4

`celldefine
module SEH_ND3_S_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_S_4

//%BEGIN SEH_ND3_S_6

`celldefine
module SEH_ND3_S_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_S_6

//%BEGIN SEH_ND3_S_8

`celldefine
module SEH_ND3_S_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_S_8

//%BEGIN SEH_ND3_T_0P5

`celldefine
module SEH_ND3_T_0P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_0P5

//%BEGIN SEH_ND3_T_0P65

`celldefine
module SEH_ND3_T_0P65 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_0P65

//%BEGIN SEH_ND3_T_0P8

`celldefine
module SEH_ND3_T_0P8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_0P8

//%BEGIN SEH_ND3_T_1

`celldefine
module SEH_ND3_T_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_1

//%BEGIN SEH_ND3_T_10

`celldefine
module SEH_ND3_T_10 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_10

//%BEGIN SEH_ND3_T_12

`celldefine
module SEH_ND3_T_12 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_12

//%BEGIN SEH_ND3_T_16

`celldefine
module SEH_ND3_T_16 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_16

//%BEGIN SEH_ND3_T_1P5

`celldefine
module SEH_ND3_T_1P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_1P5

//%BEGIN SEH_ND3_T_2

`celldefine
module SEH_ND3_T_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_2

//%BEGIN SEH_ND3_T_2P5

`celldefine
module SEH_ND3_T_2P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_2P5

//%BEGIN SEH_ND3_T_3

`celldefine
module SEH_ND3_T_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_3

//%BEGIN SEH_ND3_T_4

`celldefine
module SEH_ND3_T_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_4

//%BEGIN SEH_ND3_T_6

`celldefine
module SEH_ND3_T_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_6

//%BEGIN SEH_ND3_T_8

`celldefine
module SEH_ND3_T_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, A1, A2, A3);
   `else
        nand (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND3_T_8

//%BEGIN SEH_ND4B_1

`celldefine
module SEH_ND4B_1 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, B1, B2, B3);
   `else
         nand (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4B_1

//%BEGIN SEH_ND4B_2

`celldefine
module SEH_ND4B_2 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, B1, B2, B3);
   `else
         nand (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4B_2

//%BEGIN SEH_ND4B_4

`celldefine
module SEH_ND4B_4 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, B1, B2, B3);
   `else
         nand (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4B_4

//%BEGIN SEH_ND4B_8

`celldefine
module SEH_ND4B_8 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, B1, B2, B3);
   `else
         nand (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4B_8

//%BEGIN SEH_ND4_1

`celldefine
module SEH_ND4_1 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_1

//%BEGIN SEH_ND4_12

`celldefine
module SEH_ND4_12 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_12

//%BEGIN SEH_ND4_16

`celldefine
module SEH_ND4_16 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_16

//%BEGIN SEH_ND4_2

`celldefine
module SEH_ND4_2 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_2

//%BEGIN SEH_ND4_4

`celldefine
module SEH_ND4_4 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_4

//%BEGIN SEH_ND4_8

`celldefine
module SEH_ND4_8 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_8

//%BEGIN SEH_ND4_S_0P5

`celldefine
module SEH_ND4_S_0P5 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_S_0P5

//%BEGIN SEH_ND4_S_1

`celldefine
module SEH_ND4_S_1 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_S_1

//%BEGIN SEH_ND4_S_1P5

`celldefine
module SEH_ND4_S_1P5 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_S_1P5

//%BEGIN SEH_ND4_S_2

`celldefine
module SEH_ND4_S_2 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_S_2

//%BEGIN SEH_ND4_S_3

`celldefine
module SEH_ND4_S_3 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_S_3

//%BEGIN SEH_ND4_S_4

`celldefine
module SEH_ND4_S_4 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_S_4

//%BEGIN SEH_ND4_S_6

`celldefine
module SEH_ND4_S_6 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_S_6

//%BEGIN SEH_ND4_S_8

`celldefine
module SEH_ND4_S_8 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, A1, A2, A3, A4);
   `else
       nand (X, A1, A2, A3, A4);

    `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_ND4_S_8

//%BEGIN SEH_NR2B_1

`celldefine
module SEH_NR2B_1 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_1

//%BEGIN SEH_NR2B_10

`celldefine
module SEH_NR2B_10 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_10

//%BEGIN SEH_NR2B_12

`celldefine
module SEH_NR2B_12 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_12

//%BEGIN SEH_NR2B_16

`celldefine
module SEH_NR2B_16 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_16

//%BEGIN SEH_NR2B_2

`celldefine
module SEH_NR2B_2 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_2

//%BEGIN SEH_NR2B_3

`celldefine
module SEH_NR2B_3 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_3

//%BEGIN SEH_NR2B_4

`celldefine
module SEH_NR2B_4 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_4

//%BEGIN SEH_NR2B_6

`celldefine
module SEH_NR2B_6 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_6

//%BEGIN SEH_NR2B_8

`celldefine
module SEH_NR2B_8 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_8

//%BEGIN SEH_NR2B_V1DG_1

`celldefine
module SEH_NR2B_V1DG_1 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1DG_1

//%BEGIN SEH_NR2B_V1DG_12

`celldefine
module SEH_NR2B_V1DG_12 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1DG_12

//%BEGIN SEH_NR2B_V1DG_16

`celldefine
module SEH_NR2B_V1DG_16 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1DG_16

//%BEGIN SEH_NR2B_V1DG_2

`celldefine
module SEH_NR2B_V1DG_2 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1DG_2

//%BEGIN SEH_NR2B_V1DG_3

`celldefine
module SEH_NR2B_V1DG_3 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1DG_3

//%BEGIN SEH_NR2B_V1DG_4

`celldefine
module SEH_NR2B_V1DG_4 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1DG_4

//%BEGIN SEH_NR2B_V1DG_6

`celldefine
module SEH_NR2B_V1DG_6 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1DG_6

//%BEGIN SEH_NR2B_V1DG_8

`celldefine
module SEH_NR2B_V1DG_8 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1DG_8

//%BEGIN SEH_NR2B_V1_1

`celldefine
module SEH_NR2B_V1_1 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1_1

//%BEGIN SEH_NR2B_V1_12

`celldefine
module SEH_NR2B_V1_12 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1_12

//%BEGIN SEH_NR2B_V1_2

`celldefine
module SEH_NR2B_V1_2 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1_2

//%BEGIN SEH_NR2B_V1_3

`celldefine
module SEH_NR2B_V1_3 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1_3

//%BEGIN SEH_NR2B_V1_4

`celldefine
module SEH_NR2B_V1_4 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1_4

//%BEGIN SEH_NR2B_V1_6

`celldefine
module SEH_NR2B_V1_6 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1_6

//%BEGIN SEH_NR2B_V1_8

`celldefine
module SEH_NR2B_V1_8 (X, A, B);
   output X;
   input A, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B);

   `else
        nor (X, int_res_0, B);
    `endif

    `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR2B_V1_8

//%BEGIN SEH_NR2_0P5

`celldefine
module SEH_NR2_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_0P5

//%BEGIN SEH_NR2_0P65

`celldefine
module SEH_NR2_0P65 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_0P65

//%BEGIN SEH_NR2_0P8

`celldefine
module SEH_NR2_0P8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_0P8

//%BEGIN SEH_NR2_1

`celldefine
module SEH_NR2_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_1

//%BEGIN SEH_NR2_12

`celldefine
module SEH_NR2_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_12

//%BEGIN SEH_NR2_16

`celldefine
module SEH_NR2_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_16

//%BEGIN SEH_NR2_1P5

`celldefine
module SEH_NR2_1P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_1P5

//%BEGIN SEH_NR2_2

`celldefine
module SEH_NR2_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_2

//%BEGIN SEH_NR2_3

`celldefine
module SEH_NR2_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_3

//%BEGIN SEH_NR2_4

`celldefine
module SEH_NR2_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_4

//%BEGIN SEH_NR2_5

`celldefine
module SEH_NR2_5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_5

//%BEGIN SEH_NR2_6

`celldefine
module SEH_NR2_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_6

//%BEGIN SEH_NR2_8

`celldefine
module SEH_NR2_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_8

//%BEGIN SEH_NR2_CTY2_12

`celldefine
module SEH_NR2_CTY2_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_CTY2_12

//%BEGIN SEH_NR2_CTY2_16

`celldefine
module SEH_NR2_CTY2_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_CTY2_16

//%BEGIN SEH_NR2_CTY2_4

`celldefine
module SEH_NR2_CTY2_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_CTY2_4

//%BEGIN SEH_NR2_CTY2_6

`celldefine
module SEH_NR2_CTY2_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_CTY2_6

//%BEGIN SEH_NR2_CTY2_8

`celldefine
module SEH_NR2_CTY2_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_CTY2_8

//%BEGIN SEH_NR2_G_0P5

`celldefine
module SEH_NR2_G_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_0P5

//%BEGIN SEH_NR2_G_0P65

`celldefine
module SEH_NR2_G_0P65 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_0P65

//%BEGIN SEH_NR2_G_0P8

`celldefine
module SEH_NR2_G_0P8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_0P8

//%BEGIN SEH_NR2_G_1

`celldefine
module SEH_NR2_G_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_1

//%BEGIN SEH_NR2_G_10

`celldefine
module SEH_NR2_G_10 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_10

//%BEGIN SEH_NR2_G_12

`celldefine
module SEH_NR2_G_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_12

//%BEGIN SEH_NR2_G_16

`celldefine
module SEH_NR2_G_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_16

//%BEGIN SEH_NR2_G_1P5

`celldefine
module SEH_NR2_G_1P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_1P5

//%BEGIN SEH_NR2_G_2

`celldefine
module SEH_NR2_G_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_2

//%BEGIN SEH_NR2_G_3

`celldefine
module SEH_NR2_G_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_3

//%BEGIN SEH_NR2_G_4

`celldefine
module SEH_NR2_G_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_4

//%BEGIN SEH_NR2_G_5

`celldefine
module SEH_NR2_G_5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_5

//%BEGIN SEH_NR2_G_6

`celldefine
module SEH_NR2_G_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_6

//%BEGIN SEH_NR2_G_8

`celldefine
module SEH_NR2_G_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_G_8

//%BEGIN SEH_NR2_S_0P5

`celldefine
module SEH_NR2_S_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_0P5

//%BEGIN SEH_NR2_S_0P65

`celldefine
module SEH_NR2_S_0P65 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_0P65

//%BEGIN SEH_NR2_S_0P8

`celldefine
module SEH_NR2_S_0P8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_0P8

//%BEGIN SEH_NR2_S_1

`celldefine
module SEH_NR2_S_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_1

//%BEGIN SEH_NR2_S_10

`celldefine
module SEH_NR2_S_10 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_10

//%BEGIN SEH_NR2_S_12

`celldefine
module SEH_NR2_S_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_12

//%BEGIN SEH_NR2_S_16

`celldefine
module SEH_NR2_S_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_16

//%BEGIN SEH_NR2_S_2

`celldefine
module SEH_NR2_S_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_2

//%BEGIN SEH_NR2_S_2P5

`celldefine
module SEH_NR2_S_2P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_2P5

//%BEGIN SEH_NR2_S_3

`celldefine
module SEH_NR2_S_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_3

//%BEGIN SEH_NR2_S_4

`celldefine
module SEH_NR2_S_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_4

//%BEGIN SEH_NR2_S_5

`celldefine
module SEH_NR2_S_5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_5

//%BEGIN SEH_NR2_S_6

`celldefine
module SEH_NR2_S_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_6

//%BEGIN SEH_NR2_S_8

`celldefine
module SEH_NR2_S_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_S_8

//%BEGIN SEH_NR2_T_0P5

`celldefine
module SEH_NR2_T_0P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_0P5

//%BEGIN SEH_NR2_T_0P65

`celldefine
module SEH_NR2_T_0P65 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_0P65

//%BEGIN SEH_NR2_T_0P8

`celldefine
module SEH_NR2_T_0P8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_0P8

//%BEGIN SEH_NR2_T_1

`celldefine
module SEH_NR2_T_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_1

//%BEGIN SEH_NR2_T_10

`celldefine
module SEH_NR2_T_10 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_10

//%BEGIN SEH_NR2_T_12

`celldefine
module SEH_NR2_T_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_12

//%BEGIN SEH_NR2_T_16

`celldefine
module SEH_NR2_T_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_16

//%BEGIN SEH_NR2_T_1P5

`celldefine
module SEH_NR2_T_1P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_1P5

//%BEGIN SEH_NR2_T_2

`celldefine
module SEH_NR2_T_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_2

//%BEGIN SEH_NR2_T_2P5

`celldefine
module SEH_NR2_T_2P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_2P5

//%BEGIN SEH_NR2_T_3

`celldefine
module SEH_NR2_T_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_3

//%BEGIN SEH_NR2_T_4

`celldefine
module SEH_NR2_T_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_4

//%BEGIN SEH_NR2_T_5

`celldefine
module SEH_NR2_T_5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_5

//%BEGIN SEH_NR2_T_6

`celldefine
module SEH_NR2_T_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_6

//%BEGIN SEH_NR2_T_8

`celldefine
module SEH_NR2_T_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2);
   `else
        nor (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR2_T_8

//%BEGIN SEH_NR3B_DG_1

`celldefine
module SEH_NR3B_DG_1 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B1, B2);
   `else
        nor (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR3B_DG_1

//%BEGIN SEH_NR3B_DG_2

`celldefine
module SEH_NR3B_DG_2 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B1, B2);
   `else
        nor (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR3B_DG_2

//%BEGIN SEH_NR3B_DG_3

`celldefine
module SEH_NR3B_DG_3 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B1, B2);
   `else
        nor (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR3B_DG_3

//%BEGIN SEH_NR3B_DG_4

`celldefine
module SEH_NR3B_DG_4 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B1, B2);
   `else
        nor (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR3B_DG_4

//%BEGIN SEH_NR3B_DG_6

`celldefine
module SEH_NR3B_DG_6 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B1, B2);
   `else
        nor (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR3B_DG_6

//%BEGIN SEH_NR3B_DG_8

`celldefine
module SEH_NR3B_DG_8 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B1, B2);
   `else
        nor (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

    `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

    `endif

endmodule
`endcelldefine

//%END SEH_NR3B_DG_8

//%BEGIN SEH_NR3_0P5

`celldefine
module SEH_NR3_0P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_0P5

//%BEGIN SEH_NR3_0P65

`celldefine
module SEH_NR3_0P65 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_0P65

//%BEGIN SEH_NR3_0P8

`celldefine
module SEH_NR3_0P8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_0P8

//%BEGIN SEH_NR3_1

`celldefine
module SEH_NR3_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_1

//%BEGIN SEH_NR3_12

`celldefine
module SEH_NR3_12 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_12

//%BEGIN SEH_NR3_2

`celldefine
module SEH_NR3_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_2

//%BEGIN SEH_NR3_3

`celldefine
module SEH_NR3_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_3

//%BEGIN SEH_NR3_4

`celldefine
module SEH_NR3_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_4

//%BEGIN SEH_NR3_5

`celldefine
module SEH_NR3_5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_5

//%BEGIN SEH_NR3_6

`celldefine
module SEH_NR3_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_6

//%BEGIN SEH_NR3_8

`celldefine
module SEH_NR3_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_8

//%BEGIN SEH_NR3_G_1

`celldefine
module SEH_NR3_G_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_G_1

//%BEGIN SEH_NR3_G_12

`celldefine
module SEH_NR3_G_12 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_G_12

//%BEGIN SEH_NR3_G_2

`celldefine
module SEH_NR3_G_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_G_2

//%BEGIN SEH_NR3_G_3

`celldefine
module SEH_NR3_G_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_G_3

//%BEGIN SEH_NR3_G_4

`celldefine
module SEH_NR3_G_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_G_4

//%BEGIN SEH_NR3_G_6

`celldefine
module SEH_NR3_G_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_G_6

//%BEGIN SEH_NR3_G_8

`celldefine
module SEH_NR3_G_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_G_8

//%BEGIN SEH_NR3_T_0P5

`celldefine
module SEH_NR3_T_0P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_0P5

//%BEGIN SEH_NR3_T_0P65

`celldefine
module SEH_NR3_T_0P65 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_0P65

//%BEGIN SEH_NR3_T_0P8

`celldefine
module SEH_NR3_T_0P8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_0P8

//%BEGIN SEH_NR3_T_1

`celldefine
module SEH_NR3_T_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_1

//%BEGIN SEH_NR3_T_10

`celldefine
module SEH_NR3_T_10 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_10

//%BEGIN SEH_NR3_T_12

`celldefine
module SEH_NR3_T_12 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_12

//%BEGIN SEH_NR3_T_16

`celldefine
module SEH_NR3_T_16 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_16

//%BEGIN SEH_NR3_T_1P5

`celldefine
module SEH_NR3_T_1P5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_1P5

//%BEGIN SEH_NR3_T_2

`celldefine
module SEH_NR3_T_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_2

//%BEGIN SEH_NR3_T_3

`celldefine
module SEH_NR3_T_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_3

//%BEGIN SEH_NR3_T_4

`celldefine
module SEH_NR3_T_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_4

//%BEGIN SEH_NR3_T_5

`celldefine
module SEH_NR3_T_5 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_5

//%BEGIN SEH_NR3_T_6

`celldefine
module SEH_NR3_T_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_6

//%BEGIN SEH_NR3_T_8

`celldefine
module SEH_NR3_T_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, A1, A2, A3);
   `else
        nor (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR3_T_8

//%BEGIN SEH_NR4B_1

`celldefine
module SEH_NR4B_1 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B1, B2, B3);
   `else
        nor (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR4B_1

//%BEGIN SEH_NR4B_2

`celldefine
module SEH_NR4B_2 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B1, B2, B3);
   `else
        nor (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR4B_2

//%BEGIN SEH_NR4B_4

`celldefine
module SEH_NR4B_4 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nor #1 (X, int_res_0, B1, B2, B3);
   `else
        nor (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR4B_4

//%BEGIN SEH_NR4_0P5

`celldefine
module SEH_NR4_0P5 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nor #1 (X, A1, A2, A3, A4);
   `else
         nor (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR4_0P5

//%BEGIN SEH_NR4_1

`celldefine
module SEH_NR4_1 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nor #1 (X, A1, A2, A3, A4);
   `else
         nor (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR4_1

//%BEGIN SEH_NR4_2

`celldefine
module SEH_NR4_2 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nor #1 (X, A1, A2, A3, A4);
   `else
         nor (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR4_2

//%BEGIN SEH_NR4_3

`celldefine
module SEH_NR4_3 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nor #1 (X, A1, A2, A3, A4);
   `else
         nor (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR4_3

//%BEGIN SEH_NR4_4

`celldefine
module SEH_NR4_4 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nor #1 (X, A1, A2, A3, A4);
   `else
         nor (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR4_4

//%BEGIN SEH_NR4_6

`celldefine
module SEH_NR4_6 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nor #1 (X, A1, A2, A3, A4);
   `else
         nor (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR4_6

//%BEGIN SEH_NR4_8

`celldefine
module SEH_NR4_8 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nor #1 (X, A1, A2, A3, A4);
   `else
         nor (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_NR4_8

//%BEGIN SEH_OA21B_0P5

`celldefine
module SEH_OA21B_0P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_0, int_res_1);
   `else
       and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21B_0P5

//%BEGIN SEH_OA21B_1

`celldefine
module SEH_OA21B_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_0, int_res_1);
   `else
       and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21B_1

//%BEGIN SEH_OA21B_2

`celldefine
module SEH_OA21B_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_0, int_res_1);
   `else
       and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21B_2

//%BEGIN SEH_OA21B_3

`celldefine
module SEH_OA21B_3 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_0, int_res_1);
   `else
       and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21B_3

//%BEGIN SEH_OA21B_4

`celldefine
module SEH_OA21B_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_0, int_res_1);
   `else
       and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21B_4

//%BEGIN SEH_OA21B_8

`celldefine
module SEH_OA21B_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_0, int_res_1);
   `else
       and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21B_8

//%BEGIN SEH_OA21_1

`celldefine
module SEH_OA21_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21_1

//%BEGIN SEH_OA21_2

`celldefine
module SEH_OA21_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21_2

//%BEGIN SEH_OA21_4

`celldefine
module SEH_OA21_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21_4

//%BEGIN SEH_OA21_8

`celldefine
module SEH_OA21_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21_8

//%BEGIN SEH_OA21_V2_1

`celldefine
module SEH_OA21_V2_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21_V2_1

//%BEGIN SEH_OA21_V2_2

`celldefine
module SEH_OA21_V2_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21_V2_2

//%BEGIN SEH_OA21_V2_4

`celldefine
module SEH_OA21_V2_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21_V2_4

//%BEGIN SEH_OA21_V2_6

`celldefine
module SEH_OA21_V2_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21_V2_6

//%BEGIN SEH_OA21_V2_8

`celldefine
module SEH_OA21_V2_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA21_V2_8

//%BEGIN SEH_OA222_0P5

`celldefine
module SEH_OA222_0P5 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or  (int_res_0, A1, A2);
   or  (int_res_1, B1, B2);
   or  (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         and #1 (X, int_res_0, int_res_1, int_res_2);
   `else
         and (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C2)) | (A1 & ~(A2) & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C1)) | (A1 & ~(A2) & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA222_0P5

//%BEGIN SEH_OA222_1

`celldefine
module SEH_OA222_1 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or  (int_res_0, A1, A2);
   or  (int_res_1, B1, B2);
   or  (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         and #1 (X, int_res_0, int_res_1, int_res_2);
   `else
         and (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C2)) | (A1 & ~(A2) & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C1)) | (A1 & ~(A2) & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA222_1

//%BEGIN SEH_OA222_2

`celldefine
module SEH_OA222_2 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or  (int_res_0, A1, A2);
   or  (int_res_1, B1, B2);
   or  (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         and #1 (X, int_res_0, int_res_1, int_res_2);
   `else
         and (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C2)) | (A1 & ~(A2) & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C1)) | (A1 & ~(A2) & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA222_2

//%BEGIN SEH_OA222_4

`celldefine
module SEH_OA222_4 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or  (int_res_0, A1, A2);
   or  (int_res_1, B1, B2);
   or  (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         and #1 (X, int_res_0, int_res_1, int_res_2);
   `else
         and (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C2)) | (A1 & ~(A2) & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C1)) | (A1 & ~(A2) & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA222_4

//%BEGIN SEH_OA22_1

`celldefine
module SEH_OA22_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA22_1

//%BEGIN SEH_OA22_2

`celldefine
module SEH_OA22_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA22_2

//%BEGIN SEH_OA22_4

`celldefine
module SEH_OA22_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA22_4

//%BEGIN SEH_OA22_6

`celldefine
module SEH_OA22_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA22_6

//%BEGIN SEH_OA22_8

`celldefine
module SEH_OA22_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA22_8

//%BEGIN SEH_OA22_DG_1

`celldefine
module SEH_OA22_DG_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA22_DG_1

//%BEGIN SEH_OA22_DG_2

`celldefine
module SEH_OA22_DG_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA22_DG_2

//%BEGIN SEH_OA22_DG_4

`celldefine
module SEH_OA22_DG_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA22_DG_4

//%BEGIN SEH_OA22_DG_8

`celldefine
module SEH_OA22_DG_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA22_DG_8

//%BEGIN SEH_OA2BB2_0P5

`celldefine
module SEH_OA2BB2_0P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_0P5

//%BEGIN SEH_OA2BB2_1

`celldefine
module SEH_OA2BB2_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_1

//%BEGIN SEH_OA2BB2_1P5

`celldefine
module SEH_OA2BB2_1P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_1P5

//%BEGIN SEH_OA2BB2_2

`celldefine
module SEH_OA2BB2_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_2

//%BEGIN SEH_OA2BB2_4

`celldefine
module SEH_OA2BB2_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_4

//%BEGIN SEH_OA2BB2_6

`celldefine
module SEH_OA2BB2_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_6

//%BEGIN SEH_OA2BB2_8

`celldefine
module SEH_OA2BB2_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_8

//%BEGIN SEH_OA2BB2_DG_1

`celldefine
module SEH_OA2BB2_DG_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_DG_1

//%BEGIN SEH_OA2BB2_DG_2

`celldefine
module SEH_OA2BB2_DG_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_DG_2

//%BEGIN SEH_OA2BB2_DG_4

`celldefine
module SEH_OA2BB2_DG_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_DG_4

//%BEGIN SEH_OA2BB2_DG_6

`celldefine
module SEH_OA2BB2_DG_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_DG_6

//%BEGIN SEH_OA2BB2_DG_8

`celldefine
module SEH_OA2BB2_DG_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1, int_res_2, 
      int_res_3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A1);
   not (int_res_1, A2);
   or (int_res_2, int_res_0, int_res_1);
   or (int_res_3, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_2, int_res_3);
   `else
        and (X, int_res_2, int_res_3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA2BB2_DG_8

//%BEGIN SEH_OA311_1

`celldefine
module SEH_OA311_1 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B1, B2);
   `else
        and (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2) | (A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1) | (A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA311_1

//%BEGIN SEH_OA311_2

`celldefine
module SEH_OA311_2 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B1, B2);
   `else
        and (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2) | (A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1) | (A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA311_2

//%BEGIN SEH_OA311_4

`celldefine
module SEH_OA311_4 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B1, B2);
   `else
        and (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2) | (A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1) | (A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA311_4

//%BEGIN SEH_OA31_0P5

`celldefine
module SEH_OA31_0P5 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA31_0P5

//%BEGIN SEH_OA31_1

`celldefine
module SEH_OA31_1 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA31_1

//%BEGIN SEH_OA31_2

`celldefine
module SEH_OA31_2 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA31_2

//%BEGIN SEH_OA31_4

`celldefine
module SEH_OA31_4 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA31_4

//%BEGIN SEH_OA32_1

`celldefine
module SEH_OA32_1 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_0, int_res_1);
   `else
       and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1)) | (A1 & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA32_1

//%BEGIN SEH_OA32_2

`celldefine
module SEH_OA32_2 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_0, int_res_1);
   `else
       and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1)) | (A1 & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA32_2

//%BEGIN SEH_OA32_4

`celldefine
module SEH_OA32_4 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       and #1 (X, int_res_0, int_res_1);
   `else
       and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1)) | (A1 & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA32_4

//%BEGIN SEH_OA33_0P5

`celldefine
module SEH_OA33_0P5 (X, A1, A2, A3, B1, B2, B3);
   output X;
   input A1, A2, A3, B1, B2, B3;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or  (int_res_0, A1, A2, A3);
   or  (int_res_1, B1, B2, B3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & B2 & ~(B3)) | (~(A2) & ~(A3) & B1 & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & ~(B3)) | (~(A1) & ~(A3) & B1 & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & ~(B3)) | (~(A1) & ~(A2) & B1 & ~(B2) & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA33_0P5

//%BEGIN SEH_OA33_1

`celldefine
module SEH_OA33_1 (X, A1, A2, A3, B1, B2, B3);
   output X;
   input A1, A2, A3, B1, B2, B3;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or  (int_res_0, A1, A2, A3);
   or  (int_res_1, B1, B2, B3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & B2 & ~(B3)) | (~(A2) & ~(A3) & B1 & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & ~(B3)) | (~(A1) & ~(A3) & B1 & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & ~(B3)) | (~(A1) & ~(A2) & B1 & ~(B2) & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA33_1

//%BEGIN SEH_OA33_1P5

`celldefine
module SEH_OA33_1P5 (X, A1, A2, A3, B1, B2, B3);
   output X;
   input A1, A2, A3, B1, B2, B3;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or  (int_res_0, A1, A2, A3);
   or  (int_res_1, B1, B2, B3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & B2 & ~(B3)) | (~(A2) & ~(A3) & B1 & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & ~(B3)) | (~(A1) & ~(A3) & B1 & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & ~(B3)) | (~(A1) & ~(A2) & B1 & ~(B2) & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA33_1P5

//%BEGIN SEH_OA33_2

`celldefine
module SEH_OA33_2 (X, A1, A2, A3, B1, B2, B3);
   output X;
   input A1, A2, A3, B1, B2, B3;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or  (int_res_0, A1, A2, A3);
   or  (int_res_1, B1, B2, B3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & B2 & ~(B3)) | (~(A2) & ~(A3) & B1 & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & ~(B3)) | (~(A1) & ~(A3) & B1 & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & ~(B3)) | (~(A1) & ~(A2) & B1 & ~(B2) & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA33_2

//%BEGIN SEH_OA33_3

`celldefine
module SEH_OA33_3 (X, A1, A2, A3, B1, B2, B3);
   output X;
   input A1, A2, A3, B1, B2, B3;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or  (int_res_0, A1, A2, A3);
   or  (int_res_1, B1, B2, B3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & B2 & ~(B3)) | (~(A2) & ~(A3) & B1 & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & ~(B3)) | (~(A1) & ~(A3) & B1 & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & ~(B3)) | (~(A1) & ~(A2) & B1 & ~(B2) & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA33_3

//%BEGIN SEH_OA33_4

`celldefine
module SEH_OA33_4 (X, A1, A2, A3, B1, B2, B3);
   output X;
   input A1, A2, A3, B1, B2, B3;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or  (int_res_0, A1, A2, A3);
   or  (int_res_1, B1, B2, B3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, int_res_1);
   `else
        and (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & B2 & ~(B3)) | (~(A2) & ~(A3) & B1 & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & B3))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2 & ~(B3)) | (~(A1) & ~(A3) & B1 & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2) & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2 & ~(B3)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & ~(B2) & B3))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2 & ~(B3)) | (~(A1) & ~(A2) & B1 & ~(B2) & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2) & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & B3))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2 & ~(B3)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & ~(B2) & B3))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2) & ~(B3)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B3)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B3)))
         (B2 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1) & ~(B2)))
         (B3 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1) & ~(B2)))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA33_4

//%BEGIN SEH_OA41_1

`celldefine
module SEH_OA41_1 (X, A1, A2, A3, A4, B);
   output X;
   input A1, A2, A3, A4, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3, A4);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      if ((A1 & A2 & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & A3 & ~(A4)) | (A1 & A2 & ~(A3) & A4) | (A1 & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(A4)) | (A1 & ~(A2) & A3 & ~(A4)) | (A1 & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & ~(A4)) | (~(A1) & A2 & ~(A3) & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA41_1

//%BEGIN SEH_OA41_2

`celldefine
module SEH_OA41_2 (X, A1, A2, A3, A4, B);
   output X;
   input A1, A2, A3, A4, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3, A4);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      if ((A1 & A2 & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & A3 & ~(A4)) | (A1 & A2 & ~(A3) & A4) | (A1 & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(A4)) | (A1 & ~(A2) & A3 & ~(A4)) | (A1 & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & ~(A4)) | (~(A1) & A2 & ~(A3) & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA41_2

//%BEGIN SEH_OA41_4

`celldefine
module SEH_OA41_4 (X, A1, A2, A3, A4, B);
   output X;
   input A1, A2, A3, A4, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3, A4);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        and #1 (X, int_res_0, B);
   `else
        and (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      if ((A1 & A2 & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & A3 & ~(A4)) | (A1 & A2 & ~(A3) & A4) | (A1 & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(A4)) | (A1 & ~(A2) & A3 & ~(A4)) | (A1 & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & ~(A4)) | (~(A1) & A2 & ~(A3) & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OA41_4

//%BEGIN SEH_OAI2111_0P5

`celldefine
module SEH_OAI2111_0P5 (X, A1, A2, B1, B2, B3);
   output X;
   input A1, A2, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B1, B2, B3);
   `else
        nand (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & A2 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & B1 & B2))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI2111_0P5

//%BEGIN SEH_OAI2111_1

`celldefine
module SEH_OAI2111_1 (X, A1, A2, B1, B2, B3);
   output X;
   input A1, A2, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B1, B2, B3);
   `else
        nand (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & A2 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & B1 & B2))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI2111_1

//%BEGIN SEH_OAI2111_2

`celldefine
module SEH_OAI2111_2 (X, A1, A2, B1, B2, B3);
   output X;
   input A1, A2, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B1, B2, B3);
   `else
        nand (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & A2 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & B1 & B2))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI2111_2

//%BEGIN SEH_OAI2111_4

`celldefine
module SEH_OAI2111_4 (X, A1, A2, B1, B2, B3);
   output X;
   input A1, A2, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B1, B2, B3);
   `else
        nand (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2 & B3))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2 & B3))
         (B1 => X) = 0;
      if ((A1 & A2 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1 & B3))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1 & B3))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2))
         (B3 => X) = 0;
      if ((A1 & ~(A2) & B1 & B2))
         (B3 => X) = 0;
      if ((~(A1) & A2 & B1 & B2))
         (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI2111_4

//%BEGIN SEH_OAI211_0P5

`celldefine
module SEH_OAI211_0P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B1, B2);
   `else
        nand (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI211_0P5

//%BEGIN SEH_OAI211_1

`celldefine
module SEH_OAI211_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B1, B2);
   `else
        nand (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI211_1

//%BEGIN SEH_OAI211_2

`celldefine
module SEH_OAI211_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B1, B2);
   `else
        nand (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI211_2

//%BEGIN SEH_OAI211_3

`celldefine
module SEH_OAI211_3 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B1, B2);
   `else
        nand (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI211_3

//%BEGIN SEH_OAI211_4

`celldefine
module SEH_OAI211_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B1, B2);
   `else
        nand (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI211_4

//%BEGIN SEH_OAI211_8

`celldefine
module SEH_OAI211_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B1, B2);
   `else
        nand (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI211_8

//%BEGIN SEH_OAI21B_0P5

`celldefine
module SEH_OAI21B_0P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, int_res_1);
   `else
        nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21B_0P5

//%BEGIN SEH_OAI21B_1

`celldefine
module SEH_OAI21B_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, int_res_1);
   `else
        nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21B_1

//%BEGIN SEH_OAI21B_2

`celldefine
module SEH_OAI21B_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, int_res_1);
   `else
        nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21B_2

//%BEGIN SEH_OAI21B_3

`celldefine
module SEH_OAI21B_3 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, int_res_1);
   `else
        nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21B_3

//%BEGIN SEH_OAI21B_4

`celldefine
module SEH_OAI21B_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, int_res_1);
   `else
        nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21B_4

//%BEGIN SEH_OAI21B_6

`celldefine
module SEH_OAI21B_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, int_res_1);
   `else
        nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21B_6

//%BEGIN SEH_OAI21B_8

`celldefine
module SEH_OAI21B_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   not (int_res_1, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, int_res_1);
   `else
        nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21B_8

//%BEGIN SEH_OAI21_0P5

`celldefine
module SEH_OAI21_0P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_0P5

//%BEGIN SEH_OAI21_0P75

`celldefine
module SEH_OAI21_0P75 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_0P75

//%BEGIN SEH_OAI21_1

`celldefine
module SEH_OAI21_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_1

//%BEGIN SEH_OAI21_12

`celldefine
module SEH_OAI21_12 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_12

//%BEGIN SEH_OAI21_16

`celldefine
module SEH_OAI21_16 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_16

//%BEGIN SEH_OAI21_2

`celldefine
module SEH_OAI21_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_2

//%BEGIN SEH_OAI21_3

`celldefine
module SEH_OAI21_3 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_3

//%BEGIN SEH_OAI21_4

`celldefine
module SEH_OAI21_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_4

//%BEGIN SEH_OAI21_5

`celldefine
module SEH_OAI21_5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_5

//%BEGIN SEH_OAI21_6

`celldefine
module SEH_OAI21_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_6

//%BEGIN SEH_OAI21_8

`celldefine
module SEH_OAI21_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_8

//%BEGIN SEH_OAI21_G_0P5

`celldefine
module SEH_OAI21_G_0P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_G_0P5

//%BEGIN SEH_OAI21_G_1

`celldefine
module SEH_OAI21_G_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_G_1

//%BEGIN SEH_OAI21_G_12

`celldefine
module SEH_OAI21_G_12 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_G_12

//%BEGIN SEH_OAI21_G_16

`celldefine
module SEH_OAI21_G_16 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_G_16

//%BEGIN SEH_OAI21_G_2

`celldefine
module SEH_OAI21_G_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_G_2

//%BEGIN SEH_OAI21_G_4

`celldefine
module SEH_OAI21_G_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_G_4

//%BEGIN SEH_OAI21_G_6

`celldefine
module SEH_OAI21_G_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_G_6

//%BEGIN SEH_OAI21_G_8

`celldefine
module SEH_OAI21_G_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_G_8

//%BEGIN SEH_OAI21_S_0P5

`celldefine
module SEH_OAI21_S_0P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_S_0P5

//%BEGIN SEH_OAI21_S_1

`celldefine
module SEH_OAI21_S_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_S_1

//%BEGIN SEH_OAI21_S_1P5

`celldefine
module SEH_OAI21_S_1P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_S_1P5

//%BEGIN SEH_OAI21_S_2

`celldefine
module SEH_OAI21_S_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_S_2

//%BEGIN SEH_OAI21_S_3

`celldefine
module SEH_OAI21_S_3 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_S_3

//%BEGIN SEH_OAI21_S_4

`celldefine
module SEH_OAI21_S_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_S_4

//%BEGIN SEH_OAI21_S_6

`celldefine
module SEH_OAI21_S_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_S_6

//%BEGIN SEH_OAI21_S_8

`celldefine
module SEH_OAI21_S_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_S_8

//%BEGIN SEH_OAI21_T_0P5

`celldefine
module SEH_OAI21_T_0P5 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_T_0P5

//%BEGIN SEH_OAI21_T_1

`celldefine
module SEH_OAI21_T_1 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_T_1

//%BEGIN SEH_OAI21_T_12

`celldefine
module SEH_OAI21_T_12 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_T_12

//%BEGIN SEH_OAI21_T_2

`celldefine
module SEH_OAI21_T_2 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_T_2

//%BEGIN SEH_OAI21_T_3

`celldefine
module SEH_OAI21_T_3 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_T_3

//%BEGIN SEH_OAI21_T_4

`celldefine
module SEH_OAI21_T_4 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_T_4

//%BEGIN SEH_OAI21_T_6

`celldefine
module SEH_OAI21_T_6 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_T_6

//%BEGIN SEH_OAI21_T_8

`celldefine
module SEH_OAI21_T_8 (X, A1, A2, B);
   output X;
   input A1, A2, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
        nand #1 (X, int_res_0, B);
   `else
        nand (X, int_res_0, B); 
   `endif
 
   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2))
         (B => X) = 0;
      if ((A1 & ~(A2)))
         (B => X) = 0;
      if ((~(A1) & A2))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI21_T_8

//%BEGIN SEH_OAI221_0P5

`celldefine
module SEH_OAI221_0P5 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1, C);
   `else
      nand (X, int_res_0, int_res_1, C);
   `endif
   
   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2))
         (C => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)) | (A1 & ~(A2) & B1 & B2))
         (C => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI221_0P5

//%BEGIN SEH_OAI221_1

`celldefine
module SEH_OAI221_1 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1, C);
   `else
      nand (X, int_res_0, int_res_1, C);
   `endif
   
   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2))
         (C => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)) | (A1 & ~(A2) & B1 & B2))
         (C => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI221_1

//%BEGIN SEH_OAI221_2

`celldefine
module SEH_OAI221_2 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1, C);
   `else
      nand (X, int_res_0, int_res_1, C);
   `endif
   
   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2))
         (C => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)) | (A1 & ~(A2) & B1 & B2))
         (C => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI221_2

//%BEGIN SEH_OAI221_4

`celldefine
module SEH_OAI221_4 (X, A1, A2, B1, B2, C);
   output X;
   input A1, A2, B1, B2, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1, C);
   `else
      nand (X, int_res_0, int_res_1, C);
   `endif
   
   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2))
         (C => X) = 0;
      if ((A1 & A2 & B1 & ~(B2)) | (A1 & ~(A2) & B1 & B2))
         (C => X) = 0;
      if ((A1 & A2 & ~(B1) & B2))
         (C => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2)))
         (C => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & B2))
         (C => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI221_4

//%BEGIN SEH_OAI222_0P5

`celldefine
module SEH_OAI222_0P5 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);
   or (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      nand (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C2)) | (A1 & ~(A2) & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C1)) | (A1 & ~(A2) & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI222_0P5

//%BEGIN SEH_OAI222_0P75

`celldefine
module SEH_OAI222_0P75 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);
   or (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      nand (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C2)) | (A1 & ~(A2) & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C1)) | (A1 & ~(A2) & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI222_0P75

//%BEGIN SEH_OAI222_1

`celldefine
module SEH_OAI222_1 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);
   or (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      nand (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C2)) | (A1 & ~(A2) & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C1)) | (A1 & ~(A2) & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI222_1

//%BEGIN SEH_OAI222_2

`celldefine
module SEH_OAI222_2 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);
   or (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      nand (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C2)) | (A1 & ~(A2) & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C1)) | (A1 & ~(A2) & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI222_2

//%BEGIN SEH_OAI222_3

`celldefine
module SEH_OAI222_3 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);
   or (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      nand (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C2)) | (A1 & ~(A2) & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C1)) | (A1 & ~(A2) & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI222_3

//%BEGIN SEH_OAI222_4

`celldefine
module SEH_OAI222_4 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);
   or (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      nand (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C2)) | (A1 & ~(A2) & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C1)) | (A1 & ~(A2) & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI222_4

//%BEGIN SEH_OAI222_8

`celldefine
module SEH_OAI222_8 (X, A1, A2, B1, B2, C1, C2);
   output X;
   input A1, A2, B1, B2, C1, C2;

   wire int_res_0, int_res_1, int_res_2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);
   or (int_res_2, C1, C2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1, int_res_2);
   `else
      nand (X, int_res_0, int_res_1, int_res_2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2) & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & C2))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & C1 & ~(C2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2 & ~(C1) & C2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2) & ~(C1) & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & C2))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & C1 & ~(C2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2 & ~(C1) & C2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & C2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & C1 & ~(C2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2) & ~(C1) & C2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & C2))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & C1 & ~(C2)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & ~(C1) & C2))
         (B2 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C2)) | (A1 & ~(A2) & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C2)))
         (C1 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C2)))
         (C1 => X) = 0;
      if ((A1 & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & B1 & ~(B2) & ~(C1)) | (A1 & ~(A2) & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & B2 & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & B1 & ~(B2) & ~(C1)))
         (C2 => X) = 0;
      if ((~(A1) & A2 & ~(B1) & B2 & ~(C1)))
         (C2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI222_8

//%BEGIN SEH_OAI22_0P5

`celldefine
module SEH_OAI22_0P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_0P5

//%BEGIN SEH_OAI22_0P75

`celldefine
module SEH_OAI22_0P75 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_0P75

//%BEGIN SEH_OAI22_1

`celldefine
module SEH_OAI22_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_1

//%BEGIN SEH_OAI22_12

`celldefine
module SEH_OAI22_12 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_12

//%BEGIN SEH_OAI22_2

`celldefine
module SEH_OAI22_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_2

//%BEGIN SEH_OAI22_3

`celldefine
module SEH_OAI22_3 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_3

//%BEGIN SEH_OAI22_4

`celldefine
module SEH_OAI22_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_4

//%BEGIN SEH_OAI22_6

`celldefine
module SEH_OAI22_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_6

//%BEGIN SEH_OAI22_8

`celldefine
module SEH_OAI22_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_8

//%BEGIN SEH_OAI22_S_0P5

`celldefine
module SEH_OAI22_S_0P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_S_0P5

//%BEGIN SEH_OAI22_S_1

`celldefine
module SEH_OAI22_S_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_S_1

//%BEGIN SEH_OAI22_S_2

`celldefine
module SEH_OAI22_S_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_S_2

//%BEGIN SEH_OAI22_S_4

`celldefine
module SEH_OAI22_S_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_S_4

//%BEGIN SEH_OAI22_S_6

`celldefine
module SEH_OAI22_S_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_S_6

//%BEGIN SEH_OAI22_S_8

`celldefine
module SEH_OAI22_S_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_S_8

//%BEGIN SEH_OAI22_T_0P5

`celldefine
module SEH_OAI22_T_0P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_T_0P5

//%BEGIN SEH_OAI22_T_1

`celldefine
module SEH_OAI22_T_1 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_T_1

//%BEGIN SEH_OAI22_T_12

`celldefine
module SEH_OAI22_T_12 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_T_12

//%BEGIN SEH_OAI22_T_16

`celldefine
module SEH_OAI22_T_16 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_T_16

//%BEGIN SEH_OAI22_T_1P5

`celldefine
module SEH_OAI22_T_1P5 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_T_1P5

//%BEGIN SEH_OAI22_T_2

`celldefine
module SEH_OAI22_T_2 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_T_2

//%BEGIN SEH_OAI22_T_3

`celldefine
module SEH_OAI22_T_3 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_T_3

//%BEGIN SEH_OAI22_T_4

`celldefine
module SEH_OAI22_T_4 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_T_4

//%BEGIN SEH_OAI22_T_6

`celldefine
module SEH_OAI22_T_6 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_T_6

//%BEGIN SEH_OAI22_T_8

`celldefine
module SEH_OAI22_T_8 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_T_8

//%BEGIN SEH_OAI22_Y2_16

`celldefine
module SEH_OAI22_Y2_16 (X, A1, A2, B1, B2);
   output X;
   input A1, A2, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
         nand #1 (X, int_res_0, int_res_1);
   `else
         nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((A1 & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(B1)))
         (B2 => X) = 0;
   endspecify

  `endif

endmodule
`endcelldefine

//%END SEH_OAI22_Y2_16

//%BEGIN SEH_OAI311_1

`celldefine
module SEH_OAI311_1 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, int_res_0, B1, B2);
   `else
       nand (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2) | (A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1) | (A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI311_1

//%BEGIN SEH_OAI311_2

`celldefine
module SEH_OAI311_2 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, int_res_0, B1, B2);
   `else
       nand (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2) | (A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1) | (A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI311_2

//%BEGIN SEH_OAI311_4

`celldefine
module SEH_OAI311_4 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       nand #1 (X, int_res_0, B1, B2);
   `else
       nand (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & B2) | (A1 & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & B2))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B2))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B2))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & B1) | (A1 & ~(A2) & A3 & B1))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & B1))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & B1))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & B1))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI311_4

//%BEGIN SEH_OAI31_0P5

`celldefine
module SEH_OAI31_0P5 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_0P5

//%BEGIN SEH_OAI31_0P75

`celldefine
module SEH_OAI31_0P75 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_0P75

//%BEGIN SEH_OAI31_1

`celldefine
module SEH_OAI31_1 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_1

//%BEGIN SEH_OAI31_12

`celldefine
module SEH_OAI31_12 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_12

//%BEGIN SEH_OAI31_2

`celldefine
module SEH_OAI31_2 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_2

//%BEGIN SEH_OAI31_3

`celldefine
module SEH_OAI31_3 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_3

//%BEGIN SEH_OAI31_4

`celldefine
module SEH_OAI31_4 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_4

//%BEGIN SEH_OAI31_6

`celldefine
module SEH_OAI31_6 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_6

//%BEGIN SEH_OAI31_8

`celldefine
module SEH_OAI31_8 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_8

//%BEGIN SEH_OAI31_G_0P5

`celldefine
module SEH_OAI31_G_0P5 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_G_0P5

//%BEGIN SEH_OAI31_G_0P75

`celldefine
module SEH_OAI31_G_0P75 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_G_0P75

//%BEGIN SEH_OAI31_G_1

`celldefine
module SEH_OAI31_G_1 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_G_1

//%BEGIN SEH_OAI31_G_2

`celldefine
module SEH_OAI31_G_2 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_G_2

//%BEGIN SEH_OAI31_G_4

`celldefine
module SEH_OAI31_G_4 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_G_4

//%BEGIN SEH_OAI31_T_0P5

`celldefine
module SEH_OAI31_T_0P5 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_T_0P5

//%BEGIN SEH_OAI31_T_1

`celldefine
module SEH_OAI31_T_1 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_T_1

//%BEGIN SEH_OAI31_T_2

`celldefine
module SEH_OAI31_T_2 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_T_2

//%BEGIN SEH_OAI31_T_4

`celldefine
module SEH_OAI31_T_4 (X, A1, A2, A3, B);
   output X;
   input A1, A2, A3, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      if ((A1 & A2 & A3))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3)) | (A1 & ~(A2) & A3))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI31_T_4

//%BEGIN SEH_OAI32_1

`celldefine
module SEH_OAI32_1 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1);
   `else
      nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1)) | (A1 & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI32_1

//%BEGIN SEH_OAI32_2

`celldefine
module SEH_OAI32_2 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1);
   `else
      nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1)) | (A1 & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI32_2

//%BEGIN SEH_OAI32_4

`celldefine
module SEH_OAI32_4 (X, A1, A2, A3, B1, B2);
   output X;
   input A1, A2, A3, B1, B2;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3);
   or (int_res_1, B1, B2);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, int_res_1);
   `else
      nand (X, int_res_0, int_res_1);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((~(A2) & ~(A3) & B1 & B2))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & B1 & ~(B2)))
         (A1 => X) = 0;
      if ((~(A2) & ~(A3) & ~(B1) & B2))
         (A1 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & B1 & ~(B2)))
         (A2 => X) = 0;
      if ((~(A1) & ~(A3) & ~(B1) & B2))
         (A2 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & B2))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & B1 & ~(B2)))
         (A3 => X) = 0;
      if ((~(A1) & ~(A2) & ~(B1) & B2))
         (A3 => X) = 0;
      if ((A1 & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B2)) | (A1 & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B2)))
         (B1 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B2)))
         (B1 => X) = 0;
      if ((A1 & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(B1)) | (A1 & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & A3 & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(B1)))
         (B2 => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(B1)))
         (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI32_4

//%BEGIN SEH_OAI41_1

`celldefine
module SEH_OAI41_1 (X, A1, A2, A3, A4, B);
   output X;
   input A1, A2, A3, A4, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3, A4);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      if ((A1 & A2 & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & A3 & ~(A4)) | (A1 & A2 & ~(A3) & A4) | (A1 & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(A4)) | (A1 & ~(A2) & A3 & ~(A4)) | (A1 & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & ~(A4)) | (~(A1) & A2 & ~(A3) & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI41_1

//%BEGIN SEH_OAI41_2

`celldefine
module SEH_OAI41_2 (X, A1, A2, A3, A4, B);
   output X;
   input A1, A2, A3, A4, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3, A4);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      if ((A1 & A2 & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & A3 & ~(A4)) | (A1 & A2 & ~(A3) & A4) | (A1 & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(A4)) | (A1 & ~(A2) & A3 & ~(A4)) | (A1 & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & ~(A4)) | (~(A1) & A2 & ~(A3) & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI41_2

//%BEGIN SEH_OAI41_4

`celldefine
module SEH_OAI41_4 (X, A1, A2, A3, A4, B);
   output X;
   input A1, A2, A3, A4, B;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2, A3, A4);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nand #1 (X, int_res_0, B);
   `else
      nand (X, int_res_0, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      if ((A1 & A2 & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & A3 & ~(A4)) | (A1 & A2 & ~(A3) & A4) | (A1 & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((A1 & A2 & ~(A3) & ~(A4)) | (A1 & ~(A2) & A3 & ~(A4)) | (A1 & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & A3 & ~(A4)) | (~(A1) & A2 & ~(A3) & A4))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(A3) & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & A4))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & A3 & ~(A4)))
         (B => X) = 0;
      if ((~(A1) & ~(A2) & ~(A3) & A4))
         (B => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAI41_4

//%BEGIN SEH_OAO211_DG_1

`celldefine
module SEH_OAO211_DG_1 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_1, C);
   `else
      or (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAO211_DG_1

//%BEGIN SEH_OAO211_DG_2

`celldefine
module SEH_OAO211_DG_2 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_1, C);
   `else
      or (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAO211_DG_2

//%BEGIN SEH_OAO211_DG_4

`celldefine
module SEH_OAO211_DG_4 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_1, C);
   `else
      or (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAO211_DG_4

//%BEGIN SEH_OAOI211_0P5

`celldefine
module SEH_OAOI211_0P5 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_0P5

//%BEGIN SEH_OAOI211_1

`celldefine
module SEH_OAOI211_1 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_1

//%BEGIN SEH_OAOI211_12

`celldefine
module SEH_OAOI211_12 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_12

//%BEGIN SEH_OAOI211_2

`celldefine
module SEH_OAOI211_2 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_2

//%BEGIN SEH_OAOI211_3

`celldefine
module SEH_OAOI211_3 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_3

//%BEGIN SEH_OAOI211_4

`celldefine
module SEH_OAOI211_4 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_4

//%BEGIN SEH_OAOI211_8

`celldefine
module SEH_OAOI211_8 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_8

//%BEGIN SEH_OAOI211_G_1

`celldefine
module SEH_OAOI211_G_1 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_G_1

//%BEGIN SEH_OAOI211_G_12

`celldefine
module SEH_OAOI211_G_12 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_G_12

//%BEGIN SEH_OAOI211_G_2

`celldefine
module SEH_OAOI211_G_2 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_G_2

//%BEGIN SEH_OAOI211_G_4

`celldefine
module SEH_OAOI211_G_4 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_G_4

//%BEGIN SEH_OAOI211_G_6

`celldefine
module SEH_OAOI211_G_6 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_G_6

//%BEGIN SEH_OAOI211_G_8

`celldefine
module SEH_OAOI211_G_8 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_G_8

//%BEGIN SEH_OAOI211_V2_1

`celldefine
module SEH_OAOI211_V2_1 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_V2_1

//%BEGIN SEH_OAOI211_V2_2

`celldefine
module SEH_OAOI211_V2_2 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_V2_2

//%BEGIN SEH_OAOI211_V2_4

`celldefine
module SEH_OAOI211_V2_4 (X, A1, A2, B, C);
   output X;
   input A1, A2, B, C;

   wire int_res_0, int_res_1;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   or (int_res_0, A1, A2);
   and (int_res_1, int_res_0, B);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      nor #1 (X, int_res_1, C);
   `else
      nor (X, int_res_1, C);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      if ((A1 & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(A2) & ~(C)))
         (B => X) = 0;
      if ((~(A1) & A2 & ~(C)))
         (B => X) = 0;
      if ((A1 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & A2 & ~(B)))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & B))
         (C => X) = 0;
      if ((~(A1) & ~(A2) & ~(B)))
         (C => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OAOI211_V2_4

//%BEGIN SEH_OR2_0P65

`celldefine
module SEH_OR2_0P65 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_0P65

//%BEGIN SEH_OR2_1

`celldefine
module SEH_OR2_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_1

//%BEGIN SEH_OR2_10

`celldefine
module SEH_OR2_10 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_10

//%BEGIN SEH_OR2_12

`celldefine
module SEH_OR2_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_12

//%BEGIN SEH_OR2_16

`celldefine
module SEH_OR2_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_16

//%BEGIN SEH_OR2_1P5

`celldefine
module SEH_OR2_1P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_1P5

//%BEGIN SEH_OR2_2

`celldefine
module SEH_OR2_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_2

//%BEGIN SEH_OR2_20

`celldefine
module SEH_OR2_20 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_20

//%BEGIN SEH_OR2_2P5

`celldefine
module SEH_OR2_2P5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_2P5

//%BEGIN SEH_OR2_3

`celldefine
module SEH_OR2_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_3

//%BEGIN SEH_OR2_4

`celldefine
module SEH_OR2_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_4

//%BEGIN SEH_OR2_5

`celldefine
module SEH_OR2_5 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_5

//%BEGIN SEH_OR2_6

`celldefine
module SEH_OR2_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_6

//%BEGIN SEH_OR2_8

`celldefine
module SEH_OR2_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_8

//%BEGIN SEH_OR2_DG_1

`celldefine
module SEH_OR2_DG_1 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_DG_1

//%BEGIN SEH_OR2_DG_12

`celldefine
module SEH_OR2_DG_12 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_DG_12

//%BEGIN SEH_OR2_DG_16

`celldefine
module SEH_OR2_DG_16 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_DG_16

//%BEGIN SEH_OR2_DG_2

`celldefine
module SEH_OR2_DG_2 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_DG_2

//%BEGIN SEH_OR2_DG_24

`celldefine
module SEH_OR2_DG_24 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_DG_24

//%BEGIN SEH_OR2_DG_3

`celldefine
module SEH_OR2_DG_3 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_DG_3

//%BEGIN SEH_OR2_DG_4

`celldefine
module SEH_OR2_DG_4 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_DG_4

//%BEGIN SEH_OR2_DG_6

`celldefine
module SEH_OR2_DG_6 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_DG_6

//%BEGIN SEH_OR2_DG_8

`celldefine
module SEH_OR2_DG_8 (X, A1, A2);
   output X;
   input A1, A2;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
       or #1 (X, A1, A2);
   `else
       or (X, A1, A2);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR2_DG_8

//%BEGIN SEH_OR3B_0P5

`celldefine
module SEH_OR3B_0P5 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B1, B2);
   `else
      or (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3B_0P5

//%BEGIN SEH_OR3B_1

`celldefine
module SEH_OR3B_1 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B1, B2);
   `else
      or (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3B_1

//%BEGIN SEH_OR3B_2

`celldefine
module SEH_OR3B_2 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B1, B2);
   `else
      or (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3B_2

//%BEGIN SEH_OR3B_4

`celldefine
module SEH_OR3B_4 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B1, B2);
   `else
      or (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3B_4

//%BEGIN SEH_OR3B_8

`celldefine
module SEH_OR3B_8 (X, A, B1, B2);
   output X;
   input A, B1, B2;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, int_res_0, B1, B2);
   `else
      or (X, int_res_0, B1, B2);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3B_8

//%BEGIN SEH_OR3_0P65

`celldefine
module SEH_OR3_0P65 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3);
   `else
      or (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3_0P65

//%BEGIN SEH_OR3_1

`celldefine
module SEH_OR3_1 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3);
   `else
      or (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3_1

//%BEGIN SEH_OR3_12

`celldefine
module SEH_OR3_12 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3);
   `else
      or (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3_12

//%BEGIN SEH_OR3_16

`celldefine
module SEH_OR3_16 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3);
   `else
      or (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3_16

//%BEGIN SEH_OR3_2

`celldefine
module SEH_OR3_2 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3);
   `else
      or (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3_2

//%BEGIN SEH_OR3_3

`celldefine
module SEH_OR3_3 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3);
   `else
      or (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3_3

//%BEGIN SEH_OR3_4

`celldefine
module SEH_OR3_4 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3);
   `else
      or (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3_4

//%BEGIN SEH_OR3_6

`celldefine
module SEH_OR3_6 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3);
   `else
      or (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3_6

//%BEGIN SEH_OR3_8

`celldefine
module SEH_OR3_8 (X, A1, A2, A3);
   output X;
   input A1, A2, A3;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3);
   `else
      or (X, A1, A2, A3);
   `endif

   `ifdef VIRL_functiononly

   `else

   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR3_8

//%BEGIN SEH_OR4B_1

`celldefine
module SEH_OR4B_1 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1 (X, int_res_0, B1, B2, B3);
   `else
       or (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4B_1

//%BEGIN SEH_OR4B_2

`celldefine
module SEH_OR4B_2 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1 (X, int_res_0, B1, B2, B3);
   `else
       or (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4B_2

//%BEGIN SEH_OR4B_3

`celldefine
module SEH_OR4B_3 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1 (X, int_res_0, B1, B2, B3);
   `else
       or (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4B_3

//%BEGIN SEH_OR4B_4

`celldefine
module SEH_OR4B_4 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1 (X, int_res_0, B1, B2, B3);
   `else
       or (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4B_4

//%BEGIN SEH_OR4B_8

`celldefine
module SEH_OR4B_8 (X, A, B1, B2, B3);
   output X;
   input A, B1, B2, B3;

   wire int_res_0;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   not (int_res_0, A);

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1 (X, int_res_0, B1, B2, B3);
   `else
       or (X, int_res_0, B1, B2, B3);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A => X) = 0;
      (B1 => X) = 0;
      (B2 => X) = 0;
      (B3 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4B_8

//%BEGIN SEH_OR4_0P65

`celldefine
module SEH_OR4_0P65 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3, A4);
   `else
      or (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4_0P65

//%BEGIN SEH_OR4_1

`celldefine
module SEH_OR4_1 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3, A4);
   `else
      or (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4_1

//%BEGIN SEH_OR4_12

`celldefine
module SEH_OR4_12 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3, A4);
   `else
      or (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4_12

//%BEGIN SEH_OR4_2

`celldefine
module SEH_OR4_2 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3, A4);
   `else
      or (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4_2

//%BEGIN SEH_OR4_4

`celldefine
module SEH_OR4_4 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3, A4);
   `else
      or (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4_4

//%BEGIN SEH_OR4_6

`celldefine
module SEH_OR4_6 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3, A4);
   `else
      or (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4_6

//%BEGIN SEH_OR4_8

`celldefine
module SEH_OR4_8 (X, A1, A2, A3, A4);
   output X;
   input A1, A2, A3, A4;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////
   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3, A4);
   `else
      or (X, A1, A2, A3, A4);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR4_8

//%BEGIN SEH_OR5_1

`celldefine
module SEH_OR5_1 (X, A1, A2, A3, A4, A5);
   output X;
   input A1, A2, A3, A4, A5;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3, A4, A5);
   `else
      or (X, A1, A2, A3, A4, A5);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
   endspecify


    `endif

endmodule
`endcelldefine

//%END SEH_OR5_1

//%BEGIN SEH_OR5_2

`celldefine
module SEH_OR5_2 (X, A1, A2, A3, A4, A5);
   output X;
   input A1, A2, A3, A4, A5;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3, A4, A5);
   `else
      or (X, A1, A2, A3, A4, A5);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
   endspecify


    `endif

endmodule
`endcelldefine

//%END SEH_OR5_2

//%BEGIN SEH_OR5_4

`celldefine
module SEH_OR5_4 (X, A1, A2, A3, A4, A5);
   output X;
   input A1, A2, A3, A4, A5;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3, A4, A5);
   `else
      or (X, A1, A2, A3, A4, A5);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
   endspecify


    `endif

endmodule
`endcelldefine

//%END SEH_OR5_4

//%BEGIN SEH_OR5_Y2_8

`celldefine
module SEH_OR5_Y2_8 (X, A1, A2, A3, A4, A5);
   output X;
   input A1, A2, A3, A4, A5;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      or #1 (X, A1, A2, A3, A4, A5);
   `else
      or (X, A1, A2, A3, A4, A5);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
   endspecify


    `endif

endmodule
`endcelldefine

//%END SEH_OR5_Y2_8

//%BEGIN SEH_OR6_1

`celldefine
module SEH_OR6_1 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1(X, A1, A2, A3, A4, A5, A6);
   `else
       or (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR6_1

//%BEGIN SEH_OR6_2

`celldefine
module SEH_OR6_2 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1(X, A1, A2, A3, A4, A5, A6);
   `else
       or (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR6_2

//%BEGIN SEH_OR6_4

`celldefine
module SEH_OR6_4 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1(X, A1, A2, A3, A4, A5, A6);
   `else
       or (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR6_4

//%BEGIN SEH_OR6_Y2_12

`celldefine
module SEH_OR6_Y2_12 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1(X, A1, A2, A3, A4, A5, A6);
   `else
       or (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR6_Y2_12

//%BEGIN SEH_OR6_Y2_16

`celldefine
module SEH_OR6_Y2_16 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1(X, A1, A2, A3, A4, A5, A6);
   `else
       or (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR6_Y2_16

//%BEGIN SEH_OR6_Y2_20

`celldefine
module SEH_OR6_Y2_20 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1(X, A1, A2, A3, A4, A5, A6);
   `else
       or (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR6_Y2_20

//%BEGIN SEH_OR6_Y2_24

`celldefine
module SEH_OR6_Y2_24 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1(X, A1, A2, A3, A4, A5, A6);
   `else
       or (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR6_Y2_24

//%BEGIN SEH_OR6_Y2_32

`celldefine
module SEH_OR6_Y2_32 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1(X, A1, A2, A3, A4, A5, A6);
   `else
       or (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR6_Y2_32

//%BEGIN SEH_OR6_Y2_6

`celldefine
module SEH_OR6_Y2_6 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1(X, A1, A2, A3, A4, A5, A6);
   `else
       or (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR6_Y2_6

//%BEGIN SEH_OR6_Y2_8

`celldefine
module SEH_OR6_Y2_8 (X, A1, A2, A3, A4, A5, A6);
   output X;
   input A1, A2, A3, A4, A5, A6;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
       or #1(X, A1, A2, A3, A4, A5, A6);
   `else
       or (X, A1, A2, A3, A4, A5, A6);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      (A1 => X) = 0;
      (A2 => X) = 0;
      (A3 => X) = 0;
      (A4 => X) = 0;
      (A5 => X) = 0;
      (A6 => X) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_OR6_Y2_8

//%BEGIN SEH_RAD8BOOTHMUX_8

`celldefine
module SEH_RAD8BOOTHMUX_8 (Z, A0, A1, B0, B1, C0, C1, D0, D1, S);
   output Z;
   input A0, A1, B0, B1, C0, C1, D0, D1, S;
   wire int_res_0, int_res_1, int_res_2, int_res_3, int_res_4;
   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   and (int_res_0, A1, A0);
   and (int_res_1, B1, B0);
   and (int_res_2, C1, C0);
   and (int_res_3, D1, D0);
   or ( int_res_4, int_res_0, int_res_1, int_res_2, int_res_3);


   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
     xor #1 ( Z, int_res_4, S);
   `else
     xor ( Z, int_res_4, S);
   `endif

   `ifdef VIRL_functiononly

   `else


   specify
      if ((A1 & B0 & ~(B1) & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (A1 & B0 & ~(B1) & C0 & ~(C1) & ~(D0) & ~(S)) | (A1 & B0 & ~(B1) & ~(C0) & D0 & ~(D1) & ~(S)) | (A1 & B0 & ~(B1) & ~(C0) & ~(D0) & ~(S)))
         (A0 => Z) = 0;
      if ((A1 & ~(B0) & B1 & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (A1 & ~(B0) & B1 & C0 & ~(C1) & ~(D0) & ~(S)) | (A1 & ~(B0) & B1 & ~(C0) & D0 & ~(D1) & ~(S)) | (A1 & ~(B0) & B1 & ~(C0) & ~(D0) & ~(S)))
         (A0 => Z) = 0;
      if ((A1 & ~(B0) & ~(B1) & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (A1 & ~(B0) & ~(B1) & C0 & ~(C1) & ~(D0) & ~(S)) | (A1 & ~(B0) & ~(B1) & ~(C0) & D0 & ~(D1) & ~(S)) | (A1 & ~(B0) & ~(B1) & ~(C0) & ~(D0) & ~(S)))
         (A0 => Z) = 0;
      if ((A1 & B0 & ~(B1) & C0 & ~(C1) & D0 & ~(D1) & S) | (A1 & B0 & ~(B1) & C0 & ~(C1) & ~(D0) & S) | (A1 & B0 & ~(B1) & ~(C0) & D0 & ~(D1) & S) | (A1 & B0 & ~(B1) & ~(C0) & ~(D0) & S))
         (A0 => Z) = 0;
      if ((A1 & ~(B0) & B1 & C0 & ~(C1) & D0 & ~(D1) & S) | (A1 & ~(B0) & B1 & C0 & ~(C1) & ~(D0) & S) | (A1 & ~(B0) & B1 & ~(C0) & D0 & ~(D1) & S) | (A1 & ~(B0) & B1 & ~(C0) & ~(D0) & S))
         (A0 => Z) = 0;
      if ((A1 & ~(B0) & ~(B1) & C0 & ~(C1) & D0 & ~(D1) & S) | (A1 & ~(B0) & ~(B1) & C0 & ~(C1) & ~(D0) & S) | (A1 & ~(B0) & ~(B1) & ~(C0) & D0 & ~(D1) & S) | (A1 & ~(B0) & ~(B1) & ~(C0) & ~(D0) & S))
         (A0 => Z) = 0;
      if ((A0 & B0 & ~(B1) & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (A0 & B0 & ~(B1) & C0 & ~(C1) & ~(D0) & ~(S)) | (A0 & B0 & ~(B1) & ~(C0) & D0 & ~(D1) & ~(S)) | (A0 & B0 & ~(B1) & ~(C0) & ~(D0) & ~(S)))
         (A1 => Z) = 0;
      if ((A0 & ~(B0) & B1 & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (A0 & ~(B0) & B1 & C0 & ~(C1) & ~(D0) & ~(S)) | (A0 & ~(B0) & B1 & ~(C0) & D0 & ~(D1) & ~(S)) | (A0 & ~(B0) & B1 & ~(C0) & ~(D0) & ~(S)))
         (A1 => Z) = 0;
      if ((A0 & ~(B0) & ~(B1) & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (A0 & ~(B0) & ~(B1) & C0 & ~(C1) & ~(D0) & ~(S)) | (A0 & ~(B0) & ~(B1) & ~(C0) & D0 & ~(D1) & ~(S)) | (A0 & ~(B0) & ~(B1) & ~(C0) & ~(D0) & ~(S)))
         (A1 => Z) = 0;
      if ((A0 & B0 & ~(B1) & C0 & ~(C1) & D0 & ~(D1) & S) | (A0 & B0 & ~(B1) & C0 & ~(C1) & ~(D0) & S) | (A0 & B0 & ~(B1) & ~(C0) & D0 & ~(D1) & S) | (A0 & B0 & ~(B1) & ~(C0) & ~(D0) & S))
         (A1 => Z) = 0;
      if ((A0 & ~(B0) & B1 & C0 & ~(C1) & D0 & ~(D1) & S) | (A0 & ~(B0) & B1 & C0 & ~(C1) & ~(D0) & S) | (A0 & ~(B0) & B1 & ~(C0) & D0 & ~(D1) & S) | (A0 & ~(B0) & B1 & ~(C0) & ~(D0) & S))
         (A1 => Z) = 0;
      if ((A0 & ~(B0) & ~(B1) & C0 & ~(C1) & D0 & ~(D1) & S) | (A0 & ~(B0) & ~(B1) & C0 & ~(C1) & ~(D0) & S) | (A0 & ~(B0) & ~(B1) & ~(C0) & D0 & ~(D1) & S) | (A0 & ~(B0) & ~(B1) & ~(C0) & ~(D0) & S))
         (A1 => Z) = 0;
      if ((A0 & ~(A1) & B1 & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (A0 & ~(A1) & B1 & C0 & ~(C1) & ~(D0) & ~(S)) | (A0 & ~(A1) & B1 & ~(C0) & D0 & ~(D1) & ~(S)) | (A0 & ~(A1) & B1 & ~(C0) & ~(D0) & ~(S)))
         (B0 => Z) = 0;
      if ((~(A0) & A1 & B1 & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (~(A0) & A1 & B1 & C0 & ~(C1) & ~(D0) & ~(S)) | (~(A0) & A1 & B1 & ~(C0) & D0 & ~(D1) & ~(S)) | (~(A0) & A1 & B1 & ~(C0) & ~(D0) & ~(S)))
         (B0 => Z) = 0;
      if ((~(A0) & ~(A1) & B1 & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (~(A0) & ~(A1) & B1 & C0 & ~(C1) & ~(D0) & ~(S)) | (~(A0) & ~(A1) & B1 & ~(C0) & D0 & ~(D1) & ~(S)) | (~(A0) & ~(A1) & B1 & ~(C0) & ~(D0) & ~(S)))
         (B0 => Z) = 0;
      if ((A0 & ~(A1) & B1 & C0 & ~(C1) & D0 & ~(D1) & S) | (A0 & ~(A1) & B1 & C0 & ~(C1) & ~(D0) & S) | (A0 & ~(A1) & B1 & ~(C0) & D0 & ~(D1) & S) | (A0 & ~(A1) & B1 & ~(C0) & ~(D0) & S))
         (B0 => Z) = 0;
      if ((~(A0) & A1 & B1 & C0 & ~(C1) & D0 & ~(D1) & S) | (~(A0) & A1 & B1 & C0 & ~(C1) & ~(D0) & S) | (~(A0) & A1 & B1 & ~(C0) & D0 & ~(D1) & S) | (~(A0) & A1 & B1 & ~(C0) & ~(D0) & S))
         (B0 => Z) = 0;
      if ((~(A0) & ~(A1) & B1 & C0 & ~(C1) & D0 & ~(D1) & S) | (~(A0) & ~(A1) & B1 & C0 & ~(C1) & ~(D0) & S) | (~(A0) & ~(A1) & B1 & ~(C0) & D0 & ~(D1) & S) | (~(A0) & ~(A1) & B1 & ~(C0) & ~(D0) & S))
         (B0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (A0 & ~(A1) & B0 & C0 & ~(C1) & ~(D0) & ~(S)) | (A0 & ~(A1) & B0 & ~(C0) & D0 & ~(D1) & ~(S)) | (A0 & ~(A1) & B0 & ~(C0) & ~(D0) & ~(S)))
         (B1 => Z) = 0;
      if ((~(A0) & A1 & B0 & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (~(A0) & A1 & B0 & C0 & ~(C1) & ~(D0) & ~(S)) | (~(A0) & A1 & B0 & ~(C0) & D0 & ~(D1) & ~(S)) | (~(A0) & A1 & B0 & ~(C0) & ~(D0) & ~(S)))
         (B1 => Z) = 0;
      if ((~(A0) & ~(A1) & B0 & C0 & ~(C1) & D0 & ~(D1) & ~(S)) | (~(A0) & ~(A1) & B0 & C0 & ~(C1) & ~(D0) & ~(S)) | (~(A0) & ~(A1) & B0 & ~(C0) & D0 & ~(D1) & ~(S)) | (~(A0) & ~(A1) & B0 & ~(C0) & ~(D0) & ~(S)))
         (B1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & C0 & ~(C1) & D0 & ~(D1) & S) | (A0 & ~(A1) & B0 & C0 & ~(C1) & ~(D0) & S) | (A0 & ~(A1) & B0 & ~(C0) & D0 & ~(D1) & S) | (A0 & ~(A1) & B0 & ~(C0) & ~(D0) & S))
         (B1 => Z) = 0;
      if ((~(A0) & A1 & B0 & C0 & ~(C1) & D0 & ~(D1) & S) | (~(A0) & A1 & B0 & C0 & ~(C1) & ~(D0) & S) | (~(A0) & A1 & B0 & ~(C0) & D0 & ~(D1) & S) | (~(A0) & A1 & B0 & ~(C0) & ~(D0) & S))
         (B1 => Z) = 0;
      if ((~(A0) & ~(A1) & B0 & C0 & ~(C1) & D0 & ~(D1) & S) | (~(A0) & ~(A1) & B0 & C0 & ~(C1) & ~(D0) & S) | (~(A0) & ~(A1) & B0 & ~(C0) & D0 & ~(D1) & S) | (~(A0) & ~(A1) & B0 & ~(C0) & ~(D0) & S))
         (B1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C1 & D0 & ~(D1) & ~(S)) | (A0 & ~(A1) & ~(B0) & C1 & D0 & ~(D1) & ~(S)) | (~(A0) & B0 & ~(B1) & C1 & D0 & ~(D1) & ~(S)) | (~(A0) & ~(B0) & C1 & D0 & ~(D1) & ~(S)))
         (C0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C1 & ~(D0) & D1 & ~(S)) | (A0 & ~(A1) & ~(B0) & C1 & ~(D0) & D1 & ~(S)) | (~(A0) & B0 & ~(B1) & C1 & ~(D0) & D1 & ~(S)) | (~(A0) & ~(B0) & C1 & ~(D0) & D1 & ~(S)))
         (C0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C1 & ~(D0) & ~(D1) & ~(S)) | (A0 & ~(A1) & ~(B0) & C1 & ~(D0) & ~(D1) & ~(S)) | (~(A0) & B0 & ~(B1) & C1 & ~(D0) & ~(D1) & ~(S)) | (~(A0) & ~(B0) & C1 & ~(D0) & ~(D1) & ~(S)))
         (C0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C1 & D0 & ~(D1) & S) | (A0 & ~(A1) & ~(B0) & C1 & D0 & ~(D1) & S) | (~(A0) & B0 & ~(B1) & C1 & D0 & ~(D1) & S) | (~(A0) & ~(B0) & C1 & D0 & ~(D1) & S))
         (C0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C1 & ~(D0) & D1 & S) | (A0 & ~(A1) & ~(B0) & C1 & ~(D0) & D1 & S) | (~(A0) & B0 & ~(B1) & C1 & ~(D0) & D1 & S) | (~(A0) & ~(B0) & C1 & ~(D0) & D1 & S))
         (C0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C1 & ~(D0) & ~(D1) & S) | (A0 & ~(A1) & ~(B0) & C1 & ~(D0) & ~(D1) & S) | (~(A0) & B0 & ~(B1) & C1 & ~(D0) & ~(D1) & S) | (~(A0) & ~(B0) & C1 & ~(D0) & ~(D1) & S))
         (C0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C0 & D0 & ~(D1) & ~(S)) | (A0 & ~(A1) & ~(B0) & C0 & D0 & ~(D1) & ~(S)) | (~(A0) & B0 & ~(B1) & C0 & D0 & ~(D1) & ~(S)) | (~(A0) & ~(B0) & C0 & D0 & ~(D1) & ~(S)))
         (C1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C0 & ~(D0) & D1 & ~(S)) | (A0 & ~(A1) & ~(B0) & C0 & ~(D0) & D1 & ~(S)) | (~(A0) & B0 & ~(B1) & C0 & ~(D0) & D1 & ~(S)) | (~(A0) & ~(B0) & C0 & ~(D0) & D1 & ~(S)))
         (C1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C0 & ~(D0) & ~(D1) & ~(S)) | (A0 & ~(A1) & ~(B0) & C0 & ~(D0) & ~(D1) & ~(S)) | (~(A0) & B0 & ~(B1) & C0 & ~(D0) & ~(D1) & ~(S)) | (~(A0) & ~(B0) & C0 & ~(D0) & ~(D1) & ~(S)))
         (C1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C0 & D0 & ~(D1) & S) | (A0 & ~(A1) & ~(B0) & C0 & D0 & ~(D1) & S) | (~(A0) & B0 & ~(B1) & C0 & D0 & ~(D1) & S) | (~(A0) & ~(B0) & C0 & D0 & ~(D1) & S))
         (C1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C0 & ~(D0) & D1 & S) | (A0 & ~(A1) & ~(B0) & C0 & ~(D0) & D1 & S) | (~(A0) & B0 & ~(B1) & C0 & ~(D0) & D1 & S) | (~(A0) & ~(B0) & C0 & ~(D0) & D1 & S))
         (C1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C0 & ~(D0) & ~(D1) & S) | (A0 & ~(A1) & ~(B0) & C0 & ~(D0) & ~(D1) & S) | (~(A0) & B0 & ~(B1) & C0 & ~(D0) & ~(D1) & S) | (~(A0) & ~(B0) & C0 & ~(D0) & ~(D1) & S))
         (C1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C0 & ~(C1) & D1 & ~(S)) | (A0 & ~(A1) & ~(B0) & C0 & ~(C1) & D1 & ~(S)) | (~(A0) & B0 & ~(B1) & C0 & ~(C1) & D1 & ~(S)) | (~(A0) & ~(B0) & C0 & ~(C1) & D1 & ~(S)))
         (D0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & ~(C0) & C1 & D1 & ~(S)) | (A0 & ~(A1) & ~(B0) & ~(C0) & C1 & D1 & ~(S)) | (~(A0) & B0 & ~(B1) & ~(C0) & C1 & D1 & ~(S)) | (~(A0) & ~(B0) & ~(C0) & C1 & D1 & ~(S)))
         (D0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & ~(C0) & ~(C1) & D1 & ~(S)) | (A0 & ~(A1) & ~(B0) & ~(C0) & ~(C1) & D1 & ~(S)) | (~(A0) & B0 & ~(B1) & ~(C0) & ~(C1) & D1 & ~(S)) | (~(A0) & ~(B0) & ~(C0) & ~(C1) & D1 & ~(S)))
         (D0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C0 & ~(C1) & D1 & S) | (A0 & ~(A1) & ~(B0) & C0 & ~(C1) & D1 & S) | (~(A0) & B0 & ~(B1) & C0 & ~(C1) & D1 & S) | (~(A0) & ~(B0) & C0 & ~(C1) & D1 & S))
         (D0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & ~(C0) & C1 & D1 & S) | (A0 & ~(A1) & ~(B0) & ~(C0) & C1 & D1 & S) | (~(A0) & B0 & ~(B1) & ~(C0) & C1 & D1 & S) | (~(A0) & ~(B0) & ~(C0) & C1 & D1 & S))
         (D0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & ~(C0) & ~(C1) & D1 & S) | (A0 & ~(A1) & ~(B0) & ~(C0) & ~(C1) & D1 & S) | (~(A0) & B0 & ~(B1) & ~(C0) & ~(C1) & D1 & S) | (~(A0) & ~(B0) & ~(C0) & ~(C1) & D1 & S))
         (D0 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C0 & ~(C1) & D0 & ~(S)) | (A0 & ~(A1) & ~(B0) & C0 & ~(C1) & D0 & ~(S)) | (~(A0) & B0 & ~(B1) & C0 & ~(C1) & D0 & ~(S)) | (~(A0) & ~(B0) & C0 & ~(C1) & D0 & ~(S)))
         (D1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & ~(C0) & C1 & D0 & ~(S)) | (A0 & ~(A1) & ~(B0) & ~(C0) & C1 & D0 & ~(S)) | (~(A0) & B0 & ~(B1) & ~(C0) & C1 & D0 & ~(S)) | (~(A0) & ~(B0) & ~(C0) & C1 & D0 & ~(S)))
         (D1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & ~(C0) & ~(C1) & D0 & ~(S)) | (A0 & ~(A1) & ~(B0) & ~(C0) & ~(C1) & D0 & ~(S)) | (~(A0) & B0 & ~(B1) & ~(C0) & ~(C1) & D0 & ~(S)) | (~(A0) & ~(B0) & ~(C0) & ~(C1) & D0 & ~(S)))
         (D1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C0 & ~(C1) & D0 & S) | (A0 & ~(A1) & ~(B0) & C0 & ~(C1) & D0 & S) | (~(A0) & B0 & ~(B1) & C0 & ~(C1) & D0 & S) | (~(A0) & ~(B0) & C0 & ~(C1) & D0 & S))
         (D1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & ~(C0) & C1 & D0 & S) | (A0 & ~(A1) & ~(B0) & ~(C0) & C1 & D0 & S) | (~(A0) & B0 & ~(B1) & ~(C0) & C1 & D0 & S) | (~(A0) & ~(B0) & ~(C0) & C1 & D0 & S))
         (D1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & ~(C0) & ~(C1) & D0 & S) | (A0 & ~(A1) & ~(B0) & ~(C0) & ~(C1) & D0 & S) | (~(A0) & B0 & ~(B1) & ~(C0) & ~(C1) & D0 & S) | (~(A0) & ~(B0) & ~(C0) & ~(C1) & D0 & S))
         (D1 => Z) = 0;
      if ((A0 & ~(A1) & B0 & ~(B1) & C0 & ~(C1) & D0 & ~(D1)) | (A0 & ~(A1) & B0 & ~(B1) & C0 & ~(C1) & ~(D0)) | (A0 & ~(A1) & B0 & ~(B1) & ~(C0) & D0 & ~(D1)) | (A0 & ~(A1) & B0 & ~(B1) & ~(C0) & ~(D0)) | (A0 & ~(A1) & ~(B0) & C0 & ~(C1) & D0 & ~(D1)) | (A0 & ~(A1) & ~(B0) & C0 & ~(C1) & ~(D0)) | (A0 & ~(A1) & ~(B0) & ~(C0) & D0 & ~(D1)) | (A0 & ~(A1) & ~(B0) & ~(C0) & ~(D0)) | (~(A0) & B0 & ~(B1) & C0 & ~(C1) & D0 & ~(D1)) | (~(A0) & B0 & ~(B1) & C0 & ~(C1) & ~(D0)) | (~(A0) & B0 & ~(B1) & ~(C0) & D0 & ~(D1)) | (~(A0) & B0 & ~(B1) & ~(C0) & ~(D0)) | (~(A0) & ~(B0) & C0 & ~(C1) & D0 & ~(D1)) | (~(A0) & ~(B0) & C0 & ~(C1) & ~(D0)) | (~(A0) & ~(B0) & ~(C0) & D0 & ~(D1)) | (~(A0) & ~(B0) & ~(C0) & ~(D0)))
         (S => Z) = 0;
      if ((A0 & A1) | (A0 & ~(A1) & B0 & B1) | (A0 & ~(A1) & B0 & ~(B1) & C0 & C1) | (A0 & ~(A1) & B0 & ~(B1) & C0 & ~(C1) & D0 & D1) | (A0 & ~(A1) & B0 & ~(B1) & ~(C0) & D0 & D1) | (A0 & ~(A1) & ~(B0) & C0 & C1) | (A0 & ~(A1) & ~(B0) & C0 & ~(C1) & D0 & D1) | (A0 & ~(A1) & ~(B0) & ~(C0) & D0 & D1) | (~(A0) & B0 & B1) | (~(A0) & B0 & ~(B1) & C0 & C1) | (~(A0) & B0 & ~(B1) & C0 & ~(C1) & D0 & D1) | (~(A0) & B0 & ~(B1) & ~(C0) & D0 & D1) | (~(A0) & ~(B0) & C0 & C1) | (~(A0) & ~(B0) & C0 & ~(C1) & D0 & D1) | (~(A0) & ~(B0) & ~(C0) & D0 & D1))
         (S => Z) = 0;
   endspecify

   `endif

endmodule
`endcelldefine

//%END SEH_RAD8BOOTHMUX_8

//%BEGIN SEH_RDCAP16

`celldefine
module SEH_RDCAP16 ();
endmodule
`endcelldefine

//%END SEH_RDCAP16

//%BEGIN SEH_RDCAP32

`celldefine
module SEH_RDCAP32 ();
endmodule
`endcelldefine

//%END SEH_RDCAP32

//%BEGIN SEH_RDCAP4

`celldefine
module SEH_RDCAP4 ();
endmodule
`endcelldefine

//%END SEH_RDCAP4

//%BEGIN SEH_RDCAP64

`celldefine
module SEH_RDCAP64 ();
endmodule
`endcelldefine

//%END SEH_RDCAP64

//%BEGIN SEH_RDCAP8

`celldefine
module SEH_RDCAP8 ();
endmodule
`endcelldefine

//%END SEH_RDCAP8

//%BEGIN SEH_SUBH_1

`celldefine
module SEH_SUBH_1 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      xnor #1 (S, A, B);
      or #1 (CO, A, B);
   `else
      xnor (S, A, B);
      or (CO, A, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (B)
         (A => S) = 0;
      if (~(B))
         (A => S) = 0;
      if (A)
         (B => S) = 0;
      if (~(A))
         (B => S) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_SUBH_1

//%BEGIN SEH_SUBH_2

`celldefine
module SEH_SUBH_2 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      xnor #1 (S, A, B);
      or #1 (CO, A, B);
   `else
      xnor (S, A, B);
      or (CO, A, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (B)
         (A => S) = 0;
      if (~(B))
         (A => S) = 0;
      if (A)
         (B => S) = 0;
      if (~(A))
         (B => S) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_SUBH_2

//%BEGIN SEH_SUBH_4

`celldefine
module SEH_SUBH_4 (S, CO, A, B);
   output S, CO;
   input A, B;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      xnor #1 (S, A, B);
      or #1 (CO, A, B);
   `else
      xnor (S, A, B);
      or (CO, A, B);
   `endif

   `ifdef VIRL_functiononly

   `else

   /////////////////////////////////////
   //             TIMING              //
   /////////////////////////////////////


   specify
      (A => CO) = 0;
      (B => CO) = 0;
      if (B)
         (A => S) = 0;
      if (~(B))
         (A => S) = 0;
      if (A)
         (B => S) = 0;
      if (~(A))
         (B => S) = 0;
   endspecify

   `endif
endmodule
`endcelldefine

//%END SEH_SUBH_4

//%BEGIN SEH_TAPDS1T5

`celldefine
module SEH_TAPDS1T5 ();
endmodule
`endcelldefine

//%END SEH_TAPDS1T5

//%BEGIN SEH_TIE0_G_1

`celldefine
module SEH_TIE0_G_1 (X);
   output X;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////

   `ifdef VIRL_functiononly
      buf #1 (X, 1'b0);
   `else
      buf (X, 1'b0);
   `endif


   specify
   endspecify

endmodule
`endcelldefine

//%END SEH_TIE0_G_1

//%BEGIN SEH_TIE1_G_1

`celldefine
module SEH_TIE1_G_1 (X);
   output X;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////


   `ifdef VIRL_functiononly
     buf #1 (X, 1'b1);
   `else
     buf (X, 1'b1);
   `endif


   specify
   endspecify

endmodule
`endcelldefine

//%END SEH_TIE1_G_1

//%BEGIN SEH_TIEDIN_G_1

`celldefine
module SEH_TIEDIN_G_1 (X);
   input X;

   /////////////////////////////////////
   //          FUNCTIONALITY          //
   /////////////////////////////////////



   specify
   endspecify

endmodule
`endcelldefine
//%END SEH_TIEDIN_G_1
`ifdef _udp_def_mux2_
`else
`define _udp_def_mux2_
primitive mux2 (q, i1, i0, s0);
   input i1, i0, s0;
   output q;
   table
        ?  0  0 : 0;
        ?  1  0 : 1;
        0  ?  1 : 0;
        1  ?  1 : 1;
        0  0  ? : 0;
        1  1  ? : 1;
   endtable
endprimitive
`endif
`ifdef _udp_def_mux4_
`else
`define _udp_def_mux4_
primitive mux4 (q, i3, i2, i1, i0, s1, s0);
   input i3, i2, i1, i0, s1, s0;
   output q;
   table
        ?  ?  ?  0  0  0 : 0;
        ?  ?  ?  1  0  0 : 1;
        ?  ?  0  ?  0  1 : 0;
        ?  ?  1  ?  0  1 : 1;
        ?  0  ?  ?  1  0 : 0;
        ?  1  ?  ?  1  0 : 1;
        0  ?  ?  ?  1  1 : 0;
        1  ?  ?  ?  1  1 : 1;
        ?  ?  0  0  0  ? : 0;
        ?  ?  1  1  0  ? : 1;
        0  0  ?  ?  1  ? : 0;
        1  1  ?  ?  1  ? : 1;
        ?  0  ?  0  ?  0 : 0;
        ?  1  ?  1  ?  0 : 1;
        0  ?  0  ?  ?  1 : 0;
        1  ?  1  ?  ?  1 : 1;
        0  0  0  0  ?  ? : 0;
        1  1  1  1  ?  ? : 1;
   endtable
endprimitive
`endif
`ifdef _udp_def_latch_
`else
`define _udp_def_latch_
primitive latch (q, v, clk, d);
   output q;
   reg q;
   input v, clk, d;
   table
      * ? ? : ? : x;
      ? 1 0 : ? : 0;
      ? 1 1 : ? : 1;
      ? x 0 : 0 : -;
      ? x 1 : 1 : -;
      ? 0 ? : ? : -;
   endtable
endprimitive
`endif
`ifdef _udp_def_latch_r_
`else
`define _udp_def_latch_r_
primitive latch_r (q, v, clk, d, r);
   output q;
   reg q;
   input v, clk, d, r;
   table
      * ? ? ? : ? : x;
      ? ? ? 1 : ? : 0;
      ? 0 ? 0 : ? : -;
      ? 0 ? x : 0 : -;
      ? 1 0 0 : ? : 0;
      ? 1 0 x : ? : 0;
      ? 1 1 0 : ? : 1;
      ? x 0 0 : 0 : -;
      ? x 0 x : 0 : -;
      ? x 1 0 : 1 : -;
   endtable
endprimitive
`endif
`ifdef _udp_def_latch_s_
`else
`define _udp_def_latch_s_
primitive latch_s (q, v, clk, d, s);
   output q;
   reg q;
   input v, clk, d, s;
   table
      * ? ? ? : ? : x;
      ? ? ? 1 : ? : 1;
      ? 0 ? 0 : ? : -;
      ? 0 ? x : 1 : -;
      ? 1 1 0 : ? : 1;
      ? 1 1 x : ? : 1;
      ? 1 0 0 : ? : 0;
      ? x 1 0 : 1 : -;
      ? x 1 x : 1 : -;
      ? x 0 0 : 0 : -;
   endtable
endprimitive
`endif
`ifdef _udp_def_latch_sr_0_
`else
`define _udp_def_latch_sr_0_
primitive latch_sr_0 (q, v, clk, d, s, r);
     output q;
   reg q;
   input v, clk, d, s, r;
   table
      * ? ? ? ? : ? : x;
      ? ? ? ? 1 : ? : 0;
      ? ? ? 1 0 : ? : 1;
      ? 0 ? 0 0 : ? : -;
      ? 0 ? x 0 : 1 : -;
      ? 0 ? 0 x : 0 : -;
      ? 1 0 0 0 : ? : 0;
      ? 1 0 0 x : ? : 0;
      ? 1 1 x 0 : ? : 1;
      ? 1 1 0 0 : ? : 1;
      ? x 0 0 0 : 0 : -;
      ? x 0 0 x : 0 : -;
      ? x 1 0 0 : 1 : -;
      ? x 1 x 0 : 1 : -;
   endtable
endprimitive
`endif
`ifdef _udp_def_dff_err_
`else
`define _udp_def_dff_err_
primitive dff_err (q, clk, d);
   output q;
   reg q;
   input clk, d;
   table
      (0x) ? : ? : 0;
      (1x) ? : ? : 1;
   endtable
endprimitive
`endif
`ifdef _udp_def_dff_
`else
`define _udp_def_dff_
primitive dff (q, v, clk, d, xcr);
   output q;
   reg q;
   input v, clk, d, xcr;
   table
      *  ?   ? ? : ? : x;
      ? (x1) 0 0 : ? : 0;
      ? (x1) 1 0 : ? : 1;
      ? (x1) 0 1 : 0 : 0;
      ? (x1) 1 1 : 1 : 1;
      ? (x1) ? x : ? : -;
      ? (bx) 0 ? : 0 : -;
      ? (bx) 1 ? : 1 : -;
      ? (x0) b ? : ? : -;
      ? (x0) ? x : ? : -;
      ? (01) 0 ? : ? : 0;
      ? (01) 1 ? : ? : 1;
      ? (10) ? ? : ? : -;
      ?  b   * ? : ? : -;
      ?  ?   ? * : ? : -;
   endtable
endprimitive
`endif
`ifdef _udp_def_dff_r_err_
`else
`define _udp_def_dff_r_err_
primitive dff_r_err (q, clk, d, r);
   output q;
   reg q;
   input clk, d, r;
   table
       ?   0 (0x) : ? : -;
       ?   0 (x0) : ? : -;
      (0x) ?  0   : ? : 0;
      (0x) 0  x   : ? : 0;
      (1x) ?  0   : ? : 1;
      (1x) 0  x   : ? : 1;
   endtable
endprimitive
`endif
`ifdef _udp_def_dff_r_
`else
`define _udp_def_dff_r_
primitive dff_r (q, v, clk, d, r, xcr);
   output q;
   reg q;
   input v, clk, d, r, xcr;
   table
      *  ?   ?  ?   ? : ? : x;
      ?  ?   ?  1   ? : ? : 0;
      ?  b   ? (1?) ? : 0 : -;
      ?  x   0 (1?) ? : 0 : -;
      ?  ?   ? (10) ? : ? : -;
      ?  ?   ? (x0) ? : ? : -;
      ?  ?   ? (0x) ? : 0 : -;
      ? (x1) 0  ?   0 : ? : 0;
      ? (x1) 1  0   0 : ? : 1;
      ? (x1) 0  ?   1 : 0 : 0;
      ? (x1) 1  0   1 : 1 : 1;
      ? (x1) ?  ?   x : ? : -;
      ? (bx) 0  ?   ? : 0 : -;
      ? (bx) 1  0   ? : 1 : -;
      ? (x0) 0  ?   ? : ? : -;
      ? (x0) 1  0   ? : ? : -;
      ? (x0) ?  0   x : ? : -;
      ? (01) 0  ?   ? : ? : 0;
      ? (01) 1  0   ? : ? : 1;
      ? (10) ?  ?   ? : ? : -;
      ?  b   *  ?   ? : ? : -;
      ?  ?   ?  ?   * : ? : -;
   endtable
endprimitive
`endif
`ifdef _udp_def_dff_s_err_
`else
`define _udp_def_dff_s_err_
primitive dff_s_err (q, clk, d, s);
   output q;
   reg q;
   input clk, d, s;
   table
       ?   1 (0x) : ? : -;
       ?   1 (x0) : ? : -;
      (0x) ?  0   : ? : 0;
      (0x) 1  x   : ? : 0;
      (1x) ?  0   : ? : 1;
      (1x) 1  x   : ? : 1;
   endtable
endprimitive
`endif
`ifdef _udp_def_dff_s_
`else
`define _udp_def_dff_s_
primitive dff_s (q, v, clk, d, s, xcr);
   output q;
   reg q;
   input v, clk, d, s, xcr;
   table
      *  ?   ?  ?   ? : ? : x;
      ?  ?   ?  1   ? : ? : 1;
      ?  b   ? (1?) ? : 1 : -;
      ?  x   1 (1?) ? : 1 : -;
      ?  ?   ? (10) ? : ? : -;
      ?  ?   ? (x0) ? : ? : -;
      ?  ?   ? (0x) ? : 1 : -;
      ? (x1) 0  0   0 : ? : 0;
      ? (x1) 1  ?   0 : ? : 1;
      ? (x1) 1  ?   1 : 1 : 1;
      ? (x1) 0  0   1 : 0 : 0;
      ? (x1) ?  ?   x : ? : -;
      ? (bx) 1  ?   ? : 1 : -;
      ? (bx) 0  0   ? : 0 : -;
      ? (x0) 1  ?   ? : ? : -;
      ? (x0) 0  0   ? : ? : -;
      ? (x0) ?  0   x : ? : -;
      ? (01) 1  ?   ? : ? : 1;
      ? (01) 0  0   ? : ? : 0;
      ? (10) ?  ?   ? : ? : -;
      ?  b   *  ?   ? : ? : -;
      ?  ?   ?  ?   * : ? : -;
   endtable
endprimitive
`endif
`ifdef _udp_def_dff_sr_err_
`else
`define _udp_def_dff_sr_err_
primitive dff_sr_err (q, clk, d, s, r);
   output q;
   reg q;
   input clk, d, s, r;
   table
       ?   1 (0x)  ?   : ? : -;
       ?   1 (x0)  ?   : ? : -;
       ?   0  ?   (0x) : ? : -;
       ?   0  ?   (x0) : ? : -;
      (0x) ?  0    0   : ? : 0;
      (0x) 1  x    0   : ? : 0;
      (0x) 0  0    x   : ? : 0;
      (1x) ?  0    0   : ? : 1;
      (1x) 1  x    0   : ? : 1;
      (1x) 0  0    x   : ? : 1;
   endtable
endprimitive
`endif
`ifdef _udp_def_dff_sr_0_
`else
`define _udp_def_dff_sr_0_
primitive dff_sr_0 (q, v, clk, d, s, r, xcr);
   output q;
   reg q;
   input v, clk, d, s, r, xcr;
   table
   //   v,  clk, d, s, r : q' : q;
      *  ?   ?   ?   ?   ? : ? : x;
      ?  ?   ?   ?   1   ? : ? : 0;
      ?  ?   ?   1   0   ? : ? : 1;
      ?  b   ? (1?)  0   ? : 1 : -;
      ?  x   1 (1?)  0   ? : 1 : -;
      ?  ?   ? (10)  0   ? : ? : -;
      ?  ?   ? (x0)  0   ? : ? : -;
      ?  ?   ? (0x)  0   ? : 1 : -;
      ?  b   ?  0   (1?) ? : 0 : -;
      ?  x   0  0   (1?) ? : 0 : -;
      ?  ?   ?  0   (10) ? : ? : -;
      ?  ?   ?  0   (x0) ? : ? : -;
      ?  ?   ?  0   (0x) ? : 0 : -;
      ? (x1) 0  0    ?   0 : ? : 0;
      ? (x1) 1  ?    0   0 : ? : 1;
      ? (x1) 0  0    ?   1 : 0 : 0;
      ? (x1) 1  ?    0   1 : 1 : 1;
      ? (x1) ?  ?    0   x : ? : -;
      ? (x1) ?  0    ?   x : ? : -;
      ? (1x) 0  0    ?   ? : 0 : -;
      ? (1x) 1  ?    0   ? : 1 : -;
      ? (x0) 0  0    ?   ? : ? : -;
      ? (x0) 1  ?    0   ? : ? : -;
      ? (x0) ?  0    0   x : ? : -;
      ? (0x) 0  0    ?   ? : 0 : -;
      ? (0x) 1  ?    0   ? : 1 : -;
      ? (01) 0  0    ?   ? : ? : 0;
      ? (01) 1  ?    0   ? : ? : 1;
      ? (10) ?  0    ?   ? : ? : -;
      ? (10) ?  ?    0   ? : ? : -;
      ?  b   *  0    ?   ? : ? : -;
      ?  b   *  ?    0   ? : ? : -;
      ?  ?   ?  ?    ?   * : ? : -;
   endtable
endprimitive
`endif
//----------------------------------------------------------------------
//      Cell        : SEH_FILL1
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL12
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL16
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL2
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL3
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL32
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL4
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL5
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL6
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL64
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL8
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_CAPL8
//      Description : "Endcap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_CAPLNOPG8
//      Description : "Endcap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_CAPLV2Y8
//      Description : "Endcap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_CAPR8
//      Description : "Endcap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_CAPRNOPG8
//      Description : "Endcap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_CAPRV2Y8
//      Description : "Endcap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO1
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO10
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO11
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO12
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO13
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO14
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO15
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO16
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO17
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO18
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO19
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO2
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO20
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO3
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO4
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO5
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO6
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO7
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO8
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECO9
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECOV2Y1
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECOV2Y16
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECOV2Y2
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECOV2Y3
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECOV2Y4
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_ECOV2Y8
//      Description : "Filler cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLNOPG1
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLNOPG12
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLNOPG16
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLNOPG2
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLNOPG3
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLNOPG32
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLNOPG4
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLNOPG5
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLNOPG6
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLNOPG64
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLNOPG8
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_PO1
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_POV2Y1
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILL_PONOPG1
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLV2Y1
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLV2Y12
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLV2Y16
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLV2Y2
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLV2Y3
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLV2Y32
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLV2Y4
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLV2Y5
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLV2Y6
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLV2Y64
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_FILLV2Y8
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_TAPDS1T5
//      Description : "Tap cell"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_DCAP16
//      Description : "Filler cell with De-coupling"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_DCAP32
//      Description : "Filler cell with De-coupling"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_DCAP4
//      Description : "Filler cell with De-coupling"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_DCAP64
//      Description : "Filler cell with De-coupling"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_DCAP8
//      Description : "Filler cell with De-coupling"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_RDCAP16
//      Description : "Filler cell with De-coupling"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_RDCAP32
//      Description : "Filler cell with De-coupling"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_RDCAP4
//      Description : "Filler cell with De-coupling"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_RDCAP64
//      Description : "Filler cell with De-coupling"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
//----------------------------------------------------------------------
//      Cell        : SEH_RDCAP8
//      Description : "Filler cell with De-coupling"
//      Equation    : None
//      Version     : 5.7
//      Created     : 2009/04/30 14:13:44
//
