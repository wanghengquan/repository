//---------------------------------------------------------------------
//               Copyright(c) Synopsys, Inc.                           
//     All Rights reserved - Unpublished -rights reserved under        
//     the Copyright laws of the United States of America.             
//                                                                     
//  U.S. Patents: 7,093,156 B1 and 7,406,620 B2 (and more pending).    
//                                                                     
//  This file includes the Confidential information of Synopsys, Inc.    
//  and UMC.                                                           
//  The receiver of this Confidential Information shall not disclose   
//  it to any third party and shall protect its confidentiality by     
//  using the same degree of care, but not less then a reasonable      
//  degree of care, as the receiver uses to protect receiver's own     
//  Confidential Information.                                          
//  Licensee acknowledges and agrees that all output generated for     
//  Licensee by Synopsys, Inc. as described in the pertinent Program   
//  Schedule(s), or generated by Licensee through use of any Compiler  
//  licensed hereunder contains information that complies with the     
//  Virtual Component Identification Physical Tagging Standard (VCID)  
//  as maintained by the Virtual Socket Interface Alliance (VSIA).     
//  Such information may be expressed in GDSII Layer 63 or other such  
//  layer designated by the VSIA, hardware definition languages, or    
//  other formats.  Licensee is not authorized to alter or change any  
//  such information.                                                  
//---------------------------------------------------------------------
//                                                                     
//  Software           : Rev: F-2011.12-SP1 (Jan 23, 2012)             
//  Library Format     : Rev: 1.05.00                                  
//  Compiler Name      : um40npk42p11sadrl32ksa02                      
//  Platform           : Linux2.6.18-238.el5                           
//                     : #1 SMP Sun Dec 19 14:22:44 EST 2010x86_64     
//  Date of Generation : Fri Aug 24 04:22:03 PDT 2012                  
//                                                                     
//---------------------------------------------------------------------
//   --------------------------------------------------------------     
//                       Template Revision : 1.9.6                      
//   --------------------------------------------------------------     




//                 * Synchronous, 2-Port Register File *              
//                   * Fast Functional Verilog Model *                
//                THIS IS A SYNCHRONOUS 2-PORT MEMORY MODEL           
//                                                                    
//   Memory Name:sadrlspk42p256x16m2b1w1c0p1d0t0                      
//   Memory Size:256 words x 16 bits                                  
//                                                                    
//                               PORT NAME                            
//                               ---------                            
//               Output Ports                                         
//                                   QB[15:0]                         
//               Input Ports:                                         
//                                   ADRA[7:0]                        
//                                   DA[15:0]                         
//                                   WEMA[15:0]                       
//                                   WEA                              
//                                   MEA                              
//                                   CLKA                             
//                                   TEST1A                           
//                                   RMA[3:0]                         
//                                   RMEA                             
//                                   LS                               
//                                   DS                               
//                                   SD                               
//                                   ADRB[7:0]                        
//                                   MEB                              
//                                   CLKB                             
//                                   TEST1B                           
//                                   RMB[3:0]                         
//                                   RMEB                             

`resetall 
`timescale 1 ns / 1 ps 
`celldefine 
`ifdef verifault // for fault simulation purpose 
`suppress_faults 
`enable_portfaults 
`endif 

`define True    1'b1
`define False   1'b0

//module sadrlspk42p256x16m2b1w1c0p1d0t0 ( QB, ADRA, DA, WEMA, WEA, MEA, CLKA, TEST1A, RMA, RMEA, LS, DS, SD, ADRB, MEB, CLKB, TEST1B, RMB, RMEB);
module leafcell_2prf_4kip_u40_schematic ( QB, ADRA, ADRB, CLKA, CLKB,
     DA, DS, LS, MEA, MEB, RMA, RMB, RMEA, RMEB, SD, TEST1A, TEST1B,
     VDD, VSS, WEA, WEMA );

// Input/Output Ports Declaration
input VDD,VSS;
output  [15:0] QB;
input  [7:0] ADRA;
input  [15:0] DA;
input  [15:0] WEMA;
input WEA;
input MEA;
input CLKA;
input TEST1A;
input  [3:0] RMA;
input RMEA;
input LS;
input DS;
input SD;
input  [7:0] ADRB;
input MEB;
input CLKB;
input TEST1B;
input  [3:0] RMB;
input RMEB;

// Local registers, wires, etc
`ifdef MEM_CHECK_OFF
parameter MES_CNTRL = "OFF";
`else
parameter MES_CNTRL = "ON";
`endif
parameter TCSEP = 0.001;



`ifndef VIRAGE_IGNORE_SD_HAZARD
reg ds_sd_buf;

initial
 ds_sd_buf = 1'b0;

always @(posedge SD)
begin
  if (DS === 1'b1)
  begin
    ds_sd_buf <= 1'b1;
  end
end

always @(SD)
begin
  if (SD === 1'b0)
  begin
    ds_sd_buf <= 1'b0;
  end
end
`endif

wire sel_pwr;
`ifndef VIRAGE_IGNORE_SD_HAZARD
wire sel_pwr_ds_sd;
assign sel_pwr_ds_sd = DS || SD;
assign sel_pwr = ( ds_sd_buf === 1'b0) ? sel_pwr_ds_sd : 1'bx;
`else
assign sel_pwr = DS || SD;
`endif


wire sel_pwr1A,inv_sel_pwr1A;
assign inv_sel_pwr1A = !(sel_pwr1A);
assign sel_pwr1A = ((CLKA === 1'b0) ? sel_pwr : ((CLKA === 1'b1) ? sel_pwr1A : (sel_pwr | sel_pwr1A)));
assign CLKA_mout = CLKA && inv_sel_pwr1A;

wire sel_pwr1B,inv_sel_pwr1B;
assign inv_sel_pwr1B = !(sel_pwr1B);
assign sel_pwr1B = ((CLKB === 1'b0) ? sel_pwr : ((CLKB === 1'b1) ? sel_pwr1B : (sel_pwr | sel_pwr1B)));
assign CLKB_mout = CLKB && inv_sel_pwr1B;

reg flag_sel_tmp_pwr;
always @ (sel_pwr)
begin
  if ( (DS === 1'b1) || (SD === 1'b1) )
  begin
    flag_sel_tmp_pwr = 1'b1;
  end
  else if ( sel_pwr === 1'bX )
  begin
    flag_sel_tmp_pwr = 1'b0;
  end
  else if ( (DS === 1'b0) && (SD === 1'b0) && flag_sel_tmp_pwr)
  begin
  #0.0;
    uut.QB <= 16'b0;
  end
end
wire [15:0] QB_mem;
wire [15:0] QB_tmp;
reg  [15:0] QB_buf;
assign QB_tmp = ((sel_pwr === 1'bX ) ? 16'bx : ((sel_pwr === 1'b0 ) ? QB_mem : 16'b0));

always @ ( posedge DS or posedge SD )
begin
  if ( (SD !== 1'bX) && (DS !== 1'bX) )
    uut.QB <= 16'b0;
end

always @ ( QB_tmp )
begin
  QB_buf <= QB_tmp;
end

assign QB = QB_buf;

generic_behav_sadrlspk42p256x16m2b1w1c0p1d0t0 #( MES_CNTRL, TCSEP) uut ( .QB(QB_mem), .ADRA(ADRA), .DA(DA), .WEMA(WEMA), .WEA(WEA), .MEA(MEA), .CLKA(CLKA_mout), .LS(LS), .DS(DS), .SD(SD), .ADRB(ADRB), .MEB(MEB), .CLKB(CLKB_mout) );

endmodule

`endcelldefine 
`ifdef verifault 
`disable_portfaults 
`nosuppress_faults 
`endif 


module generic_behav_sadrlspk42p256x16m2b1w1c0p1d0t0 (  QB, ADRA, DA, WEMA, WEA, MEA, CLKA, LS, DS, SD, ADRB, MEB, CLKB );

parameter MES_CNTRL = "ON";
parameter TCSEP = 0.001;
parameter words = 256, bits = 16, addrbits = 8, wembits=16;

output [bits-1:0] QB;
input [addrbits-1:0] ADRA;
input [bits-1:0] DA;
input [wembits-1:0] WEMA;
input WEA;
input MEA;
input CLKA;
input LS;
input DS;
input SD;
input [addrbits-1:0] ADRB;
input MEB;
input CLKB;

reg [bits-1:0] QB;

reg [addrbits-1:0] ADRAlatched;
reg WEAlatched;
reg [bits-1:0] DAlatched;
reg [wembits-1:0] WEMAlatched;

reg [addrbits-1:0] ADRBlatched;

reg MEAlatched;
reg MEBlatched;


real CLK_A_T, CLK_B_T;

reg flaga_clk_valid;
reg flagb_clk_valid;
reg mes_all_valid;

wire [1:0] ADRA_valid;
wire [1:0] ADRB_valid;
reg [15:0] mem_core_array [0:255];

parameter DataX = { bits { 1'bx } };

// -------------------------------------------------------------------
// Common tasks
// -------------------------------------------------------------------

// Task to report unknown messages
task report_unknown;
input [8*6:1] signal;
  begin
    if( (MES_CNTRL=="ON" || MES_CNTRL=="ERR") && $realtime != 0 && mes_all_valid )
    begin
      $display("<<VIRL_MEM_ERR:%0s unknown>> at time=%t; instance=%m (RAMS1H)",signal,$realtime);
    end
  end
endtask


task corrupt_all_loc;
 input flag_range_ok;
 integer addr_index;
 begin
   if( flag_range_ok == `True)
   begin
   for( addr_index = 0; addr_index < words; addr_index = addr_index + 1)
   begin
     mem_core_array[ addr_index] = DataX;
   end
  end
 end
endtask


/////////////////////////////////////////////
/////Simultaneous Clock handling
/////////////////////////////////////////////

reg same_edge;

always @( posedge same_edge ) 
begin : blk_same_edge
  if ((( ADRAlatched === ADRBlatched ) && (ADRA_valid == 2'b00)) && ( ^ADRAlatched !== 1'bx ) && ( ^ADRBlatched !== 1'bx ))
  begin
    if ( MEAlatched !== 1'b0 && MEBlatched !== 1'b0 && WEAlatched !== 1'b0 )
    begin
      QB = mem_core_array[ADRBlatched] ^ ( DataX & WEMAlatched);
    end // end if simultaneous write and read
  end // end of if ADRA and ADRB
end // end of block blk_same_edge

initial 
begin
  flaga_clk_valid = `False;
  mes_all_valid = 1'b0;
end 

assign ADRA_valid = (( ^ADRA === 1'bx ) ? 2'b01 : ( ( ADRA > 8'b11111111 ) ? 2'b10 : 2'b00 ));

always @ ( negedge CLKA )
begin : blk_negedge_clk_0
  if ( CLKA !== 1'bx )
  begin
    flaga_clk_valid = `True;
  end // end if CLKA != X
  else
  begin
    report_unknown("CLKA");
    flaga_clk_valid = `False;
    corrupt_all_loc(`True);
  end // end of else of CLKA != X
end // end of block blk_negedge_clk_0

always @ ( posedge CLKA )
begin : blk_posedge_clk_0
   CLK_A_T = $realtime;
   if (CLK_A_T - CLK_B_T < TCSEP)
     same_edge = 1'b1;
   else
     same_edge = 1'b0;
   ADRAlatched = ADRA;
   WEAlatched = WEA;
   DAlatched = DA;
   WEMAlatched = WEMA;
  MEAlatched = MEA;
  if ( (SD !== 1'b0) || (DS === 1'b1) || (DS === 1'b0 && LS === 1'b1) )
  begin
    MEAlatched = 1'b0;
  end
  if ( LS === 1'bX && (MEAlatched !== 1'b0 && WEA !== 1'b0) )
  begin
    report_unknown("LS");
    corrupt_all_loc(`True);
    QB = 16'bx;
  end
  else if ( DS === 1'bX )
  begin
    corrupt_all_loc(`True);
    QB = 16'bx;
  end
  else
  begin
    if ( flaga_clk_valid )
    begin
      if ( CLKA === 1'b1)
      begin
        if ( MEAlatched === 1'b1) 
        begin
          if ( WEA === 1'b1) 
          begin
            WritePortA;
          end // end of Write
          else
          begin
           if ( WEA === 1'bx )
           begin
            report_unknown("WEA");
            mem_core_array[ADRA] = DataX;
            if ( ADRA_valid === 2'b00 ) 
            begin
              if ( ^WEMA === 1'bx )
              begin
                report_unknown("WEMA");
                mem_core_array[ADRA] = mem_core_array[ADRA] ^ ( WEMA & DataX );
              end
            end // end of if ADRA_valid = 2'b00
            else if ( ADRA_valid === 2'b01 ) 
            begin
              if ( WEMA !== { wembits{1'b0}} )
              corrupt_all_loc(`True);
            end // end of else of ADRA_valid = 2'b01
           end // 
          end // end of else of WEA = X
        end // end of MEAlatched = 1
        else
        begin
          if ( MEAlatched === 1'bx ) 
          begin
            report_unknown("MEA");
            if ( WEA !== 1'b0 )
            begin
              corrupt_all_loc(`True);
            end
          end // end of if MEAlatched = X
        end // end of else of MEAlatched = 1
      end // end of if CLKA = 1
      else 
      begin
        if ( CLKA === 1'bx ) 
        begin
          report_unknown("CLKA");
          corrupt_all_loc(`True);
        end // end of if CLKA = 1'bx
      end // end of else of CLKA = 1
    end // end of if flaga_clk_valid = 1
    else 
    begin
      corrupt_all_loc(`True);
    end // end of else of flaga_clk_valid = 1
  end // end of else of LS = 1
end // end of block blk_posedge_clk_0


task WritePortA;
begin : blk_WritePortA
  if ( ADRA_valid === 2'b00 )
  begin
    mem_core_array[ADRA] = (( mem_core_array[ADRA] & ~WEMA ) | ( DA & WEMA ) ^ ( WEMA ^ WEMA ));
    if ( !mes_all_valid )
       mes_all_valid = 1'b1;
    if ( ^WEMA === 1'bx )
    begin
      report_unknown("WEMA");
    end
    if ( ^DA === 1'bx )
    begin
      report_unknown("DA");
    end
  end // end of if ADRA_valid = 2'b00
  else if (ADRA_valid === 2'b10 )
  begin
    if ( (MES_CNTRL == "ON" || MES_CNTRL == "WARN") && $realtime != 0 && mes_all_valid )
    begin
      $display("<<VIRL_MEM_WARNING:address is out of range\n RANGE:0 to 255>> at time=%t; instance=%m (RAMS1H)",$realtime);
    end // end of if mes_all_valid 
  end // end of else of ADRA_valid = 2'b10
  else 
  begin
    report_unknown("ADRA");
     if ( WEMA !== {wembits {1'b0}} )
    corrupt_all_loc(`True);
  end // end of else of ADRA_valid = 2'b01
end // end of block blk_WritePortA
endtask

// Display the warning when LS is 1.
always @ (LS or MEA)
begin : blk_LS_0
  if ( LS === 1'b1 && MEAlatched !== 1'b0 && DS === 1'b0 && SD === 1'b0 )
  begin
    if ( (MES_CNTRL == "ON" || MES_CNTRL == "WARN") && $realtime != 0 && mes_all_valid )
    begin
      $display("\n%m<<VIRL_MEM_WARNING: No Operation as Memory in Light Sleep>>.", $time);
    end // end if MES_CNTRL = ON
  end // end if LS = 1 with ME = 1
end // end blk_LS_0

initial 
begin
  flagb_clk_valid = `False;
  mes_all_valid = 1'b0;
end 

assign ADRB_valid = (( ^ADRB === 1'bx ) ? 2'b01 : ( ( ADRB > 8'b11111111 ) ? 2'b10 : 2'b00 ));

always @ ( negedge CLKB )
begin : blk_negedge_clk_1
  if ( CLKB !== 1'bx )
  begin
    flagb_clk_valid = `True;
  end // end if CLKB != X
  else
  begin
    report_unknown("CLKB");
    flagb_clk_valid = `False;
    QB = DataX;
    corrupt_all_loc(`True);
  end // end of else of CLKB != X
end // end of block blk_negedge_clk_1

always @ ( posedge CLKB )
begin : blk_posedge_clk_1
   CLK_B_T = $realtime;
   if (CLK_B_T - CLK_A_T < TCSEP)
     same_edge = 1'b1;
   else
     same_edge = 1'b0;
   ADRBlatched = ADRB;
  MEBlatched = MEB;
  if ( (SD !== 1'b0) || (DS === 1'b1) || (DS === 1'b0 && LS === 1'b1) )
  begin
    MEBlatched = 1'b0;
  end
  if ( LS === 1'bX && MEBlatched !== 1'b0 )
  begin
    report_unknown("LS");
    corrupt_all_loc(`True);
    QB = 16'bx;
  end
  else if ( DS === 1'bX )
  begin
    corrupt_all_loc(`True);
    QB = 16'bx;
  end
  else
  begin
    if ( flagb_clk_valid )
    begin
      if ( CLKB === 1'b1)
      begin
        if ( MEBlatched === 1'b1) 
        begin
            ReadPortB;
        end // end of MEBlatched = 1
        else
        begin
          if ( MEBlatched === 1'bx ) 
          begin
            report_unknown("MEB");
            QB = 16'bx;
            `ifdef virage_ignore_read_addx
            `else
               corrupt_all_loc(`True);
            `endif
          end // end of if MEBlatched = X
        end // end of else of MEBlatched = 1
      end // end of if CLKB = 1
      else 
      begin
        if ( CLKB === 1'bx ) 
        begin
          report_unknown("CLKB");
          QB = DataX;
          corrupt_all_loc(`True);
        end // end of if CLKB = 1'bx
      end // end of else of CLKB = 1
    end // end of if flagb_clk_valid = 1
    else 
    begin
      QB = DataX;
    end // end of else of flagb_clk_valid = 1
  end // end of else of LS = 1
end // end of block blk_posedge_clk_1



task ReadPortB;
begin : blk_ReadPortB
  if ( ADRB_valid === 2'b00 )
  begin
    QB = mem_core_array[ADRB];
  end // end of if ADRB_valid = 2'b00
  else if ( ADRB_valid === 2'b10 )
  begin
    QB = DataX;
    if ( (MES_CNTRL == "ON" || MES_CNTRL == "WARN") && $realtime != 0 && mes_all_valid )
    begin
      $display("<<VIRL_MEM_WARNING:address is out of range\n RANGE:0 to 255>> at time=%t; instance=%m (RAMS1H)",$realtime);
    end // end of if mes_all_valid
  end // end of else of ADRB_valid = 2'b10
  else 
  begin
    report_unknown("ADRB");
    QB = DataX;
    `ifdef virage_ignore_read_addx
    `else
       corrupt_all_loc(`True);
    `endif
  end // end of else of ADRB_valid = 2'b01
end // end of block blk_ReadPortB
endtask

// Display the warning when LS is 1.
always @ (LS or MEB)
begin : blk_LS_1
  if ( LS === 1'b1 && MEBlatched !== 1'b0 && DS === 1'b0 && SD === 1'b0 )
  begin
    if ( (MES_CNTRL == "ON" || MES_CNTRL == "WARN") && $realtime != 0 && mes_all_valid )
    begin
      $display("\n%m<<VIRL_MEM_WARNING: No Operation as Memory in Light Sleep>>.", $time);
    end // end if MES_CNTRL = ON
  end // end if LS = 1 with ME = 1
end // end blk_LS_1

always @ ( DS )
begin :blk_DS
  if ( DS === 1'bX )
  begin
    report_unknown("DS");
    QB = 16'bX;
  end // end id DS = X
end // end blk_DS

always @ (posedge SD )
begin : blk_SD
  corrupt_all_loc(`True);
  if ( SD === 1'bX )
  begin
    report_unknown("SD");
    QB = 16'bX;
  end
end // end blk_SD
endmodule
